<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#F2C31B" />
    <meta name="description" content="Mobile-first cleaning photo documentation app" />

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

    <!-- Prevent zoom on input fields -->
    <meta name="format-detection" content="telephone=no" />

    <!-- Status bar styling for iOS -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Cleaning App" />
    
    <!-- Additional iOS compatibility -->
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="apple-mobile-web-app-orientations" content="portrait" />

    <title>Cleaning Photo App</title>

    <!-- Google Fonts - Garamond -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

    <style>
      /* Prevent flash of unstyled content */
      body {
        margin: 0;
        padding: 0;
        font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif;
        background-color: #f8fafc;
        color: #1e293b;
        overscroll-behavior-y: auto;
        overscroll-behavior-x: none;
        overflow-x: hidden;
        width: 100vw;
        max-width: 100vw;
        height: 100vh;
      }
      
      * {
        box-sizing: border-box;
      }
      
      /* Hide scrollbars for swipeable elements */
      #room-tabs-container::-webkit-scrollbar {
        display: none;
      }
      
      #room-tabs-container {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      /* Loading spinner */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8fafc;
        z-index: 9999;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #e2e8f0;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Hide loading once React loads */
      #root:not(:empty) + .loading-container {
        display: none;
      }

      /* Debug info */
      .debug-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 10000;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <div class="loading-container">
      <div class="loading-spinner"></div>
    </div>
    
    <!-- Debug info (hidden by default) -->
    <div class="debug-info" id="debug-info" style="display: none;">
      <div>üöÄ HTML Loaded</div>
      <div>üì± User Agent: <span id="user-agent">Loading...</span></div>
      <div>üåê Location: <span id="location">Loading...</span></div>
      <div>‚è∞ Time: <span id="time">Loading...</span></div>
    </div>
    
    <script>
      // Basic debug info
      console.log('üöÄ Debug: HTML loaded');
      console.log('üöÄ Debug: User Agent:', navigator.userAgent);
      console.log('üöÄ Debug: Location:', window.location.href);
      
      // Update debug info
      document.getElementById('user-agent').textContent = navigator.userAgent.substring(0, 50) + '...';
      document.getElementById('location').textContent = window.location.href;
      document.getElementById('time').textContent = new Date().toLocaleTimeString();
      
      // Check if we're on iOS
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      console.log('üöÄ Debug: Is iOS:', isIOS);
      
      if (isIOS) {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">üçé iOS Detected</div>';
      }
      
      // Check if React loads
      let reactLoadTimer = setTimeout(() => {
        console.log('‚ùå Debug: React failed to load within 10 seconds');
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå React Failed to Load</div>';
      }, 10000);
      
      // Clear timer when React loads
      window.addEventListener('load', () => {
        clearTimeout(reactLoadTimer);
        console.log('‚úÖ Debug: Page fully loaded');
      });
      
      // Check for React errors
      window.addEventListener('error', (e) => {
        console.log('‚ùå Debug: JavaScript error:', e.error);
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå JS Error: ' + e.error.message + '</div>';
      });
      
      // Check for unhandled promise rejections
      window.addEventListener('unhandledrejection', (e) => {
        console.log('‚ùå Debug: Unhandled promise rejection:', e.reason);
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå Promise Error: ' + e.reason + '</div>';
      });
      
      // Monitor script loading
      const scripts = document.querySelectorAll('script[type="module"]');
      scripts.forEach((script, index) => {
        script.addEventListener('load', () => {
          console.log('‚úÖ Debug: Script ' + index + ' loaded successfully');
          document.getElementById('debug-info').innerHTML += '<div style="color: green;">‚úÖ Script ' + index + ' loaded</div>';
        });
        script.addEventListener('error', (e) => {
          console.log('‚ùå Debug: Script ' + index + ' failed to load:', e);
          document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå Script ' + index + ' failed: ' + e.message + '</div>';
        });
      });
      
      // Check if main.jsx loads
      console.log('üöÄ Debug: About to load main.jsx');
    </script>
    
    <!-- Simple JavaScript test -->
    <script>
      console.log('üß™ Debug: Testing basic JavaScript...');
      
      // Test if we can create DOM elements
      try {
        const testDiv = document.createElement('div');
        testDiv.innerHTML = '<div style="color: green;">‚úÖ Basic JavaScript Works!</div>';
        document.getElementById('debug-info').appendChild(testDiv);
        console.log('‚úÖ Debug: Basic JavaScript works');
      } catch (e) {
        console.log('‚ùå Debug: Basic JavaScript failed:', e);
      }
      
      // Test if we can fetch (for checking if the app files exist)
      fetch('/src/main.jsx')
        .then(response => {
          console.log('‚úÖ Debug: main.jsx file exists, status:', response.status);
          if (response.status === 200) {
            document.getElementById('debug-info').innerHTML += '<div style="color: green;">‚úÖ main.jsx file exists</div>';
          } else {
            document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå main.jsx file not found (status: ' + response.status + ')</div>';
          }
        })
        .catch(error => {
          console.log('‚ùå Debug: Cannot fetch main.jsx:', error);
          document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå Cannot fetch main.jsx: ' + error.message + '</div>';
        });
    </script>
    
    <!-- Try a very simple inline test first -->
    <script>
      console.log('üß™ Debug: Inline script starting...');
      try {
        const root = document.getElementById('root');
        if (root) {
          root.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Inline Script Works!</h1><p>JavaScript is executing on iPhone!</p></div>';
          console.log('‚úÖ Debug: Inline script successful');
        } else {
          console.log('‚ùå Debug: Root element not found in inline script');
        }
      } catch (e) {
        console.log('‚ùå Debug: Inline script error:', e);
      }
    </script>
    
    <!-- Try regular script (not module) -->
    <script>
      console.log('üß™ Debug: Testing regular script execution...');
      
      try {
        const rootElement = document.getElementById('root');
        if (rootElement) {
          rootElement.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Regular Script Works!</h1><p>This proves regular JavaScript works on iOS Safari.</p><p>Now loading bundled React app...</p></div>';
          console.log('‚úÖ Debug: Regular script execution successful');
        }
      } catch (error) {
        console.log('‚ùå Debug: Regular script failed:', error);
      }
    </script>
    
    <!-- iOS Safari Compatible Cleaning Photo App -->
    <script>
      console.log('üöÄ Debug: Loading iOS Safari compatible version...');
      
      // Simple photo documentation app
      class CleaningPhotoApp {
        constructor() {
          this.photos = [];
          this.currentRoom = 'kitchen';
          this.currentTab = 'photo';
          this.isLandscape = false;
          this.loadPhotos(); // Load photos first
          this.init();
        }
        
        init() {
          // Check orientation
          this.checkOrientation();
          
          // Reassign photo names to ensure proper sequential numbering
          this.reassignPhotoNames();
          
          const rootElement = document.getElementById('root');
          if (rootElement) {
            rootElement.innerHTML = this.getAppHTML();
            this.attachEventListeners();
            this.updateTabsCarousel(); // Update carousel layout
            
            // Auto-scroll to bottom after app initialization
            setTimeout(() => {
              const mainScrollableContent = document.getElementById('main-scrollable-content');
              if (mainScrollableContent) {
                console.log('Init: Scrolling to bottom of gallery');
                mainScrollableContent.scrollTop = mainScrollableContent.scrollHeight;
              }
            }, 300);
          }
          
          // Listen for orientation changes
          window.addEventListener('orientationchange', () => {
            setTimeout(() => {
              this.checkOrientation();
              this.init();
            }, 100);
          });
          
          window.addEventListener('resize', () => {
            this.checkOrientation();
            this.init();
          });

          // Add scroll listener for auto tab switching
          this.addScrollListener();
        }
        
        checkOrientation() {
          this.isLandscape = window.innerWidth > window.innerHeight;
        }
        
        getCameraModalHTML() {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <!-- Landscape camera - left/right split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Active camera -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Reference or inactive -->
                <div style="position: relative; width: 50%; height: 100%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls on the left</div>
                  </div>
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top/bottom split
            return `
              <!-- Portrait camera - top/bottom split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Active camera -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Reference or inactive -->
                <div style="position: relative; width: 100%; height: 50%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls above</div>
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getBeforePhotoModalHTML() {
          return `
            <div style="position: relative; width: 100vw; height: calc(100vh - 80px); display: flex; flex-direction: column;">
              <!-- Top half - Camera -->
              <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black;">
                <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                
                <!-- Photo frame overlay for camera -->
                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                  <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                </div>
                
                <!-- Before label -->
                <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                  BEFORE
                </div>
              </div>
              
              <!-- Room Tabs Section -->
              <div style="width: 100%; background: #f8fafc; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <div id="modal-room-tabs-container" style="position: relative; width: 100%; height: 60px; overflow: hidden;">
                  <div id="modal-tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                    ${this.getRoomTabsCarousel()}
                  </div>
                </div>
              </div>
              
              <!-- Bottom half - Photo Grid -->
              <div id="before-photo-grid" style="width: 100%; flex: 1; background: #f8f9fa; overflow-y: auto; padding: 10px; padding-bottom: 20px; min-height: 200px;">
                ${this.getBeforePhotosGridHTML()}
              </div>
              
              <!-- Close button -->
              <button id="close-before-modal-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                ‚úï
              </button>
            </div>
          `;
        }

        getBeforePhotosGridHTML() {
          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for current room
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp);

          // Create grid layout with all photos and dummy squares
          const gridItems = [];
          
          // Add all existing photos
          beforePhotos.forEach(photo => {
            gridItems.push(`
              <div class="before-photo-item" data-photo-id="${photo.id}" style="aspect-ratio: 1; border-radius: 8px; overflow: hidden; position: relative; cursor: pointer; border: 2px solid #e1e5e9; transition: all 0.2s;" onmouseover="this.style.borderColor='#F2C31B'; this.style.transform='scale(1.02)'" onmouseout="this.style.borderColor='#e1e5e9'; this.style.transform='scale(1)'">
                <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                
                <!-- Delete button -->
                <button class="delete-before-photo-btn" data-photo-id="${photo.id}" style="position: absolute; top: 5px; right: 5px; background: #F2C31B; color: #303030; border: none; padding: 6px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#e6b800'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='#F2C31B'; this.style.transform='scale(1)'">
                  √ó
                </button>
                
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 8px; color: white;">
                  <div style="font-size: 12px; font-weight: bold;">${photo.name}</div>
                  <div style="font-size: 10px; opacity: 0.9;">${new Date(photo.timestamp).toLocaleTimeString()}</div>
                </div>
              </div>
            `);
          });
          
          // Add one dummy square for taking more photos
          gridItems.push(`
            <div class="dummy-before-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; color: #999; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e8e8e8'; this.style.color='#666';" onmouseout="this.style.background='#f0f0f0'; this.style.color='#999';">
              ${roomIcons[this.currentRoom] || 'üì∑'}
            </div>
          `);

          return `
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; grid-auto-rows: minmax(120px, 1fr); align-content: start; min-height: 100%;">
              ${gridItems.join('')}
            </div>
          `;
        }

        getComparisonModalHTML(photo) {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Camera -->
                <div id="camera-container" style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Camera -->
                <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                </div>
                
                <!-- Close button -->
                <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room) {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row; background: white;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - After photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; background: white;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - After photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getAppHTML() {
          return `
            <div style="min-height: 100vh; background: #f8fafc; font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif; display: flex; flex-direction: column; overflow-x: hidden;">
              <!-- Header -->
              <div style="background: #F2C31B; color: #303030; padding: 4px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; max-width: 100vw; position: relative; z-index: 200;">
                <!-- Location dropdown -->
                <select id="location-select" style="background: white; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 14px; font-weight: bold; max-width: 120px;">
                  <option value="tampa">Tampa</option>
                  <option value="st-petersburg">St. Petersburg</option>
                  <option value="jacksonville">Jacksonville</option>
                  <option value="miami">Miami</option>
                </select>
                
                <!-- Cleaner name -->
                <div style="font-size: 16px; font-weight: bold;">Kate</div>
                
                <!-- Upload button -->
                <button id="header-upload-btn" style="background: #303030; color: #F2C31B; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold;">
                  üì§ Upload
                </button>
              </div>
              
              <!-- Fixed Room Tabs -->
              <div id="sticky-tabs-container" style="position: fixed; top: 0; left: 0; right: 0; z-index: 100; background: #f8fafc; padding: 10px; width: 100vw; box-sizing: border-box; display: flex; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <div id="room-tabs-container" style="position: relative; width: 100vw; height: 60px; overflow: hidden;">
                  <div id="tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                    ${this.getRoomTabsCarousel()}
                  </div>
                </div>
              </div>
              
              <!-- Scrollable Content -->
              <div id="main-scrollable-content" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 80px 10px 100px 10px; width: 100%; max-width: 100vw; box-sizing: border-box;">
                
                <!-- Photos grid with swipe -->
                <div id="photos-container" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; padding: 0 10px; max-width: 100%; box-sizing: border-box;">
                  ${this.getPhotosHTML()}
                </div>
                
              </div>
              
              <!-- Fixed Action Buttons Panel (only for camera modals) -->
              <div id="bottom-panel" style="position: fixed; bottom: 0; left: 0; right: 0; z-index: 2001; display: grid; grid-template-columns: 1fr 1fr 1fr; height: 80px; align-items: center;">
                <!-- Left Section - Retake Button (hidden by default) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-retake" style="background: #ef4444; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üîÑ Retake
                  </button>
                </div>

                <!-- Center Section - Camera Button (hidden by default for gallery, shown during photo capture) -->
                <div style="display: flex; justify-content: center;">
                  <button id="camera-btn" style="background: #F2C31B; border: none; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; box-shadow: 0 4px 12px rgba(48,48,48,0.3); display: none;"></button>
                </div>

                <!-- Right Section - Save Button (hidden by default) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-save" style="background: #10b981; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üíæ Save
                  </button>
                </div>
              </div>
              
            </div>
          `;
        }
        
        
        
        getRoomTabsCarousel() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          const currentIndex = rooms.indexOf(this.currentRoom);

          // Create extended array for infinite loop effect (3x the original)
          const extendedRooms = [...rooms, ...rooms, ...rooms];
          const centerIndex = rooms.length + currentIndex; // Middle set + current position

          return extendedRooms.map((room, index) => {
            const relativePosition = index - centerIndex;
            const distance = Math.abs(relativePosition);

            // Only show tabs that are close to center (within 2 positions)
            if (distance > 2) {
              return '';
            }

            // Calculate positioning with smaller gaps
            const isActive = relativePosition === 0;
            const translateX = relativePosition * 80; // Reduced from 120px to 80px
            const opacity = distance === 0 ? 1 : Math.max(0.5, 1 - (distance * 0.25));
            const scale = distance === 0 ? 1.1 : Math.max(0.85, 1 - (distance * 0.08));

            return `
              <button class="room-tab" data-room="${room}" data-position="${relativePosition}"
                      style="position: absolute;
                             left: 50%;
                             top: 50%;
                             transform: translate(-50%, -50%) translateX(${translateX}px) scale(${scale});
                             padding: 10px 14px;
                             border: none;
                             border-radius: 12px;
                             font-size: ${isActive ? '15px' : '13px'};
                             cursor: pointer;
                             background: ${isActive ? '#F2C31B' : 'rgba(225,225,225,0.9)'};
                             color: ${isActive ? '#303030' : '#666'};
                             transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                             opacity: ${opacity};
                             white-space: nowrap;
                             z-index: ${10 - distance};
                             font-weight: ${isActive ? '600' : '400'};
                             box-shadow: ${isActive ? '0 4px 12px rgba(242,195,27,0.3)' : '0 2px 4px rgba(0,0,0,0.1)'};
                             letter-spacing: ${isActive ? '0.5px' : '0px'};">
                ${room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ')}
              </button>
            `;
          }).filter(tab => tab !== '').join('');
        }
        
        getPhotosHTML() {
          console.log('getPhotosHTML - Current room:', this.currentRoom);
          console.log('getPhotosHTML - Current tab:', this.currentTab);
          console.log('getPhotosHTML - All photos:', this.photos);

          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for this room, sorted by timestamp (oldest first)
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp); // Oldest first

          console.log('Before photos (chronological):', beforePhotos);

          // Create grid layout with all photos and dummy squares
          const gridItems = [];
          
          console.log(`Grid calculation: ${beforePhotos.length} photos`);

          // Add all existing photos
          beforePhotos.forEach((beforePhoto, i) => {
            // Check if there's a corresponding after photo linked to this before photo
            const afterPhoto = this.photos.find(p =>
              p.room === this.currentRoom &&
              p.mode === 'after' &&
              p.beforePhotoId === beforePhoto.id
            );

            if (afterPhoto) {
              // Show split-screen before/after
              const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

              gridItems.push(`
                <div class="photo-item" data-photo-index="${this.photos.indexOf(afterPhoto)}" style="border: 1px solid #E1E1E1; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1;">
                  <!-- Split screen container taking full card space -->
                  <div style="height: 100%; display: flex; flex-direction: column; position: relative;">
                    <!-- Before photo (top half) -->
                    <div style="height: 50%; overflow: hidden; position: relative;">
                      <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                      <div style="position: absolute; top: 2px; left: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold;">BEFORE</div>
                    </div>
                    <!-- Divider line -->
                    <div style="height: 2px; background: #000;"></div>
                    <!-- After photo (bottom half) -->
                    <div style="height: 50%; overflow: hidden; position: relative;">
                      <img src="${afterPhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                      <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold;">AFTER</div>
                    </div>
                  </div>

                  <!-- Transparent title overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(0,0,0,0.7));">
                    <div style="color: white; font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${displayName}</div>
                    <div style="color: rgba(255,255,255,0.9); font-size: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                  </div>

                  <!-- Delete button -->
                  <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(afterPhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                    üóëÔ∏è
                  </button>
                </div>
              `);
            } else {
              // Show only before photo
              const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

              gridItems.push(`
                <div class="photo-item" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="border: 1px solid #E1E1E1; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s;">
                  <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 120px; object-fit: cover; cursor: pointer;" />
                  <div style="padding: 8px; font-size: 11px; color: #B3B3B3;">
                    <div style="font-weight: bold; margin-bottom: 2px; color: #303030;">${displayName}</div>
                    <div style="font-size: 10px; opacity: 0.8;">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                  </div>
                  <!-- Delete button -->
                  <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                    üóëÔ∏è
                  </button>
                </div>
              `);
            }
          });
          
          // Add one dummy square for taking more photos
          gridItems.push(`
            <div class="dummy-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; color: #999; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e8e8e8'; this.style.color='#666';" onmouseout="this.style.background='#f0f0f0'; this.style.color='#999';">
              ${roomIcons[this.currentRoom] || 'üì∑'}
            </div>
          `);

          console.log('Grid items count:', gridItems.length);
          return gridItems.join('');
        }
        
        getRoomPhotosByType(type) {
          const roomPhotos = this.photos.filter(photo => photo.room === this.currentRoom);
          console.log('getRoomPhotosByType - Type:', type, 'Current room:', this.currentRoom);
          console.log('getRoomPhotosByType - Room photos:', roomPhotos);
          
          if (type === 'photo') {
            const result = roomPhotos.filter(photo => photo.mode === 'before' || photo.mode === 'after');
            console.log('getRoomPhotosByType - Photo result:', result);
            return result;
          } else if (type === 'combined') {
            const result = roomPhotos.filter(photo => photo.mode === 'mix');
            console.log('getRoomPhotosByType - Combined result:', result);
            return result;
          } else if (type === 'all') {
            const result = roomPhotos.filter(photo => photo.mode === 'archived' || photo.mode === 'mix');
            console.log('getRoomPhotosByType - All result:', result);
            return result;
          }
          return roomPhotos;
        }
        
        getRoomFilteredPhotos() {
          // Always show photos by default, unless specifically viewing combined or all
          return this.getRoomPhotosByType(this.currentTab || 'photo');
        }
        
        addSwipeListeners() {
          // Only add listeners once
          if (this.swipeListenersAdded) return;
          this.swipeListenersAdded = true;
          
          // Ensure room order matches the visual tab order exactly
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          let startX = 0;
          let startY = 0;
          
          // Add touch events for swiping
          document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          });
          
          document.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const diffX = startX - endX;
            const diffY = startY - endY;
            
            // Only trigger swipe if horizontal movement is greater than vertical
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
              const currentIndex = rooms.indexOf(this.currentRoom);
              console.log('Swipe - Current room:', this.currentRoom, 'Index:', currentIndex);
              
              if (diffX > 0) {
                // Swipe left - next room (following tab order)
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
                console.log('Swipe left - Next room:', this.currentRoom, 'Index:', nextIndex);
              } else {
                // Swipe right - previous room (following tab order)
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
                console.log('Swipe right - Previous room:', this.currentRoom, 'Index:', prevIndex);
              }
              
              this.currentTab = 'photo';
              
              // Check if we're in a camera modal - if so, don't call init() to avoid regenerating the entire app
              const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
              
              if (isInCameraModal) {
                // Just update modal elements without regenerating the entire app
                setTimeout(() => {
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }, 100);
              } else {
                // Normal app update
                this.init();
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              }
            }
          });
          
          // Add keyboard support for cycling
          document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
              e.preventDefault();
              const currentIndex = rooms.indexOf(this.currentRoom);
              
              if (e.key === 'ArrowLeft') {
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
              } else {
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
              }
              
              this.currentTab = 'photo';
              
              // Check if we're in a camera modal - if so, don't call init() to avoid regenerating the entire app
              const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
              
              if (isInCameraModal) {
                // Just update modal elements without regenerating the entire app
                setTimeout(() => {
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }, 100);
              } else {
                // Normal app update
                this.init();
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              }
            }
          });
        }
        
        updateTabsCarousel() {
          // Just re-render the tabs - the carousel positioning is handled in getRoomTabsCarousel()
          const tabsCarousel = document.getElementById('tabs-carousel');
          if (tabsCarousel) {
            tabsCarousel.innerHTML = this.getRoomTabsCarousel();
            console.log('Carousel updated for room:', this.currentRoom);
          }
        }

        updateModalRoomTabs() {
          // Update room tabs in the modal
          const modalTabsCarousel = document.getElementById('modal-tabs-carousel');
          if (modalTabsCarousel) {
            modalTabsCarousel.innerHTML = this.getRoomTabsCarousel();
            console.log('Modal carousel updated for room:', this.currentRoom);
          }
        }

        updateModalPhotoGrid() {
          // Update photo grid in the modal
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            beforePhotoGrid.innerHTML = this.getBeforePhotosGridHTML();
            this.attachBeforePhotoListeners();
            
            // Auto-scroll to bottom to show latest photos
            setTimeout(() => {
              beforePhotoGrid.scrollTop = beforePhotoGrid.scrollHeight;
            }, 100);
          }
        }

        showActionButtons() {
          // Show retake and save buttons, hide camera button
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          if (retakeBtn) retakeBtn.style.display = 'flex';
          if (saveBtn) saveBtn.style.display = 'flex';
          if (cameraBtn) cameraBtn.style.display = 'none';
          
          // Check if we're in after mode (comparison camera modal) and make bottom panel transparent
          if (bottomPanel) {
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');
            
            if (cameraModal && cameraModal.innerHTML.includes('comparison-camera')) {
              // After mode - make bottom panel transparent
              bottomPanel.style.background = 'transparent';
              bottomPanel.style.boxShadow = 'none';
            } else {
              // Before mode - use original styling
              bottomPanel.style.background = 'white';
              bottomPanel.style.boxShadow = '0 -2px 8px rgba(0,0,0,0.1)';
            }
          }
        }

        hideActionButtons() {
          // Hide retake and save buttons, keep camera button hidden for gallery
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          if (retakeBtn) retakeBtn.style.display = 'none';
          if (saveBtn) saveBtn.style.display = 'none';
          
          // Reset bottom panel styling to original
          if (bottomPanel) {
            bottomPanel.style.background = 'white';
            bottomPanel.style.boxShadow = '0 -2px 8px rgba(0,0,0,0.1)';
          }
          
          // Check if we're in a camera modal - if so, keep camera button visible
          const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                  document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                  document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
          if (cameraBtn) {
            if (isInCameraModal) {
              cameraBtn.style.display = 'block'; // Keep visible during camera modal
            } else {
              cameraBtn.style.display = 'none'; // Hide for gallery
            }
          }
        }

        showCameraButton() {
          // Show camera button during photo capture screens
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');
          
          if (cameraBtn) cameraBtn.style.display = 'block';
          
          // Check if we're in a camera modal and apply appropriate styling
          if (bottomPanel && cameraBtn) {
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');
            
            if (cameraModal) {
              // Both before and after modes - transparent panel, yellow button with white border
              bottomPanel.style.background = 'transparent';
              bottomPanel.style.boxShadow = 'none';
              
              // Make individual sections transparent as well
              const sections = bottomPanel.querySelectorAll('div');
              sections.forEach(section => {
                section.style.background = 'transparent';
              });
              
              cameraBtn.style.background = '#F2C31B';
              cameraBtn.style.border = '2px solid rgba(255,255,255,0.8)';
              cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
            } else {
              // Not in camera modal - use original styling
              bottomPanel.style.background = 'white';
              bottomPanel.style.boxShadow = '0 -2px 8px rgba(0,0,0,0.1)';
              cameraBtn.style.background = '#F2C31B';
              cameraBtn.style.border = 'none';
              cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
            }
          }
        }

        hideCameraButton() {
          // Hide camera button and reset styling
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');
          
          if (cameraBtn) {
            cameraBtn.style.display = 'none';
            // Reset camera button styling to original
            cameraBtn.style.background = '#F2C31B';
            cameraBtn.style.border = 'none';
            cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
          }
          
          // Reset bottom panel styling to original
          if (bottomPanel) {
            bottomPanel.style.background = 'white';
            bottomPanel.style.boxShadow = '0 -2px 8px rgba(0,0,0,0.1)';
            
            // Reset individual sections to default
            const sections = bottomPanel.querySelectorAll('div');
            sections.forEach(section => {
              section.style.background = '';
            });
          }
        }

        addScrollListener() {
          // Throttle scroll events for performance
          let scrollTimeout;

          window.addEventListener('scroll', () => {
            if (scrollTimeout) {
              clearTimeout(scrollTimeout);
            }

            scrollTimeout = setTimeout(() => {
              this.checkVisibleRoom();
            }, 100); // Check every 100ms during scroll
          });
        }

        checkVisibleRoom() {
          // Room sections removed - scroll-based room switching disabled
          // Users can only switch rooms through tabs
        }
        
        attachPhotoListeners() {
          // Only attach listeners for photo elements (called after photo grid updates)
          console.log('attachPhotoListeners called');
          setTimeout(() => {
            document.querySelectorAll('.photo-item').forEach(item => {
              // Photo click to view fullscreen
              item.addEventListener('click', (e) => {
                // Don't trigger if clicking delete button
                if (e.target.classList.contains('delete-photo-btn')) {
                  return;
                }

                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                if (photoIndex >= 0 && photoIndex < this.photos.length) {
                  this.showPhotoFullscreen(this.photos[photoIndex]);
                }
              });

              // Add hover effect
              item.addEventListener('mouseenter', (e) => {
                e.currentTarget.style.transform = 'scale(1.02)';
              });

              item.addEventListener('mouseleave', (e) => {
                e.currentTarget.style.transform = 'scale(1)';
              });
            });

            // Delete button functionality for photos
            document.querySelectorAll('.delete-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const photoIndex = parseInt(e.target.dataset.photoIndex);
                this.deletePhoto(photoIndex);
              });
            });

            // Dummy photos click handlers
            document.querySelectorAll('.dummy-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                this.openCameraForRoom(room);
              });
            });
            
            // Auto-scroll to bottom to show latest photos (main gallery only)
            setTimeout(() => {
              const mainScrollableContent = document.getElementById('main-scrollable-content');
              if (mainScrollableContent) {
                console.log('Found main scrollable content:', mainScrollableContent);
                console.log('Scroll height:', mainScrollableContent.scrollHeight);
                console.log('Client height:', mainScrollableContent.clientHeight);
                console.log('Current scroll top:', mainScrollableContent.scrollTop);
                
                if (mainScrollableContent.scrollHeight > mainScrollableContent.clientHeight) {
                  console.log('Content is scrollable, scrolling to bottom');
                  mainScrollableContent.scrollTop = mainScrollableContent.scrollHeight;
                  console.log('New scroll top:', mainScrollableContent.scrollTop);
                } else {
                  console.log('Content is not scrollable - no need to scroll');
                }
              } else {
                console.log('Main scrollable content not found');
              }
            }, 200);
          }, 100);
        }

        attachEventListeners() {
          // Room tabs with swipe support - attach with delay to ensure DOM is ready
          setTimeout(() => {
            const roomTabs = document.querySelectorAll('.room-tab');
            console.log('Attaching click listeners to', roomTabs.length, 'room tabs');

            roomTabs.forEach((btn, index) => {
              console.log(`Room tab ${index}:`, btn.dataset.room);

              btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Get room from current target (the button) instead of target (might be inner element)
                const room = e.currentTarget.dataset.room;
                console.log('Room tab clicked:', room);

                if (room && room !== this.currentRoom) {
                  this.currentRoom = room;
                  this.currentTab = 'photo'; // Reset to photo tab when switching rooms

                  // Update only the content area instead of full re-init
                  const photosContainer = document.getElementById('photos-container');
                  if (photosContainer) {
                    photosContainer.innerHTML = this.getPhotosHTML();
                    this.attachPhotoListeners();
                  }

                  // Update carousel and scroll
                  setTimeout(() => {
                    this.updateTabsCarousel();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                  }, 100);
                }
              });

              // Also add pointer events for better touch handling
              btn.style.pointerEvents = 'auto';
              btn.style.cursor = 'pointer';
            });
          }, 100);
          
          // Add swipe functionality to room tabs
          this.addSwipeListeners();

          // Camera button - only visible during photo capture screens
          const cameraBtn = document.getElementById('camera-btn');
          if (cameraBtn) {
            cameraBtn.addEventListener('click', () => {
              // Check if we're in a camera modal (before or after mode)
              const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                                 document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                                 document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');

              if (cameraModal) {
                // We're in a camera modal, capture photo
                if (cameraModal.innerHTML.includes('camera-video')) {
                  // Before mode - regular camera
                  console.log('Capturing from regular camera modal');
                  this.captureFromCameraModal();
                } else if (cameraModal.innerHTML.includes('comparison-camera')) {
                  // After mode - comparison camera
                  console.log('Capturing from comparison camera modal');
                  this.captureFromComparisonModal();
                }
              }
            });
          }
          
          // Header upload button (dummy functionality)
          const headerUploadBtn = document.getElementById('header-upload-btn');
          if (headerUploadBtn) {
            headerUploadBtn.addEventListener('click', () => {
              alert('Upload functionality will be added soon!');
            });
          }
          
          // Location select
          const locationSelect = document.getElementById('location-select');
          if (locationSelect) {
            locationSelect.addEventListener('change', (e) => {
              console.log('Location changed to:', e.target.value);
              // You can add location-specific functionality here
            });
          }
          
          // Retake and Save button handlers
          const retakeBtn = document.getElementById('btn-retake');
          if (retakeBtn) {
            retakeBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Store the room before closing split screen
                const room = this.currentSplitScreen.room;

                // Close current split screen
                this.closeSplitScreenPreview();

                // Clean up any remaining modals (exclude permanent UI elements)
                const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
                existingModals.forEach(modal => {
                  try {
                    if (modal.parentNode &&
                        !modal.id.includes('bottom-panel') &&
                        !modal.id.includes('sticky-tabs-container') &&
                        modal.id !== 'bottom-panel' &&
                        modal.id !== 'sticky-tabs-container') {
                      if (modal.parentNode === document.body) {
                        document.body.removeChild(modal);
                      } else {
                        modal.parentNode.removeChild(modal);
                      }
                    }
                  } catch (error) {
                    console.log('Modal already removed:', error);
                  }
                });

                // Small delay to ensure cleanup completes
                setTimeout(() => {
                  // Find the before photo and reopen comparison camera
                  const beforePhoto = this.photos.find(p =>
                    p.room === room && p.mode === 'before'
                  );

                  if (beforePhoto) {
                    this.showPhotoFullscreen(beforePhoto);
                  }
                }, 100);
              }
            });
          }

          const saveBtn = document.getElementById('btn-save');
          if (saveBtn) {
            saveBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Save the combined photo
                this.captureSplitScreenPhoto(
                  this.currentSplitScreen.beforeDataUrl,
                  this.currentSplitScreen.afterDataUrl,
                  this.currentSplitScreen.room
                );

                // Close split screen and return to gallery
                this.closeSplitScreenPreview();
              }
            });
          }
          
          // Photo event listeners moved to attachPhotoListeners() to prevent duplicates
          this.attachPhotoListeners();
        }
        
        
        updateTabs() {
          document.querySelectorAll('.photo-tab').forEach(tab => {
            const tabType = tab.dataset.tab;
            if (tabType === this.currentTab) {
              tab.style.background = '#F2C31B';
              tab.style.color = '#303030';
            } else {
              tab.style.background = 'transparent';
              tab.style.color = '#B3B3B3';
            }
          });
        }
        
        deletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            const photo = this.photos[photoIndex];
            const photoType = photo.mode === 'mix' ? 'combined before/after' : photo.mode;

            this.showDeleteConfirmation(photoType, photo.room, photoIndex);
          }
        }

        showDeleteConfirmation(photoType, room, photoIndex) {
          // Clean up any existing confirmation modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 3000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 3000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
              <!-- Title -->
              <h3 style="text-align: center; font-size: 20px; font-weight: bold; color: #1f2937; margin-bottom: 24px;">
                Are you sure?
              </h3>
              
              <!-- Buttons -->
              <div style="display: flex; gap: 12px;">
                <button id="cancel-delete-btn" style="flex: 1; padding: 12px 20px; border: 2px solid #d1d5db; background: white; color: #374151; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  Cancel
                </button>
                <button id="confirm-delete-btn" style="flex: 1; padding: 12px 20px; border: none; background: #F2C31B; color: #303030; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  Delete
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Add hover effects
          const cancelBtn = document.getElementById('cancel-delete-btn');
          const confirmBtn = document.getElementById('confirm-delete-btn');

          cancelBtn.addEventListener('mouseenter', () => {
            cancelBtn.style.background = '#f9fafb';
            cancelBtn.style.borderColor = '#9ca3af';
          });
          cancelBtn.addEventListener('mouseleave', () => {
            cancelBtn.style.background = 'white';
            cancelBtn.style.borderColor = '#d1d5db';
          });

          confirmBtn.addEventListener('mouseenter', () => {
            confirmBtn.style.background = '#e6b800';
          });
          confirmBtn.addEventListener('mouseleave', () => {
            confirmBtn.style.background = '#F2C31B';
          });

          // Event listeners
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          confirmBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
            this.confirmDeletePhoto(photoIndex);
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        confirmDeletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            this.photos.splice(photoIndex, 1);
            
            // Reassign names to maintain proper sequential numbering
            this.reassignPhotoNames();

            // Update photo grid without full DOM regeneration
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners(); // Re-attach event listeners for updated photo elements
            }

            // Update before photo grid in modal if it exists
            this.updateModalPhotoGrid();
          }
        }
        
        async showPhotoFullscreen(photo) {
          // Clean up any existing photo fullscreen modals first
          const existingPhotoModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingPhotoModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;
          
          if (photo.mode === 'before') {
            // Store the specific before photo that was clicked for later reference
            this.currentBeforePhoto = photo;
            
            // Split screen: before photo and camera
            modal.innerHTML = this.getComparisonModalHTML(photo);

            document.body.appendChild(modal);

            // Show camera button for photo capture
            this.showCameraButton();
            
            // Initialize camera for comparison
            try {
              let stream;
              try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                  video: { facingMode: 'environment' } // Default to back camera
                });
              } catch (backCameraError) {
                console.log('Back camera not available, trying any camera:', backCameraError);
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
              }
              
              const video = document.getElementById('comparison-camera');
              video.srcObject = stream;
              
              let currentFacingMode = 'environment';
              
              
              // Close button
              document.getElementById('close-comparison-btn').addEventListener('click', () => {
                stream.getTracks().forEach(track => track.stop());
                document.body.removeChild(modal);
                this.hideCameraButton();
                this.currentBeforePhoto = null; // Clear the reference
              });
              
            } catch (error) {
              alert('Camera access denied or failed: ' + error.message);
              document.body.removeChild(modal);
              this.hideCameraButton();
              this.currentBeforePhoto = null; // Clear the reference
            }
            
          } else if (photo.mode === 'after') {
            // For after photos, find the linked before photo and open comparison camera for retaking
            const linkedBeforePhoto = this.photos.find(p => 
              p.id === photo.beforePhotoId && p.mode === 'before'
            );
            
            if (linkedBeforePhoto) {
              // Store the specific before photo that was clicked for later reference
              this.currentBeforePhoto = linkedBeforePhoto;
              
              // Split screen: before photo and camera
              modal.innerHTML = this.getComparisonModalHTML(linkedBeforePhoto);

              document.body.appendChild(modal);

              // Show camera button for photo capture
              this.showCameraButton();
              
              // Initialize camera for comparison
              try {
                let stream;
                try {
                  stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } // Default to back camera
                  });
                } catch (backCameraError) {
                  console.log('Back camera not available, trying any camera:', backCameraError);
                  stream = await navigator.mediaDevices.getUserMedia({ video: true });
                }
                
                const video = document.getElementById('comparison-camera');
                video.srcObject = stream;
                
                let currentFacingMode = 'environment';
                
                
                // Close button
                document.getElementById('close-comparison-btn').addEventListener('click', () => {
                  stream.getTracks().forEach(track => track.stop());
                  document.body.removeChild(modal);
                  this.hideCameraButton();
                  this.currentBeforePhoto = null; // Clear the reference
                });
                
              } catch (error) {
                alert('Camera access denied or failed: ' + error.message);
                document.body.removeChild(modal);
                this.hideCameraButton();
                this.currentBeforePhoto = null; // Clear the reference
              }
            } else {
              // Fallback: Regular fullscreen if no linked before photo found
              modal.innerHTML = `
                <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center;">
                  <img src="${photo.dataUrl}" style="width: 100vw; height: 100vh; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 40px 20px 20px; text-align: center; color: white;">
                    <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                    </div>
                    <div style="font-size: 16px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Close button -->
                  <button id="close-photo-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                    ‚úï
                  </button>
                </div>
              `;
              
              document.body.appendChild(modal);
              
              document.getElementById('close-photo-btn').addEventListener('click', () => {
                document.body.removeChild(modal);
              });
              
              // Close on background click
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  document.body.removeChild(modal);
                }
              });
            }
          } else {
            // Regular fullscreen for other photo types
            modal.innerHTML = `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center;">
                <img src="${photo.dataUrl}" style="width: 100vw; height: 100vh; object-fit: cover;" />
                
                <!-- Photo info overlay -->
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 40px 20px 20px; text-align: center; color: white;">
                  <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                    ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                  </div>
                  <div style="font-size: 16px; opacity: 0.9;">
                    ${new Date(photo.timestamp).toLocaleString()}
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-photo-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('close-photo-btn').addEventListener('click', () => {
              document.body.removeChild(modal);
            });
            
            // Close on background click
            modal.addEventListener('click', (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);
              }
            });
          }
        }
        
        captureComparisonPhoto(video, stream, beforePhoto) {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          ctx.drawImage(video, 0, 0);

          const dataUrl = canvas.toDataURL('image/jpeg', 0.8);

          // Automatically save the "after" photo
          this.saveAfterPhotoToAll(dataUrl, beforePhoto);

          // Stop camera stream
          stream.getTracks().forEach(track => track.stop());

          // Close modal overlays only (exclude permanent UI elements)
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
          existingModals.forEach(modal => {
            try {
              if (modal.parentNode &&
                  !modal.id.includes('bottom-panel') &&
                  !modal.id.includes('sticky-tabs-container') &&
                  modal.id !== 'bottom-panel' &&
                  modal.id !== 'sticky-tabs-container') {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else if (modal.parentNode) {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Small delay to ensure cleanup completes before updating gallery
          setTimeout(() => {
            // Update gallery to show new after photo
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners(); // Re-attach event listeners for new photo elements
            }

            // Hide action buttons and return to gallery view
            this.hideActionButtons();
            
            // Clear the before photo reference
            this.currentBeforePhoto = null;
            
            // Auto-cycle to next unpaired before photo
            this.autoCycleToNextBeforePhoto(beforePhoto.room);
          }, 100);
        }
        
        autoCycleToNextBeforePhoto(room) {
          // Find all before photos in this room that don't have corresponding after photos
          const beforePhotos = this.photos.filter(p => p.room === room && p.mode === 'before');
          const afterPhotos = this.photos.filter(p => p.room === room && p.mode === 'after');
          
          // Find before photos that don't have a corresponding after photo
          const unpairedBeforePhotos = beforePhotos.filter(beforePhoto => {
            return !afterPhotos.some(afterPhoto => afterPhoto.beforePhotoId === beforePhoto.id);
          });
          
          if (unpairedBeforePhotos.length > 0) {
            // Sort by timestamp to get the next one chronologically
            unpairedBeforePhotos.sort((a, b) => a.timestamp - b.timestamp);
            const nextBeforePhoto = unpairedBeforePhotos[0];
            
            console.log('Auto-cycling to next before photo:', nextBeforePhoto);
            
            // Open comparison modal with the next before photo
            this.openComparisonModal(nextBeforePhoto);
          } else {
            console.log('All before photos in room', room, 'have been paired with after photos');
            // Could show a message or return to gallery
          }
        }
        
        openComparisonModal(beforePhoto) {
          // Create modal container
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: black; z-index: 2000; display: flex; align-items: center; justify-content: center;
          `;
          
          // Store the specific before photo that was clicked for later reference
          this.currentBeforePhoto = beforePhoto;
          
          // Split screen: before photo and camera
          modal.innerHTML = this.getComparisonModalHTML(beforePhoto);
          
          document.body.appendChild(modal);
          
          // Show camera button for photo capture
          this.showCameraButton();
          
          // Initialize camera for comparison
          this.initializeComparisonCamera(modal);
        }
        
        async initializeComparisonCamera(modal) {
          try {
            let stream;
            try {
              // Try to get back camera first
              stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' } 
              });
            } catch (backCameraError) {
              console.log('Back camera not available, trying any camera:', backCameraError);
              stream = await navigator.mediaDevices.getUserMedia({ video: true });
            }
            
            const video = document.getElementById('comparison-camera');
            video.srcObject = stream;
            
            let currentFacingMode = 'environment';
            
            // Close button
            document.getElementById('close-comparison-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(modal);
              this.hideCameraButton();
              this.currentBeforePhoto = null; // Clear the reference
            });
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
            document.body.removeChild(modal);
            this.hideCameraButton();
            this.currentBeforePhoto = null; // Clear the reference
          }
        }
        
        generatePhotoName(room, mode) {
          // Get all photos for this room and mode, sorted by timestamp (oldest first)
          const roomPhotos = this.photos
            .filter(p => p.room === room && p.mode === mode)
            .sort((a, b) => a.timestamp - b.timestamp);
          
          // The position should be based on the chronological order in the grid
          // Since photos are sorted by timestamp, the position is the index + 1
          const position = roomPhotos.length + 1;
          
          // Create simple name: "kitchen 1", "kitchen 2", etc.
          const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
          return `${roomName} ${position}`;
        }

        // Function to reassign names to all photos based on their current grid position
        reassignPhotoNames() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          
          rooms.forEach(room => {
            // Get all before photos for this room, sorted by timestamp (oldest first)
            const beforePhotos = this.photos
              .filter(p => p.room === room && p.mode === 'before')
              .sort((a, b) => a.timestamp - b.timestamp);
            
            // Reassign names based on chronological position
            beforePhotos.forEach((photo, index) => {
              const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
              const newName = `${roomName} ${index + 1}`;
              photo.name = newName;
              
              // Also update any linked after photos
              const afterPhoto = this.photos.find(p => 
                p.mode === 'after' && p.beforePhotoId === photo.id
              );
              if (afterPhoto) {
                afterPhoto.name = newName;
              }
            });
          });
          
          this.savePhotos();
        }

        saveAfterPhotoToAll(afterPhotoDataUrl, beforePhoto) {
          // Check if there's already an after photo linked to this before photo
          const existingAfterPhotoIndex = this.photos.findIndex(p => 
            p.mode === 'after' && p.beforePhotoId === beforePhoto.id
          );

          // Use the same name as the before photo
          const afterPhotoName = beforePhoto.name;

          const afterPhoto = {
            id: Date.now(),
            dataUrl: afterPhotoDataUrl,
            room: beforePhoto.room,
            mode: 'after', // Save as after photo for split-screen display
            name: afterPhotoName,
            timestamp: Date.now(),
            beforePhotoId: beforePhoto.id // Link to specific before photo
          };

          if (existingAfterPhotoIndex !== -1) {
            // Replace existing after photo
            this.photos[existingAfterPhotoIndex] = afterPhoto;
            console.log('Replaced existing after photo for before photo:', beforePhoto.id);
          } else {
            // Add new after photo
            this.photos.push(afterPhoto);
            console.log('Added new after photo for before photo:', beforePhoto.id);
          }

          this.savePhotos();
        }
        
        
        
        
        showSplitScreenPreview(beforeDataUrl, afterDataUrl, room) {
          // Clean up any existing split screen modals first
          const existingSplitScreens = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingSplitScreens.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Create a new modal for split screen preview
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;

          modal.innerHTML = this.getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room);
          document.body.appendChild(modal);

          // Show action buttons in bottom panel
          this.showActionButtons();

          // Store current split screen data for button handlers
          this.currentSplitScreen = {
            beforeDataUrl,
            afterDataUrl,
            room,
            modal
          };

          // Close button event listener
          document.getElementById('close-split-btn').addEventListener('click', () => {
            this.closeSplitScreenPreview();
          });
        }

        closeSplitScreenPreview() {
          if (this.currentSplitScreen && this.currentSplitScreen.modal) {
            try {
              if (this.currentSplitScreen.modal.parentNode) {
                if (this.currentSplitScreen.modal.parentNode === document.body) {
                  document.body.removeChild(this.currentSplitScreen.modal);
                } else {
                  this.currentSplitScreen.modal.parentNode.removeChild(this.currentSplitScreen.modal);
                }
              }
            } catch (error) {
              console.log('Split screen modal already removed:', error);
            }
          }

          // Clean up any remaining split screen modals that might be orphaned
          const splitScreenModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          splitScreenModals.forEach(modal => {
            try {
              if (modal.parentNode) {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Hide action buttons and show camera button
          this.hideActionButtons();

          // Clear current split screen data
          this.currentSplitScreen = null;
        }
        
        captureSplitScreenPhoto(beforeDataUrl, afterDataUrl, room) {
          // Create a temporary fullscreen container for the split-screen photo
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: white; z-index: 9999;
          `;
          
          tempContainer.innerHTML = `
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column;">
              <!-- Before photo (top half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  BEFORE
                </div>
              </div>
              
              <!-- Divider line -->
              <div style="width: 100%; height: 4px; background: #000;"></div>
              
              <!-- After photo (bottom half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  AFTER
                </div>
              </div>
            </div>
          `;
          
          document.body.appendChild(tempContainer);
          
          // Use html2canvas to capture the entire screen
          setTimeout(() => {
            this.captureScreenAsImage(tempContainer, room);
          }, 500); // Give time for images to load
        }
        
        captureScreenAsImage(container, room) {
          // Create a canvas to capture the screen
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match the container
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          
          // Fill white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Get all images from the container
          const images = container.querySelectorAll('img');
          let imagesLoaded = 0;
          const totalImages = images.length;
          
          if (totalImages === 0) {
            // No images, just save the container
            this.saveCombinedPhoto(canvas.toDataURL('image/jpeg', 0.9), room);
            document.body.removeChild(container);
            return;
          }
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // All images loaded, now draw them
              const halfHeight = canvas.height / 2;
              
              // Draw before photo (top half)
              const beforeImg = images[0];
              ctx.drawImage(beforeImg, 0, 0, canvas.width, halfHeight);
              
              // Draw divider line
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(0, halfHeight);
              ctx.lineTo(canvas.width, halfHeight);
              ctx.stroke();
              
              // Draw after photo (bottom half)
              const afterImg = images[1];
              ctx.drawImage(afterImg, 0, halfHeight, canvas.width, halfHeight);
              
              // Add labels
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.font = 'bold 18px Arial';
              ctx.textAlign = 'center';
              
              // Before label
              ctx.fillRect(canvas.width/2 - 50, 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('BEFORE', canvas.width/2, 40);
              
              // After label
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.fillRect(canvas.width/2 - 50, halfHeight + 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('AFTER', canvas.width/2, halfHeight + 40);
              
              // Convert to data URL and save
              const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
              this.saveCombinedPhoto(combinedDataUrl, room);
              
              // Clean up
              document.body.removeChild(container);
            }
          };
          
          // Set up image load handlers
          images.forEach(img => {
            if (img.complete) {
              onImageLoad();
            } else {
              img.onload = onImageLoad;
            }
          });
        }
        
        saveCombinedPhoto(combinedDataUrl, room) {
          // Find the before photo for this room (after photos are already in "All" tab)
          const roomPhotos = this.photos.filter(photo => photo.room === room);
          const beforePhoto = roomPhotos.find(photo => photo.mode === 'before');
          
          // Create meaningful name for the combined photo
          const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
          const combinedPhotoName = `${roomName}_Combined_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
          
          // Create the combined photo
          const combinedPhoto = {
            id: Date.now(),
            dataUrl: combinedDataUrl,
            room: room,
            mode: 'mix',
            name: combinedPhotoName,
            timestamp: Date.now()
          };
          
          // Add the combined photo
          this.photos.push(combinedPhoto);
          
          // Move before photo to "archived" mode (All tab)
          if (beforePhoto) {
            beforePhoto.mode = 'archived';
          }
          
          this.savePhotos();

          // Photo saved successfully - modal closing handled by caller
        }
        
        async openCameraForRoom(room) {
          // Set the current room
          this.currentRoom = room;
          
          // Open camera
          await this.openCamera();
        }
        
        async openCamera() {
          console.log('Opening camera...');

          // Prevent multiple camera modals from opening simultaneously
          if (this.isOpeningCamera) {
            console.log('Camera already opening, ignoring request');
            return;
          }
          this.isOpeningCamera = true;

          try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
              alert('Camera not supported on this device');
              this.isOpeningCamera = false;
              return;
            }

            // Clean up any existing camera modals first
            const existingCameraModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 1000"]');
            existingCameraModals.forEach(existing => {
              if (existing.parentNode) {
                document.body.removeChild(existing);
              }
            });

            // Try to use back camera first, fallback to any camera
            let stream;
            try {
              stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' } // Back camera
              });
            } catch (backCameraError) {
              console.log('Back camera not available, trying any camera:', backCameraError);
              stream = await navigator.mediaDevices.getUserMedia({ video: true });
            }

            // Create fullscreen camera modal
            const modal = document.createElement('div');
            modal.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100vw; height: calc(100vh - 80px); 
              background: black; z-index: 1000; display: flex; 
              flex-direction: column; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = this.getBeforePhotoModalHTML();
            
            document.body.appendChild(modal);
            console.log('Before photo modal created and added to DOM');

            // Show camera button for photo capture
            this.showCameraButton();
            
            const video = document.getElementById('camera-video');
            console.log('Video element found:', video);
            if (video) {
              video.srcObject = stream;
              console.log('Stream assigned to video');
            } else {
              console.error('Video element not found!');
            }
            
            // Store current facing mode
            let currentFacingMode = 'environment'; // Start with back camera
            
            // Capture will be handled by the bottom panel camera button
            
            document.getElementById('close-before-modal-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              if (modal && modal.parentNode) {
                document.body.removeChild(modal);
              }
              this.isOpeningCamera = false; // Reset flag
              this.hideCameraButton(); // Hide camera button when closing modal
            });

            // Attach listeners to before photo items
            this.attachBeforePhotoListeners();
            
            // Auto-scroll to bottom to show latest photos
            setTimeout(() => {
              const beforePhotoGrid = document.getElementById('before-photo-grid');
              if (beforePhotoGrid) {
                beforePhotoGrid.scrollTop = beforePhotoGrid.scrollHeight;
              }
            }, 200);
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
            this.isOpeningCamera = false; // Reset flag on error
            this.hideCameraButton();
          }
        }
        
        captureFromCameraModal() {
          // Get the camera video element
          const video = document.getElementById('camera-video');
          if (!video || !video.srcObject) {
            console.error('Camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Capture the before photo
          this.capturePhoto(video, stream);
        }
        
        captureFromComparisonModal() {
          // Get the comparison camera video element
          const video = document.getElementById('comparison-camera');
          if (!video || !video.srcObject) {
            console.error('Comparison camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Use the specific before photo that was clicked to open the comparison modal
          const beforePhoto = this.currentBeforePhoto;

          if (!beforePhoto) {
            console.error('No before photo reference found - this should not happen');
            return;
          }
          
          // Capture the after photo
          this.captureComparisonPhoto(video, stream, beforePhoto);
        }
        
        capturePhoto(video, stream) {
          console.log('Capturing photo...');
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          context.drawImage(video, 0, 0);
          
          // First photos are always "before" photos
          const photoMode = 'before';
          
          // Create simple position-based name
          const photoName = this.generatePhotoName(this.currentRoom, photoMode);
          
          const photo = {
            id: Date.now(),
            dataUrl: canvas.toDataURL('image/jpeg', 0.8),
            room: this.currentRoom,
            mode: photoMode,
            name: photoName,
            timestamp: Date.now()
          };
          
          console.log('Photo created:', photo);
          this.photos.push(photo);
          console.log('Photos array length:', this.photos.length);
          this.savePhotos();
          
          // Update the before photo grid in the modal
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            beforePhotoGrid.innerHTML = this.getBeforePhotosGridHTML();
            this.attachBeforePhotoListeners();
          }

          // Update main gallery as well
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }

          console.log('Photo capture completed');
        }

        attachBeforePhotoListeners() {
          // Add click listeners to before photo items in the modal
          setTimeout(() => {
            // Delete button listeners
            document.querySelectorAll('.delete-before-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering the photo click
                const photoId = parseInt(e.currentTarget.dataset.photoId);
                const photoIndex = this.photos.findIndex(p => p.id === photoId);
                if (photoIndex !== -1) {
                  this.showDeleteConfirmation('before', this.currentRoom, photoIndex);
                }
              });
            });

            // Photo item click listeners (for enlarging photo)
            document.querySelectorAll('.before-photo-item').forEach(item => {
              item.addEventListener('click', (e) => {
                // Only trigger if clicking on the photo itself, not on buttons
                if (e.target === item || e.target.tagName === 'IMG') {
                  const photoId = parseInt(e.currentTarget.dataset.photoId);
                  const photo = this.photos.find(p => p.id === photoId);
                  if (photo) {
                    // Show enlarged photo
                    this.showPhotoEnlarged(photo);
                  }
                }
              });
            });

            // Room tab listeners in modal
            document.querySelectorAll('#modal-tabs-carousel .room-tab').forEach(btn => {
              btn.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                if (room && room !== this.currentRoom) {
                  this.currentRoom = room;
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }
              });
            });

            // Dummy square listeners in modal (for taking new before photos)
            document.querySelectorAll('.dummy-before-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                // Dummy squares don't do anything special - camera button is already available
                // They just provide visual feedback that more photos can be taken
                console.log('Dummy square clicked - camera button should be used for taking photos');
              });
            });
          }, 100);
        }

        showPhotoEnlarged(photo) {
          // Clean up any existing enlarged photo modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 4000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.3); backdrop-filter: blur(10px); z-index: 4000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
            opacity: 0; transition: opacity 0.3s ease-in-out;
          `;

          modal.innerHTML = `
            <div style="position: relative; max-width: 90vw; max-height: 90vh; transform: scale(0.8); transition: transform 0.3s ease-in-out;">
              <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 12px; box-shadow: 0 20px 40px rgba(0,0,0,0.5);" />
              
              <!-- Photo info overlay -->
              <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white; border-radius: 0 0 12px 12px;">
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                  ${photo.name}
                </div>
                <div style="font-size: 14px; opacity: 0.9;">
                  ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                </div>
                <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">
                  ${new Date(photo.timestamp).toLocaleString()}
                </div>
              </div>
              
              <!-- Close button -->
              <button id="close-enlarged-photo-btn" style="position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); color: white; border: none; padding: 10px; border-radius: 50%; font-size: 18px; cursor: pointer; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">
                ‚úï
              </button>
            </div>
          `;

          document.body.appendChild(modal);

          // Trigger animation
          setTimeout(() => {
            modal.style.opacity = '1';
            const imgContainer = modal.querySelector('div');
            imgContainer.style.transform = 'scale(1)';
          }, 10);

          // Close button event listener
          document.getElementById('close-enlarged-photo-btn').addEventListener('click', () => {
            modal.style.opacity = '0';
            const imgContainer = modal.querySelector('div');
            imgContainer.style.transform = 'scale(0.8)';
            setTimeout(() => {
              if (modal.parentNode) {
                document.body.removeChild(modal);
              }
            }, 300);
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.style.opacity = '0';
              const imgContainer = modal.querySelector('div');
              imgContainer.style.transform = 'scale(0.8)';
              setTimeout(() => {
                if (modal.parentNode) {
                  document.body.removeChild(modal);
                }
              }, 300);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              modal.style.opacity = '0';
              const imgContainer = modal.querySelector('div');
              imgContainer.style.transform = 'scale(0.8)';
              setTimeout(() => {
                if (modal.parentNode) {
                  document.body.removeChild(modal);
                }
                document.removeEventListener('keydown', handleEscape);
              }, 300);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        savePhotos() {
          localStorage.setItem('cleaning-photos', JSON.stringify(this.photos));
        }
        
        loadPhotos() {
          const saved = localStorage.getItem('cleaning-photos');
          if (saved) {
            this.photos = JSON.parse(saved);
          }
        }
      }
      
      // Initialize app
      new CleaningPhotoApp();
      console.log('‚úÖ Debug: iOS Safari compatible app loaded successfully');
    </script>
    
    <!-- Fallback for browsers that don't support ES6 modules -->
    <script nomodule>
      console.log('‚ùå Debug: ES6 modules not supported, using fallback');
      document.getElementById('debug-info').innerHTML += '<div style="color: orange;">‚ö†Ô∏è ES6 modules not supported</div>';
      
      // Show a simple message instead of React app
      setTimeout(() => {
        document.getElementById('root').innerHTML = `
          <div style="padding: 20px; text-align: center; font-family: Arial, sans-serif;">
            <h1>üö´ Browser Compatibility Issue</h1>
            <p>Your browser doesn't support ES6 modules, which are required for this app.</p>
            <p>Please update your browser or try a different browser.</p>
            <p style="color: #666; font-size: 14px;">iOS Safari 10.3+ is required for ES6 module support.</p>
          </div>
        `;
      }, 2000);
    </script>
    
    <script>
      // This will run after main.jsx loads (if it loads)
      console.log('‚úÖ Debug: main.jsx script tag processed');
    </script>
  </body>
</html>