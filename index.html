<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#F2C31B" />
    <meta name="description" content="Mobile-first cleaning photo documentation app" />

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

    <!-- Prevent zoom on input fields -->
    <meta name="format-detection" content="telephone=no" />

    <!-- Status bar styling for iOS -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Cleaning App" />
    
    <!-- Additional iOS compatibility -->
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="apple-mobile-web-app-orientations" content="portrait" />

    <title>Cleaning Photo App</title>

    <!-- Google Fonts - Garamond -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

    <style>
      /* Prevent flash of unstyled content */
      body {
        margin: 0;
        padding: 0;
        font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif;
        background-color: #f8fafc;
        color: #1e293b;
        overscroll-behavior-y: auto;
        overscroll-behavior-x: none;
        overflow-x: hidden;
        width: 100vw;
        max-width: 100vw;
        height: 100vh;
      }
      
      * {
        box-sizing: border-box;
      }
      
      /* Hide scrollbars for swipeable elements */
      #room-tabs-container::-webkit-scrollbar {
        display: none;
      }
      
      #room-tabs-container {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      /* Loading spinner */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8fafc;
        z-index: 9999;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #e2e8f0;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Hide loading once React loads */
      #root:not(:empty) + .loading-container {
        display: none;
      }

      /* Debug info */
      .debug-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 10000;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <div class="loading-container">
      <div class="loading-spinner"></div>
    </div>
    
    <!-- Debug info (hidden by default) -->
    <div class="debug-info" id="debug-info" style="display: none;">
      <div>üöÄ HTML Loaded</div>
      <div>üì± User Agent: <span id="user-agent">Loading...</span></div>
      <div>üåê Location: <span id="location">Loading...</span></div>
      <div>‚è∞ Time: <span id="time">Loading...</span></div>
    </div>
    
    <script>
      // Basic debug info
      console.log('üöÄ Debug: HTML loaded');
      console.log('üöÄ Debug: User Agent:', navigator.userAgent);
      console.log('üöÄ Debug: Location:', window.location.href);
      
      // Update debug info
      document.getElementById('user-agent').textContent = navigator.userAgent.substring(0, 50) + '...';
      document.getElementById('location').textContent = window.location.href;
      document.getElementById('time').textContent = new Date().toLocaleTimeString();
      
      // Check if we're on iOS
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      console.log('üöÄ Debug: Is iOS:', isIOS);
      
      if (isIOS) {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">üçé iOS Detected</div>';
      }
      
      // Check if React loads
      let reactLoadTimer = setTimeout(() => {
        console.log('‚ùå Debug: React failed to load within 10 seconds');
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå React Failed to Load</div>';
      }, 10000);
      
      // Clear timer when React loads
      window.addEventListener('load', () => {
        clearTimeout(reactLoadTimer);
        console.log('‚úÖ Debug: Page fully loaded');
      });
      
      // Check for React errors
      window.addEventListener('error', (e) => {
        console.log('‚ùå Debug: JavaScript error:', e.error);
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå JS Error: ' + e.error.message + '</div>';
      });
      
      // Check for unhandled promise rejections
      window.addEventListener('unhandledrejection', (e) => {
        console.log('‚ùå Debug: Unhandled promise rejection:', e.reason);
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå Promise Error: ' + e.reason + '</div>';
      });
      
      // Monitor script loading
      const scripts = document.querySelectorAll('script[type="module"]');
      scripts.forEach((script, index) => {
        script.addEventListener('load', () => {
          console.log('‚úÖ Debug: Script ' + index + ' loaded successfully');
          document.getElementById('debug-info').innerHTML += '<div style="color: green;">‚úÖ Script ' + index + ' loaded</div>';
        });
        script.addEventListener('error', (e) => {
          console.log('‚ùå Debug: Script ' + index + ' failed to load:', e);
          document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå Script ' + index + ' failed: ' + e.message + '</div>';
        });
      });
      
      // Check if main.jsx loads
      console.log('üöÄ Debug: About to load main.jsx');
    </script>
    
    <!-- Simple JavaScript test -->
    <script>
      console.log('üß™ Debug: Testing basic JavaScript...');
      
      // Test if we can create DOM elements
      try {
        const testDiv = document.createElement('div');
        testDiv.innerHTML = '<div style="color: green;">‚úÖ Basic JavaScript Works!</div>';
        document.getElementById('debug-info').appendChild(testDiv);
        console.log('‚úÖ Debug: Basic JavaScript works');
      } catch (e) {
        console.log('‚ùå Debug: Basic JavaScript failed:', e);
      }
      
      // Test if we can fetch (for checking if the app files exist)
      fetch('/src/main.jsx')
        .then(response => {
          console.log('‚úÖ Debug: main.jsx file exists, status:', response.status);
          if (response.status === 200) {
            document.getElementById('debug-info').innerHTML += '<div style="color: green;">‚úÖ main.jsx file exists</div>';
          } else {
            document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå main.jsx file not found (status: ' + response.status + ')</div>';
          }
        })
        .catch(error => {
          console.log('‚ùå Debug: Cannot fetch main.jsx:', error);
          document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå Cannot fetch main.jsx: ' + error.message + '</div>';
        });
    </script>
    
    <!-- Try a very simple inline test first -->
    <script>
      console.log('üß™ Debug: Inline script starting...');
      try {
        const root = document.getElementById('root');
        if (root) {
          root.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Inline Script Works!</h1><p>JavaScript is executing on iPhone!</p></div>';
          console.log('‚úÖ Debug: Inline script successful');
        } else {
          console.log('‚ùå Debug: Root element not found in inline script');
        }
      } catch (e) {
        console.log('‚ùå Debug: Inline script error:', e);
      }
    </script>
    
    <!-- Try regular script (not module) -->
    <script>
      console.log('üß™ Debug: Testing regular script execution...');
      
      try {
        const rootElement = document.getElementById('root');
        if (rootElement) {
          rootElement.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Regular Script Works!</h1><p>This proves regular JavaScript works on iOS Safari.</p><p>Now loading bundled React app...</p></div>';
          console.log('‚úÖ Debug: Regular script execution successful');
        }
      } catch (error) {
        console.log('‚ùå Debug: Regular script failed:', error);
      }
    </script>
    
    <!-- iOS Safari Compatible Cleaning Photo App -->
    <script>
      console.log('üöÄ Debug: Loading iOS Safari compatible version...');
      
      // Simple photo documentation app
      class CleaningPhotoApp {
        constructor() {
          this.photos = [];
          this.currentRoom = 'kitchen';
          this.currentTab = 'photo';
          this.isLandscape = false;
          this.loadPhotos(); // Load photos first
          this.init();
        }
        
        init() {
          // Check orientation
          this.checkOrientation();
          
          const rootElement = document.getElementById('root');
          if (rootElement) {
            rootElement.innerHTML = this.getAppHTML();
            this.attachEventListeners();
            this.updateTabsCarousel(); // Update carousel layout
          }
          
          // Listen for orientation changes
          window.addEventListener('orientationchange', () => {
            setTimeout(() => {
              this.checkOrientation();
              this.init();
            }, 100);
          });
          
          window.addEventListener('resize', () => {
            this.checkOrientation();
            this.init();
          });

          // Add scroll listener for auto tab switching
          this.addScrollListener();
        }
        
        checkOrientation() {
          this.isLandscape = window.innerWidth > window.innerHeight;
        }
        
        getCameraModalHTML() {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <!-- Landscape camera - left/right split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Active camera -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Reference or inactive -->
                <div style="position: relative; width: 50%; height: 100%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls on the left</div>
                  </div>
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top/bottom split
            return `
              <!-- Portrait camera - top/bottom split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Active camera -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Reference or inactive -->
                <div style="position: relative; width: 100%; height: 50%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls above</div>
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getComparisonModalHTML(photo) {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Camera -->
                <div id="camera-container" style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Camera -->
                <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                </div>
                
                <!-- Close button -->
                <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room) {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row; background: white;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - After photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; background: white;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - After photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getAppHTML() {
          return `
            <div style="min-height: 100vh; background: #f8fafc; font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif; display: flex; flex-direction: column; overflow-x: hidden;">
              <!-- Header -->
              <div style="background: #F2C31B; color: #303030; padding: 4px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; max-width: 100vw; position: relative; z-index: 200;">
                <!-- Location dropdown -->
                <select id="location-select" style="background: white; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 14px; font-weight: bold; max-width: 120px;">
                  <option value="tampa">Tampa</option>
                  <option value="st-petersburg">St. Petersburg</option>
                  <option value="jacksonville">Jacksonville</option>
                  <option value="miami">Miami</option>
                </select>
                
                <!-- Cleaner name -->
                <div style="font-size: 16px; font-weight: bold;">Kate</div>
                
                <!-- Upload button -->
                <button id="header-upload-btn" style="background: #303030; color: #F2C31B; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold;">
                  üì§ Upload
                </button>
              </div>
              
              <!-- Fixed Room Tabs -->
              <div id="sticky-tabs-container" style="position: fixed; top: 0; left: 0; right: 0; z-index: 100; background: #f8fafc; padding: 10px; width: 100vw; box-sizing: border-box; display: flex; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <div id="room-tabs-container" style="position: relative; width: 100vw; height: 60px; overflow: hidden;">
                  <div id="tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                    ${this.getRoomTabsCarousel()}
                  </div>
                </div>
              </div>
              
              <!-- Scrollable Content -->
              <div style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 80px 10px 100px 10px; width: 100%; max-width: 100vw; box-sizing: border-box;">
                
                <!-- Photos grid with swipe -->
                <div id="photos-container" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; padding: 0 10px; max-width: 100%; box-sizing: border-box;">
                  ${this.getPhotosHTML()}
                </div>
                
                <!-- Room sections for scrolling -->
                ${this.getRoomScrollSections()}
                
              </div>
              
              <!-- Fixed Camera Button with Action Buttons -->
              <div id="bottom-panel" style="position: fixed; bottom: 0; left: 0; right: 0; z-index: 2001; display: grid; grid-template-columns: 1fr 1fr 1fr; height: 80px; align-items: center; background: transparent;">
                <!-- Left Section - Retake Button (hidden by default) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-retake" style="background: #ef4444; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üîÑ Retake
                  </button>
                </div>

                <!-- Center Section - Camera Button -->
                <div style="display: flex; justify-content: center;">
                  <button id="camera-btn" style="background: #F2C31B; border: none; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; box-shadow: 0 4px 12px rgba(48,48,48,0.3);"></button>
                </div>

                <!-- Right Section - Save Button (hidden by default) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-save" style="background: #10b981; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üíæ Save
                  </button>
                </div>
              </div>
            </div>
          `;
        }
        
        getRoomScrollSections() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };
          
          return rooms.map(room => {
            const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
            const roomPhotos = this.getRoomPhotosByType('photo');
            const isActive = this.currentRoom === room;
            
            return `
              <div class="room-section" data-room="${room}" style="margin-top: 30px; padding: 20px; border-radius: 12px; background: ${isActive ? '#F2C31B' : 'white'}; border: 2px solid ${isActive ? '#F2C31B' : '#E1E1E1'}; cursor: pointer; transition: all 0.3s;">
                <!-- Room header -->
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                  <div style="font-size: 32px; margin-right: 15px;">${roomIcons[room]}</div>
                  <div>
                    <h3 style="color: ${isActive ? '#303030' : '#303030'}; margin: 0; font-size: 20px;">${roomName}</h3>
                    <p style="color: ${isActive ? '#303030' : '#B3B3B3'}; margin: 5px 0 0 0; font-size: 14px;">${roomPhotos.length} photos</p>
                  </div>
                </div>
                
                <!-- Room photos preview -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                  ${this.getRoomPreviewPhotos(room)}
                </div>
              </div>
            `;
          }).join('');
        }
        
        getRoomPreviewPhotos(room) {
          const roomPhotos = this.photos.filter(photo => photo.room === room && (photo.mode === 'before' || photo.mode === 'after'));
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };
          
          // Show up to 6 photos, fill with dummy squares if needed
          const maxPhotos = 6;
          const photosToShow = roomPhotos.slice(0, maxPhotos);
          const dummyCount = Math.max(0, maxPhotos - photosToShow.length);
          
          const photoElements = photosToShow.map(photo => `
            <div style="aspect-ratio: 1; border-radius: 8px; overflow: hidden; position: relative;">
              <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
              <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.7)); padding: 4px; color: white; font-size: 10px;">
                ${photo.mode.toUpperCase()}
              </div>
            </div>
          `);
          
          const dummyElements = [];
          for (let i = 0; i < dummyCount; i++) {
            dummyElements.push(`
              <div class="dummy-photo" data-room="${room}" style="aspect-ratio: 1; border-radius: 8px; background: #E1E1E1; border: 2px dashed #B3B3B3; display: flex; align-items: center; justify-content: center; color: #B3B3B3; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#F2C31B'; this.style.color='#303030';" onmouseout="this.style.background='#E1E1E1'; this.style.color='#B3B3B3';">
                ${roomIcons[room]}
              </div>
            `);
          }
          
          return [...photoElements, ...dummyElements].join('');
        }
        
        getRoomTabsCarousel() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          const currentIndex = rooms.indexOf(this.currentRoom);

          // Create extended array for infinite loop effect (3x the original)
          const extendedRooms = [...rooms, ...rooms, ...rooms];
          const centerIndex = rooms.length + currentIndex; // Middle set + current position

          return extendedRooms.map((room, index) => {
            const relativePosition = index - centerIndex;
            const distance = Math.abs(relativePosition);

            // Only show tabs that are close to center (within 2 positions)
            if (distance > 2) {
              return '';
            }

            // Calculate positioning with smaller gaps
            const isActive = relativePosition === 0;
            const translateX = relativePosition * 80; // Reduced from 120px to 80px
            const opacity = distance === 0 ? 1 : Math.max(0.5, 1 - (distance * 0.25));
            const scale = distance === 0 ? 1.1 : Math.max(0.85, 1 - (distance * 0.08));

            return `
              <button class="room-tab" data-room="${room}" data-position="${relativePosition}"
                      style="position: absolute;
                             left: 50%;
                             top: 50%;
                             transform: translate(-50%, -50%) translateX(${translateX}px) scale(${scale});
                             padding: 10px 14px;
                             border: none;
                             border-radius: 12px;
                             font-size: ${isActive ? '15px' : '13px'};
                             cursor: pointer;
                             background: ${isActive ? '#F2C31B' : 'rgba(225,225,225,0.9)'};
                             color: ${isActive ? '#303030' : '#666'};
                             transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                             opacity: ${opacity};
                             white-space: nowrap;
                             z-index: ${10 - distance};
                             font-weight: ${isActive ? '600' : '400'};
                             box-shadow: ${isActive ? '0 4px 12px rgba(242,195,27,0.3)' : '0 2px 4px rgba(0,0,0,0.1)'};
                             letter-spacing: ${isActive ? '0.5px' : '0px'};">
                ${room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ')}
              </button>
            `;
          }).filter(tab => tab !== '').join('');
        }
        
        getPhotosHTML() {
          console.log('getPhotosHTML - Current room:', this.currentRoom);
          console.log('getPhotosHTML - Current tab:', this.currentTab);
          console.log('getPhotosHTML - All photos:', this.photos);

          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for this room, sorted by timestamp (oldest first)
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp); // Oldest first

          console.log('Before photos (chronological):', beforePhotos);

          // Create dynamic grid layout
          const gridItems = [];

          // Start with minimum 6 slots (3 rows x 2 columns)
          let totalSlots;

          if (beforePhotos.length === 0) {
            // No photos yet - show 6 empty squares with last one as camera
            totalSlots = 6;
          } else if (beforePhotos.length < 5) {
            // Still filling initial 6 squares - keep 6 total with last one as camera
            totalSlots = 6;
          } else {
            // 5 or more photos - expand grid dynamically
            // Always keep one empty camera slot
            const filledSlots = beforePhotos.length;
            const minRows = Math.ceil((filledSlots + 1) / 2); // +1 for camera slot
            totalSlots = minRows * 2; // Always even number for 2-column layout
          }

          console.log(`Grid calculation: ${beforePhotos.length} photos, ${totalSlots} total slots`);

          // Fill grid positions based on before photos chronologically
          for (let i = 0; i < totalSlots; i++) {
            const beforePhotoIndex = i;

            if (beforePhotoIndex < beforePhotos.length) {
              const beforePhoto = beforePhotos[beforePhotoIndex];

              // Check if there's a corresponding after photo
              const afterPhoto = this.photos.find(p =>
                p.room === this.currentRoom &&
                p.mode === 'after' &&
                p.timestamp > beforePhoto.timestamp &&
                // Find after photo that matches this before photo (within reasonable time)
                Math.abs(p.timestamp - beforePhoto.timestamp) < 300000 // Within 5 minutes
              );

              if (afterPhoto) {
                // Show split-screen before/after
                const photoName = beforePhoto.name || `${beforePhoto.room}_before_${beforePhoto.timestamp}`;
                const displayName = photoName.replace(/_/g, ' ').replace(/\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/, '');

                gridItems.push(`
                  <div class="photo-item" data-photo-index="${this.photos.indexOf(afterPhoto)}" style="border: 1px solid #E1E1E1; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1;">
                    <!-- Split screen container taking full card space -->
                    <div style="height: 100%; display: flex; flex-direction: column; position: relative;">
                      <!-- Before photo (top half) -->
                      <div style="height: 50%; overflow: hidden; position: relative;">
                        <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                        <div style="position: absolute; top: 2px; left: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold;">BEFORE</div>
                      </div>
                      <!-- Divider line -->
                      <div style="height: 2px; background: #000;"></div>
                      <!-- After photo (bottom half) -->
                      <div style="height: 50%; overflow: hidden; position: relative;">
                        <img src="${afterPhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold;">AFTER</div>
                      </div>
                    </div>

                    <!-- Transparent title overlay -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(0,0,0,0.7));">
                      <div style="color: white; font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${displayName}</div>
                      <div style="color: rgba(255,255,255,0.9); font-size: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                    </div>

                    <!-- Delete button -->
                    <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(afterPhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                      üóëÔ∏è
                    </button>
                  </div>
                `);
              } else {
                // Show only before photo
                const photoName = beforePhoto.name || `${beforePhoto.room}_before_${beforePhoto.timestamp}`;
                const displayName = photoName.replace(/_/g, ' ').replace(/\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/, '');

                gridItems.push(`
                  <div class="photo-item" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="border: 1px solid #E1E1E1; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s;">
                    <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 120px; object-fit: cover; cursor: pointer;" />
                    <div style="padding: 8px; font-size: 11px; color: #B3B3B3;">
                      <div style="font-weight: bold; margin-bottom: 2px; color: #303030;">${displayName}</div>
                      <div style="font-size: 10px; opacity: 0.8;">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                    </div>
                    <!-- Delete button -->
                    <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                      üóëÔ∏è
                    </button>
                  </div>
                `);
              }
            } else {
              // Empty slots
              const isLastSlot = i === totalSlots - 1;
              const currentRow = Math.floor(i / 2);
              const currentCol = i % 2;

              // Camera placeholder logic:
              // - If we have fewer than 5 photos, camera goes in last slot of initial 6
              // - If we have 5+ photos, camera goes in the new row
              let isCameraSlot = false;

              if (beforePhotos.length < 5) {
                // Initial 6 slots - camera in position 5 (last slot)
                isCameraSlot = i === 5;
              } else {
                // Dynamic expansion - camera in last slot
                isCameraSlot = isLastSlot;
              }

              if (isCameraSlot) {
                gridItems.push(`
                  <div class="dummy-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #E1E1E1; border: 2px dashed #B3B3B3; display: flex; align-items: center; justify-content: center; color: #B3B3B3; font-size: 32px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#F2C31B'; this.style.color='#303030';" onmouseout="this.style.background='#E1E1E1'; this.style.color='#B3B3B3';">
                    ${roomIcons[this.currentRoom] || 'üì∑'}
                  </div>
                `);
              } else {
                // Regular empty placeholder
                gridItems.push(`
                  <div style="aspect-ratio: 1; border-radius: 8px; background: transparent; display: flex; align-items: center; justify-content: center;">
                  </div>
                `);
              }
            }
          }

          console.log('Grid items count:', gridItems.length);
          return gridItems.join('');
        }
        
        getRoomPhotosByType(type) {
          const roomPhotos = this.photos.filter(photo => photo.room === this.currentRoom);
          console.log('getRoomPhotosByType - Type:', type, 'Current room:', this.currentRoom);
          console.log('getRoomPhotosByType - Room photos:', roomPhotos);
          
          if (type === 'photo') {
            const result = roomPhotos.filter(photo => photo.mode === 'before' || photo.mode === 'after');
            console.log('getRoomPhotosByType - Photo result:', result);
            return result;
          } else if (type === 'combined') {
            const result = roomPhotos.filter(photo => photo.mode === 'mix');
            console.log('getRoomPhotosByType - Combined result:', result);
            return result;
          } else if (type === 'all') {
            const result = roomPhotos.filter(photo => photo.mode === 'archived' || photo.mode === 'mix');
            console.log('getRoomPhotosByType - All result:', result);
            return result;
          }
          return roomPhotos;
        }
        
        getRoomFilteredPhotos() {
          // Always show photos by default, unless specifically viewing combined or all
          return this.getRoomPhotosByType(this.currentTab || 'photo');
        }
        
        addSwipeListeners() {
          // Only add listeners once
          if (this.swipeListenersAdded) return;
          this.swipeListenersAdded = true;
          
          // Ensure room order matches the visual tab order exactly
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          let startX = 0;
          let startY = 0;
          
          // Add touch events for swiping
          document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          });
          
          document.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const diffX = startX - endX;
            const diffY = startY - endY;
            
            // Only trigger swipe if horizontal movement is greater than vertical
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
              const currentIndex = rooms.indexOf(this.currentRoom);
              console.log('Swipe - Current room:', this.currentRoom, 'Index:', currentIndex);
              
              if (diffX > 0) {
                // Swipe left - next room (following tab order)
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
                console.log('Swipe left - Next room:', this.currentRoom, 'Index:', nextIndex);
              } else {
                // Swipe right - previous room (following tab order)
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
                console.log('Swipe right - Previous room:', this.currentRoom, 'Index:', prevIndex);
              }
              
              this.currentTab = 'photo';
              this.init();
              
              // Delay carousel update to ensure DOM is ready
              setTimeout(() => {
                this.updateTabsCarousel();
                window.scrollTo({ top: 0, behavior: 'smooth' });
              }, 200);
            }
          });
          
          // Add keyboard support for cycling
          document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
              e.preventDefault();
              const currentIndex = rooms.indexOf(this.currentRoom);
              
              if (e.key === 'ArrowLeft') {
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
              } else {
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
              }
              
              this.currentTab = 'photo';
              this.init();
              
              // Delay carousel update to ensure DOM is ready
              setTimeout(() => {
                this.updateTabsCarousel();
                window.scrollTo({ top: 0, behavior: 'smooth' });
              }, 200);
            }
          });
        }
        
        updateTabsCarousel() {
          // Just re-render the tabs - the carousel positioning is handled in getRoomTabsCarousel()
          const tabsCarousel = document.getElementById('tabs-carousel');
          if (tabsCarousel) {
            tabsCarousel.innerHTML = this.getRoomTabsCarousel();
            console.log('Carousel updated for room:', this.currentRoom);
          }
        }

        showActionButtons() {
          // Show retake and save buttons, hide camera button
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');

          if (retakeBtn) retakeBtn.style.display = 'flex';
          if (saveBtn) saveBtn.style.display = 'flex';
          if (cameraBtn) cameraBtn.style.display = 'none';
        }

        hideActionButtons() {
          // Hide retake and save buttons, show camera button
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');

          if (retakeBtn) retakeBtn.style.display = 'none';
          if (saveBtn) saveBtn.style.display = 'none';
          if (cameraBtn) cameraBtn.style.display = 'block';
        }

        addScrollListener() {
          // Throttle scroll events for performance
          let scrollTimeout;

          window.addEventListener('scroll', () => {
            if (scrollTimeout) {
              clearTimeout(scrollTimeout);
            }

            scrollTimeout = setTimeout(() => {
              this.checkVisibleRoom();
            }, 100); // Check every 100ms during scroll
          });
        }

        checkVisibleRoom() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          const viewportHeight = window.innerHeight;
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          const tabsHeight = 80; // Height of fixed tabs container

          // Check which room section is most visible in the viewport
          let mostVisibleRoom = null;
          let maxVisibleArea = 0;

          rooms.forEach(room => {
            const roomSection = document.querySelector(`[data-room="${room}"].room-section`);
            if (!roomSection) return;

            const rect = roomSection.getBoundingClientRect();
            const sectionTop = rect.top + scrollTop;
            const sectionBottom = sectionTop + rect.height;

            // Calculate visible area of this section
            const visibleTop = Math.max(sectionTop, scrollTop + tabsHeight);
            const visibleBottom = Math.min(sectionBottom, scrollTop + viewportHeight);
            const visibleArea = Math.max(0, visibleBottom - visibleTop);

            // Also consider sections that are prominently in view (top 1/3 of screen)
            const prominentViewTop = scrollTop + tabsHeight;
            const prominentViewBottom = scrollTop + (viewportHeight / 3) + tabsHeight;

            if (sectionTop <= prominentViewBottom && sectionBottom >= prominentViewTop) {
              const prominentArea = Math.min(sectionBottom, prominentViewBottom) - Math.max(sectionTop, prominentViewTop);
              const prominentWeight = prominentArea * 2; // Give more weight to prominent area

              if (prominentWeight > maxVisibleArea) {
                maxVisibleArea = prominentWeight;
                mostVisibleRoom = room;
              }
            } else if (visibleArea > maxVisibleArea) {
              maxVisibleArea = visibleArea;
              mostVisibleRoom = room;
            }
          });

          // Update current room if it changed
          if (mostVisibleRoom && mostVisibleRoom !== this.currentRoom) {
            console.log('Auto-switching to room:', mostVisibleRoom, 'based on scroll position');
            this.currentRoom = mostVisibleRoom;
            this.updateTabsCarousel();
          }
        }
        
        attachEventListeners() {
          // Room tabs with swipe support
          document.querySelectorAll('.room-tab').forEach(btn => {
            btn.addEventListener('click', (e) => {
              this.currentRoom = e.target.dataset.room;
              this.currentTab = 'photo'; // Reset to photo tab when switching rooms
              this.init();
              
              // Delay carousel update to ensure DOM is ready
              setTimeout(() => {
                this.updateTabsCarousel();
                window.scrollTo({ top: 0, behavior: 'smooth' });
              }, 200);
            });
          });
          
          // Add swipe functionality to room tabs
          this.addSwipeListeners();
          
          // Room sections click handlers
          setTimeout(() => {
            document.querySelectorAll('.room-section').forEach(section => {
              section.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                this.currentRoom = room;
                this.currentTab = 'photo';
                this.init();
                
                // Delay tab centering to ensure DOM is ready
                setTimeout(() => {
                  this.scrollToActiveTab();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              });
            });
            
            // Dummy photos click handlers
            document.querySelectorAll('.dummy-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent room section click
                const room = e.currentTarget.dataset.room;
                
                // Switch to the room if it's different
                if (this.currentRoom !== room) {
                  this.currentRoom = room;
                  this.currentTab = 'photo';
                }
                
                // Open camera in "before" mode
                this.openCameraForRoom(room);
              });
            });
          }, 100);
          
          // Camera
          document.getElementById('camera-btn').addEventListener('click', () => {
            // Check if we're in a camera modal (before or after mode)
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]');

            if (cameraModal) {
              // We're in a camera modal, capture photo
              if (cameraModal.innerHTML.includes('camera-video')) {
                // Before mode - regular camera
                console.log('Capturing from regular camera modal');
                this.captureFromCameraModal();
              } else if (cameraModal.innerHTML.includes('comparison-camera')) {
                // After mode - comparison camera
                console.log('Capturing from comparison camera modal');
                this.captureFromComparisonModal();
              }
            } else {
              // No camera modal open, open camera
              console.log('Opening new camera');
              this.openCamera();
            }
          });
          
          // Header upload button (dummy functionality)
          const headerUploadBtn = document.getElementById('header-upload-btn');
          if (headerUploadBtn) {
            headerUploadBtn.addEventListener('click', () => {
              alert('Upload functionality will be added soon!');
            });
          }
          
          // Location select
          const locationSelect = document.getElementById('location-select');
          if (locationSelect) {
            locationSelect.addEventListener('change', (e) => {
              console.log('Location changed to:', e.target.value);
              // You can add location-specific functionality here
            });
          }
          
          // Retake and Save button handlers
          const retakeBtn = document.getElementById('btn-retake');
          if (retakeBtn) {
            retakeBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Store the room before closing split screen
                const room = this.currentSplitScreen.room;

                // Close current split screen
                this.closeSplitScreenPreview();

                // Clean up any remaining modals
                const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
                existingModals.forEach(modal => {
                  try {
                    if (modal.parentNode && !modal.id.includes('bottom-panel')) {
                      if (modal.parentNode === document.body) {
                        document.body.removeChild(modal);
                      } else {
                        modal.parentNode.removeChild(modal);
                      }
                    }
                  } catch (error) {
                    console.log('Modal already removed:', error);
                  }
                });

                // Small delay to ensure cleanup completes
                setTimeout(() => {
                  // Find the before photo and reopen comparison camera
                  const beforePhoto = this.photos.find(p =>
                    p.room === room && p.mode === 'before'
                  );

                  if (beforePhoto) {
                    this.showPhotoFullscreen(beforePhoto);
                  }
                }, 100);
              }
            });
          }

          const saveBtn = document.getElementById('btn-save');
          if (saveBtn) {
            saveBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Save the combined photo
                this.captureSplitScreenPhoto(
                  this.currentSplitScreen.beforeDataUrl,
                  this.currentSplitScreen.afterDataUrl,
                  this.currentSplitScreen.room
                );

                // Close split screen and return to gallery
                this.closeSplitScreenPreview();
              }
            });
          }
          
          // Photo click to view fullscreen and delete functionality
          setTimeout(() => {
            document.querySelectorAll('.photo-item').forEach(item => {
              // Photo click to view fullscreen
              item.addEventListener('click', (e) => {
                // Don't trigger if clicking delete button
                if (e.target.classList.contains('delete-photo-btn')) return;
                
                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                this.showPhotoFullscreen(this.photos[photoIndex]);
              });
              
              // Add hover effect
              item.addEventListener('mouseenter', (e) => {
                e.currentTarget.style.transform = 'scale(1.02)';
              });
              item.addEventListener('mouseleave', (e) => {
                e.currentTarget.style.transform = 'scale(1)';
              });
            });
            
            // Delete button functionality
            document.querySelectorAll('.delete-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent photo click
                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                this.deletePhoto(photoIndex);
              });
            });
          }, 100);
        }
        
        
        updateTabs() {
          document.querySelectorAll('.photo-tab').forEach(tab => {
            const tabType = tab.dataset.tab;
            if (tabType === this.currentTab) {
              tab.style.background = '#F2C31B';
              tab.style.color = '#303030';
            } else {
              tab.style.background = 'transparent';
              tab.style.color = '#B3B3B3';
            }
          });
        }
        
        deletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            const photo = this.photos[photoIndex];
            const photoType = photo.mode === 'mix' ? 'combined before/after' : photo.mode;
            
            if (confirm(`Are you sure you want to delete this ${photoType} photo from ${photo.room}?`)) {
              this.photos.splice(photoIndex, 1);
              this.savePhotos();
              this.init(); // Refresh the gallery
            }
          }
        }
        
        async showPhotoFullscreen(photo) {
          // Clean up any existing photo fullscreen modals first
          const existingPhotoModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"]');
          existingPhotoModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;
          
          if (photo.mode === 'before') {
            // Split screen: before photo and camera
            modal.innerHTML = this.getComparisonModalHTML(photo);
            
            document.body.appendChild(modal);
            
            // Initialize camera for comparison
            try {
              let stream;
              try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                  video: { facingMode: 'environment' } // Default to back camera
                });
              } catch (backCameraError) {
                console.log('Back camera not available, trying any camera:', backCameraError);
                stream = await navigator.mediaDevices.getUserMedia({ video: true });
              }
              
              const video = document.getElementById('comparison-camera');
              video.srcObject = stream;
              
              let currentFacingMode = 'environment';
              
              
              // Close button
              document.getElementById('close-comparison-btn').addEventListener('click', () => {
                stream.getTracks().forEach(track => track.stop());
                document.body.removeChild(modal);
              });
              
            } catch (error) {
              alert('Camera access denied or failed: ' + error.message);
              document.body.removeChild(modal);
            }
            
          } else {
            // Regular fullscreen for after photos
            modal.innerHTML = `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center;">
                <img src="${photo.dataUrl}" style="width: 100vw; height: 100vh; object-fit: cover;" />
                
                <!-- Photo info overlay -->
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 40px 20px 20px; text-align: center; color: white;">
                  <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                    ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                  </div>
                  <div style="font-size: 16px; opacity: 0.9;">
                    ${new Date(photo.timestamp).toLocaleString()}
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-photo-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('close-photo-btn').addEventListener('click', () => {
              document.body.removeChild(modal);
            });
            
            // Close on background click
            modal.addEventListener('click', (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);
              }
            });
          }
        }
        
        captureComparisonPhoto(video, stream, beforePhoto) {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          ctx.drawImage(video, 0, 0);

          const dataUrl = canvas.toDataURL('image/jpeg', 0.8);

          // Automatically save the "after" photo
          this.saveAfterPhotoToAll(dataUrl, beforePhoto);

          // Stop camera stream
          stream.getTracks().forEach(track => track.stop());

          // Close ALL existing modals to prevent overlapping
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
          existingModals.forEach(modal => {
            try {
              if (modal.parentNode && modal.parentNode === document.body) {
                document.body.removeChild(modal);
              } else if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Small delay to ensure cleanup completes before creating new modal
          setTimeout(() => {
            // Go directly to split screen preview
            this.showSplitScreenPreview(beforePhoto.dataUrl, dataUrl, beforePhoto.room);
          }, 100);
        }
        
        saveAfterPhotoToAll(afterPhotoDataUrl, beforePhoto) {
          // Create meaningful name for the after photo
          const roomName = beforePhoto.room.charAt(0).toUpperCase() + beforePhoto.room.slice(1).replace('-', ' ');
          const afterPhotoName = `${roomName}_After_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
          
          const afterPhoto = {
            id: Date.now(),
            dataUrl: afterPhotoDataUrl,
            room: beforePhoto.room,
            mode: 'after', // Save as after photo for split-screen display
            name: afterPhotoName,
            timestamp: Date.now()
          };
          
          this.photos.push(afterPhoto);
          this.savePhotos();
        }
        
        
        
        
        showSplitScreenPreview(beforeDataUrl, afterDataUrl, room) {
          // Clean up any existing split screen modals first
          const existingSplitScreens = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"]');
          existingSplitScreens.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Create a new modal for split screen preview
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;

          modal.innerHTML = this.getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room);
          document.body.appendChild(modal);

          // Show action buttons in bottom panel
          this.showActionButtons();

          // Store current split screen data for button handlers
          this.currentSplitScreen = {
            beforeDataUrl,
            afterDataUrl,
            room,
            modal
          };

          // Close button event listener
          document.getElementById('close-split-btn').addEventListener('click', () => {
            this.closeSplitScreenPreview();
          });
        }

        closeSplitScreenPreview() {
          if (this.currentSplitScreen && this.currentSplitScreen.modal) {
            try {
              if (this.currentSplitScreen.modal.parentNode) {
                if (this.currentSplitScreen.modal.parentNode === document.body) {
                  document.body.removeChild(this.currentSplitScreen.modal);
                } else {
                  this.currentSplitScreen.modal.parentNode.removeChild(this.currentSplitScreen.modal);
                }
              }
            } catch (error) {
              console.log('Split screen modal already removed:', error);
            }
          }

          // Clean up any remaining split screen modals that might be orphaned
          const splitScreenModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"]');
          splitScreenModals.forEach(modal => {
            try {
              if (modal.parentNode) {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Hide action buttons and show camera button
          this.hideActionButtons();

          // Clear current split screen data
          this.currentSplitScreen = null;
        }
        
        captureSplitScreenPhoto(beforeDataUrl, afterDataUrl, room) {
          // Create a temporary fullscreen container for the split-screen photo
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: white; z-index: 9999;
          `;
          
          tempContainer.innerHTML = `
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column;">
              <!-- Before photo (top half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  BEFORE
                </div>
              </div>
              
              <!-- Divider line -->
              <div style="width: 100%; height: 4px; background: #000;"></div>
              
              <!-- After photo (bottom half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  AFTER
                </div>
              </div>
            </div>
          `;
          
          document.body.appendChild(tempContainer);
          
          // Use html2canvas to capture the entire screen
          setTimeout(() => {
            this.captureScreenAsImage(tempContainer, room);
          }, 500); // Give time for images to load
        }
        
        captureScreenAsImage(container, room) {
          // Create a canvas to capture the screen
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match the container
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          
          // Fill white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Get all images from the container
          const images = container.querySelectorAll('img');
          let imagesLoaded = 0;
          const totalImages = images.length;
          
          if (totalImages === 0) {
            // No images, just save the container
            this.saveCombinedPhoto(canvas.toDataURL('image/jpeg', 0.9), room);
            document.body.removeChild(container);
            return;
          }
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // All images loaded, now draw them
              const halfHeight = canvas.height / 2;
              
              // Draw before photo (top half)
              const beforeImg = images[0];
              ctx.drawImage(beforeImg, 0, 0, canvas.width, halfHeight);
              
              // Draw divider line
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(0, halfHeight);
              ctx.lineTo(canvas.width, halfHeight);
              ctx.stroke();
              
              // Draw after photo (bottom half)
              const afterImg = images[1];
              ctx.drawImage(afterImg, 0, halfHeight, canvas.width, halfHeight);
              
              // Add labels
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.font = 'bold 18px Arial';
              ctx.textAlign = 'center';
              
              // Before label
              ctx.fillRect(canvas.width/2 - 50, 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('BEFORE', canvas.width/2, 40);
              
              // After label
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.fillRect(canvas.width/2 - 50, halfHeight + 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('AFTER', canvas.width/2, halfHeight + 40);
              
              // Convert to data URL and save
              const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
              this.saveCombinedPhoto(combinedDataUrl, room);
              
              // Clean up
              document.body.removeChild(container);
            }
          };
          
          // Set up image load handlers
          images.forEach(img => {
            if (img.complete) {
              onImageLoad();
            } else {
              img.onload = onImageLoad;
            }
          });
        }
        
        saveCombinedPhoto(combinedDataUrl, room) {
          // Find the before photo for this room (after photos are already in "All" tab)
          const roomPhotos = this.photos.filter(photo => photo.room === room);
          const beforePhoto = roomPhotos.find(photo => photo.mode === 'before');
          
          // Create meaningful name for the combined photo
          const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
          const combinedPhotoName = `${roomName}_Combined_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
          
          // Create the combined photo
          const combinedPhoto = {
            id: Date.now(),
            dataUrl: combinedDataUrl,
            room: room,
            mode: 'mix',
            name: combinedPhotoName,
            timestamp: Date.now()
          };
          
          // Add the combined photo
          this.photos.push(combinedPhoto);
          
          // Move before photo to "archived" mode (All tab)
          if (beforePhoto) {
            beforePhoto.mode = 'archived';
          }
          
          this.savePhotos();

          // Photo saved successfully - modal closing handled by caller
        }
        
        async openCameraForRoom(room) {
          // Set the current room
          this.currentRoom = room;
          
          // Open camera
          await this.openCamera();
        }
        
        async openCamera() {
          console.log('Opening camera...');
          try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
              alert('Camera not supported on this device');
              return;
            }

            // Clean up any existing camera modals first
            const existingCameraModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 1000"]');
            existingCameraModals.forEach(existing => {
              if (existing.parentNode) {
                document.body.removeChild(existing);
              }
            });

            // Try to use back camera first, fallback to any camera
            let stream;
            try {
              stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' } // Back camera
              });
            } catch (backCameraError) {
              console.log('Back camera not available, trying any camera:', backCameraError);
              stream = await navigator.mediaDevices.getUserMedia({ video: true });
            }

            // Create fullscreen camera modal
            const modal = document.createElement('div');
            modal.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
              background: black; z-index: 1000; display: flex; 
              flex-direction: column; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = this.getCameraModalHTML();
            
            document.body.appendChild(modal);
            console.log('Camera modal created and added to DOM');
            
            const video = document.getElementById('camera-video');
            console.log('Video element found:', video);
            if (video) {
              video.srcObject = stream;
              console.log('Stream assigned to video');
            } else {
              console.error('Video element not found!');
            }
            
            // Store current facing mode
            let currentFacingMode = 'environment'; // Start with back camera
            
            // Capture will be handled by the bottom panel camera button
            
            document.getElementById('close-camera-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              if (modal && modal.parentNode) {
                document.body.removeChild(modal);
              }
            });
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
          }
        }
        
        captureFromCameraModal() {
          // Get the camera video element
          const video = document.getElementById('camera-video');
          if (!video || !video.srcObject) {
            console.error('Camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Capture the before photo
          this.capturePhoto(video, stream);
        }
        
        captureFromComparisonModal() {
          // Get the comparison camera video element
          const video = document.getElementById('comparison-camera');
          if (!video || !video.srcObject) {
            console.error('Comparison camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Get the before photo from the comparison modal
          const beforePhotoImg = document.querySelector('[style*="object-fit: cover"]');
          if (!beforePhotoImg) {
            console.error('Before photo not found in comparison modal');
            return;
          }
          
          // Create a before photo object from the image
          const beforePhoto = {
            dataUrl: beforePhotoImg.src,
            room: this.currentRoom,
            mode: 'before',
            timestamp: Date.now()
          };
          
          // Capture the after photo
          this.captureComparisonPhoto(video, stream, beforePhoto);
        }
        
        capturePhoto(video, stream) {
          console.log('Capturing photo...');
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          
          context.drawImage(video, 0, 0);
          
          // First photos are always "before" photos
          const photoMode = 'before';
          
          // Create meaningful name for the photo
          const roomName = this.currentRoom.charAt(0).toUpperCase() + this.currentRoom.slice(1).replace('-', ' ');
          const photoName = `${roomName}_${photoMode}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
          
          const photo = {
            id: Date.now(),
            dataUrl: canvas.toDataURL('image/jpeg', 0.8),
            room: this.currentRoom,
            mode: photoMode,
            name: photoName,
            timestamp: Date.now()
          };
          
          console.log('Photo created:', photo);
          this.photos.push(photo);
          console.log('Photos array length:', this.photos.length);
          this.savePhotos();
          
          // Close camera
          stream.getTracks().forEach(track => track.stop());
          
          // Remove the camera modal
          const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]');
          if (modal) {
            document.body.removeChild(modal);
          }
          
          // Refresh display
          this.init();
          console.log('Photo capture completed');
        }
        
        savePhotos() {
          localStorage.setItem('cleaning-photos', JSON.stringify(this.photos));
        }
        
        loadPhotos() {
          const saved = localStorage.getItem('cleaning-photos');
          if (saved) {
            this.photos = JSON.parse(saved);
          }
        }
      }
      
      // Initialize app
      new CleaningPhotoApp();
      console.log('‚úÖ Debug: iOS Safari compatible app loaded successfully');
    </script>
    
    <!-- Fallback for browsers that don't support ES6 modules -->
    <script nomodule>
      console.log('‚ùå Debug: ES6 modules not supported, using fallback');
      document.getElementById('debug-info').innerHTML += '<div style="color: orange;">‚ö†Ô∏è ES6 modules not supported</div>';
      
      // Show a simple message instead of React app
      setTimeout(() => {
        document.getElementById('root').innerHTML = `
          <div style="padding: 20px; text-align: center; font-family: Arial, sans-serif;">
            <h1>üö´ Browser Compatibility Issue</h1>
            <p>Your browser doesn't support ES6 modules, which are required for this app.</p>
            <p>Please update your browser or try a different browser.</p>
            <p style="color: #666; font-size: 14px;">iOS Safari 10.3+ is required for ES6 module support.</p>
          </div>
        `;
      }, 2000);
    </script>
    
    <script>
      // This will run after main.jsx loads (if it loads)
      console.log('‚úÖ Debug: main.jsx script tag processed');
    </script>
  </body>
</html>