<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#F2C31B" />
    <meta name="description" content="Mobile-first cleaning photo documentation app" />

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

    <!-- Prevent zoom on input fields -->
    <meta name="format-detection" content="telephone=no" />

    <!-- Status bar styling for iOS -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Cleaning App" />
    
    <!-- Additional iOS compatibility -->
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="apple-mobile-web-app-orientations" content="portrait" />

    <title>Cleaning Photo App</title>

    <!-- Google Fonts - Garamond -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

    <style>
      /* Prevent flash of unstyled content */
      body {
        margin: 0;
        padding: 0;
        font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif;
        background-color: #f8fafc;
        color: #1e293b;
        overscroll-behavior-y: auto;
        overscroll-behavior-x: none;
        overflow-x: hidden;
        width: 100vw;
        max-width: 100vw;
        height: 100vh;
      }
      
      * {
        box-sizing: border-box;
      }
      
      /* Hide scrollbars for swipeable elements */
      #room-tabs-container::-webkit-scrollbar {
        display: none;
      }
      
      #room-tabs-container {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      /* Loading spinner */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8fafc;
        z-index: 9999;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #e2e8f0;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Hide loading once React loads */
      #root:not(:empty) + .loading-container {
        display: none;
      }

      /* Debug info */
      .debug-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 10000;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <div class="loading-container">
      <div class="loading-spinner"></div>
    </div>
    
    <!-- Debug info (hidden by default) -->
    <div class="debug-info" id="debug-info" style="display: none;">
      <div>üì± User Agent: <span id="user-agent">Loading...</span></div>
      <div>üåê Location: <span id="location">Loading...</span></div>
      <div>‚è∞ Time: <span id="time">Loading...</span></div>
    </div>
    
    <script>
      // Basic debug info
      
      // Update debug info
      document.getElementById('user-agent').textContent = navigator.userAgent.substring(0, 50) + '...';
      document.getElementById('location').textContent = window.location.href;
      document.getElementById('time').textContent = new Date().toLocaleTimeString();
      
      // Check if we're on iOS
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      
      if (isIOS) {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">üçé iOS Detected</div>';
      }
      
      // Check if React loads
      let reactLoadTimer = setTimeout(() => {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå React Failed to Load</div>';
      }, 10000);
      
      // Clear timer when React loads
      window.addEventListener('load', () => {
        clearTimeout(reactLoadTimer);
      });
      
      // Check for React errors
      window.addEventListener('error', (e) => {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå JS Error: ' + e.error.message + '</div>';
      });
      
      // Check for unhandled promise rejections
      window.addEventListener('unhandledrejection', (e) => {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå Promise Error: ' + e.reason + '</div>';
      });
      
      // Monitor script loading
      const scripts = document.querySelectorAll('script[type="module"]');
      scripts.forEach((script, index) => {
        script.addEventListener('load', () => {
          document.getElementById('debug-info').innerHTML += '<div style="color: green;">‚úÖ Script ' + index + ' loaded</div>';
        });
        script.addEventListener('error', (e) => {
          document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå Script ' + index + ' failed: ' + e.message + '</div>';
        });
      });
      
      // Check if main.jsx loads
    </script>
    
    <!-- Simple JavaScript test -->
    <script>
      
      // Test if we can create DOM elements
      try {
        const testDiv = document.createElement('div');
        testDiv.innerHTML = '<div style="color: green;">‚úÖ Basic JavaScript Works!</div>';
        document.getElementById('debug-info').appendChild(testDiv);
      } catch (e) {
      }
      
    </script>
    
    <!-- Try a very simple inline test first -->
    <script>
      try {
        const root = document.getElementById('root');
        if (root) {
          root.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Inline Script Works!</h1><p>JavaScript is executing on iPhone!</p></div>';
        } else {
        }
      } catch (e) {
      }
    </script>
    
    <!-- Try regular script (not module) -->
    <script>
      
      try {
        const rootElement = document.getElementById('root');
        if (rootElement) {
          rootElement.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Regular Script Works!</h1><p>This proves regular JavaScript works on iOS Safari.</p><p>Now loading bundled React app...</p></div>';
        }
      } catch (error) {
      }
    </script>
    
    <!-- iOS Safari Compatible Cleaning Photo App -->
    <script>
      
      // Simple photo documentation app
      class CleaningPhotoApp {
        constructor() {
          this.photos = [];
          this.currentRoom = 'kitchen';
          this.currentTab = 'photo';
          this.isLandscape = false;
          this.currentTemplate = 'default'; // Default template for all photos
          this.loadPhotos(); // Load photos first
          this.init();
        }
        
        init() {

          // Check orientation
          this.checkOrientation();

          // Reassign photo names to ensure proper sequential numbering
          this.reassignPhotoNames();

          const rootElement = document.getElementById('root');
          if (rootElement) {
            rootElement.innerHTML = this.getAppHTML();

            // Verify header was created
            setTimeout(() => {
              const headerUploadBtn = document.getElementById('header-upload-btn');
            }, 10);

            this.attachEventListeners();
            this.updateTabsCarousel(); // Update carousel layout

            // Ensure bottom panel is hidden in gallery mode
            this.hideActionButtons();

            // Ensure room tab listeners are attached with a small delay
            setTimeout(() => {
              this.attachRoomTabListeners();
            }, 50);

            // BACKUP: Also try a more direct approach after a longer delay
            setTimeout(() => {
              document.querySelectorAll('#tabs-carousel .room-tab').forEach((btn, i) => {
                btn.onclick = (e) => {
                  const room = btn.dataset.room;
                  if (room && room !== this.currentRoom) {
                    this.currentRoom = room;
                    this.currentTab = 'photo';
                    const photosContainer = document.getElementById('photos-container');
                    if (photosContainer) {
                      photosContainer.innerHTML = this.getPhotosHTML();
                      this.attachPhotoListeners();
                    }
                    setTimeout(() => {
                      this.updateTabsCarousel();
                    }, 100);
                  }
                };
              });
            }, 200);

            // Auto-scroll to bottom after app initialization
            setTimeout(() => {
              const mainScrollableContent = document.getElementById('main-scrollable-content');
              if (mainScrollableContent) {
                mainScrollableContent.scrollTop = mainScrollableContent.scrollHeight;
              }
            }, 300);
          }
          
          // Listen for orientation changes
          window.addEventListener('orientationchange', () => {
            setTimeout(() => {
              this.checkOrientation();
              this.init();
            }, 100);
          });
          
          window.addEventListener('resize', () => {
            // Update orientation detection
            const wasLandscape = this.isLandscape;
            this.checkOrientation();
            
            // If orientation changed, update grids
            if (wasLandscape !== this.isLandscape) {
              setTimeout(() => {
                this.updateGridsOnOrientationChange();
              }, 100); // Small delay to ensure layout is stable
            }
            
            this.init();
          });

          // Add scroll listener for auto tab switching
          this.addScrollListener();
        }
        
        checkOrientation() {
          this.isLandscape = window.innerWidth > window.innerHeight;
        }
        
        getCameraModalHTML() {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <!-- Landscape camera - left/right split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Active camera -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Reference or inactive -->
                <div style="position: relative; width: 50%; height: 100%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls on the left</div>
                  </div>
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top/bottom split
            return `
              <!-- Portrait camera - top/bottom split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Active camera -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Reference or inactive -->
                <div style="position: relative; width: 100%; height: 50%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls above</div>
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getBeforePhotoModalHTML() {
          if (this.isLandscape) {
            // Landscape mode - left (camera) and right (existing photos)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top section - Camera and Photos -->
                <div style="position: relative; width: 100%; height: calc(100% - 80px); display: flex; flex-direction: row;">
                  <!-- Left half - Camera -->
                  <div id="camera-container" style="position: relative; width: 50%; height: 100%; background: black;">
                    <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                    
                    <!-- Photo frame overlay for camera -->
                    <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                      <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                    </div>
                    
                    <!-- Before label -->
                    <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                      BEFORE
                    </div>
                    
                    <!-- Close button - positioned within camera view -->
                    <button id="close-before-modal-btn" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 10; backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center;">
                      ‚úï
                    </button>
                  </div>
                  
                  <!-- Divider line -->
                  <div style="width: 4px; height: 100%; background: #000;"></div>
                  
                  <!-- Right half - Photo Grid Only -->
                  <div style="position: relative; width: calc(50% - 80px); height: 100%; background: #f8f9fa; overflow-y: auto; padding: 10px; padding-bottom: 15px;">
                    ${this.getBeforePhotosGridHTML()}
                  </div>
                </div>
                
                <!-- Bottom section - Room Tabs (spanning full width) -->
                <div style="position: relative; width: 100%; height: 80px; background: #f8fafc; padding: 10px; box-shadow: 0 -2px 8px rgba(0,0,0,0.1); display: flex; justify-content: center; align-items: center;">
                  <div id="modal-room-tabs-container" style="position: relative; width: 100%; height: 60px; overflow: hidden;">
                    <div id="modal-tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                      ${this.getRoomTabsCarousel()}
                    </div>
                  </div>
                </div>
              </div>
            `;
          } else {
            // Portrait mode - top (camera) and bottom (existing photos)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Camera -->
                <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Room Tabs Section -->
                <div style="width: 100%; background: #f8fafc; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                  <div id="modal-room-tabs-container" style="position: relative; width: 100%; height: 60px; overflow: hidden;">
                    <div id="modal-tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                      ${this.getRoomTabsCarousel()}
                    </div>
                  </div>
                </div>
                
                <!-- Bottom half - Photo Grid -->
                <div id="before-photo-grid" style="width: 100%; flex: 1; background: #f8f9fa; overflow-y: auto; padding: 10px; padding-bottom: 15px; min-height: 200px;">
                  ${this.getBeforePhotosGridHTML()}
                </div>
                
                <!-- Close button -->
                <button id="close-before-modal-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }

        getBeforePhotosGridHTML() {
          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for current room
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp);

          // Create grid layout with all photos and dummy squares
          const gridItems = [];
          
          // Add all existing photos
          beforePhotos.forEach(photo => {
            gridItems.push(`
              <div class="before-photo-item" data-photo-id="${photo.id}" style="aspect-ratio: 1; border-radius: 8px; overflow: hidden; position: relative; cursor: pointer; border: 2px solid #e1e5e9; transition: all 0.2s;" onmouseover="this.style.borderColor='#F2C31B'; this.style.transform='scale(1.02)'" onmouseout="this.style.borderColor='#e1e5e9'; this.style.transform='scale(1)'">
                <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                
                <!-- Delete button -->
                <button class="delete-before-photo-btn" data-photo-id="${photo.id}" style="position: absolute; top: 5px; right: 5px; background: #F2C31B; color: #303030; border: none; padding: 6px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#e6b800'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='#F2C31B'; this.style.transform='scale(1)'">
                  √ó
                </button>
                
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 8px; color: white;">
                  <div style="font-size: 12px; font-weight: bold;">${photo.name}</div>
                  <div style="font-size: 10px; opacity: 0.9;">${new Date(photo.timestamp).toLocaleTimeString()}</div>
                </div>
              </div>
            `);
          });
          
          // Add one dummy square for taking more photos
          gridItems.push(`
            <div class="dummy-before-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; color: #999; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e8e8e8'; this.style.color='#666';" onmouseout="this.style.background='#f0f0f0'; this.style.color='#999';">
              ${roomIcons[this.currentRoom] || 'üì∑'}
            </div>
          `);

          return `
            <div style="display: grid; grid-template-columns: ${this.isLandscape ? 'repeat(3, 1fr)' : 'repeat(3, 1fr)'}; gap: 10px; grid-auto-rows: minmax(${this.calculateSquareSize(3)}px, 1fr); align-content: start; min-height: 100%;">
              ${gridItems.join('')}
            </div>
          `;
        }

        getComparisonModalHTML(photo) {
          if (this.isLandscape) {
            // Landscape mode - left (before photo) and right (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Camera -->
                <div id="camera-container" style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                  
                  <!-- Close button -->
                  <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 99999; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                    ‚úï
                  </button>
                </div>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Camera -->
                <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: cover;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                    <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                  </div>
                  
                </div>
                
                <!-- Close button -->
                <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 9999; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room) {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row; background: white;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - After photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; background: white;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - After photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getAppHTML() {
          return `
            <div style="min-height: 100vh; background: #f8fafc; font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif; display: flex; flex-direction: column; overflow-x: hidden;">
              <!-- Fixed Header -->
              <div style="position: fixed; top: 0; left: 0; right: 0; z-index: 200; background: #F2C31B; color: #303030; padding: 4px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; max-width: 100vw; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <!-- Location dropdown -->
                <select id="location-select" style="background: white; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 14px; font-weight: bold; max-width: 120px;">
                  <option value="tampa">Tampa</option>
                  <option value="st-petersburg">St. Petersburg</option>
                  <option value="jacksonville">Jacksonville</option>
                  <option value="miami">Miami</option>
                </select>

                <!-- Cleaner name -->
                <div style="font-size: 16px; font-weight: bold;">Kate</div>

                <!-- Action buttons -->
                <div style="display: flex; gap: 8px; align-items: center;">
                  <button id="all-photos-btn" style="background: white; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold;">
                    üì∑ All Photos
                  </button>
                <button id="header-upload-btn" style="background: #303030; color: #F2C31B; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold;">
                  üì§ Upload
                </button>
                </div>
              </div>

              <!-- Fixed Room Tabs (at bottom) -->
              <div id="sticky-tabs-container" style="position: fixed; ${this.isLandscape ? 'bottom: 0; left: 0; right: 0; z-index: 100; background: #f8fafc; padding: 10px; width: 100vw; box-sizing: border-box; display: flex; justify-content: center; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);' : 'bottom: 0; left: 0; right: 0; z-index: 100; background: #f8fafc; padding: 10px; width: 100vw; box-sizing: border-box; display: flex; justify-content: center; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);'}">
                <div id="room-tabs-container" style="position: relative; ${this.isLandscape ? 'width: 100vw; height: 60px;' : 'width: 100vw; height: 60px;'} overflow: hidden;">
                  <div id="tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                    ${this.getRoomTabsCarousel()}
                  </div>
                </div>
              </div>
              
              <!-- Scrollable Content -->
              <div id="main-scrollable-content" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 60px 10px 95px 10px; width: 100%; max-width: 100vw; box-sizing: border-box;">
                
                <!-- Photos grid with swipe -->
                <div id="photos-container" style="display: grid; grid-template-columns: ${this.isLandscape ? 'repeat(5, 1fr)' : 'repeat(2, 1fr)'}; gap: 5px; padding: 0 10px; max-width: 100%; box-sizing: border-box;">
                  ${this.getPhotosHTML()}
                </div>
                
              </div>
              
              <!-- Fixed Action Buttons Panel (only for camera modals) -->
              <div id="bottom-panel" style="position: fixed; ${this.isLandscape ? 'right: 0; top: 0; bottom: 0; width: 80px; display: none; flex-direction: column; justify-content: center; align-items: center; gap: 20px; padding-top: 40px; padding-bottom: 40px;' : 'bottom: 0; left: 0; right: 0; display: none; grid-template-columns: 1fr 1fr 1fr; height: 80px; align-items: center;'} z-index: 2001; background: white; box-shadow: ${this.isLandscape ? '0 0 8px rgba(0,0,0,0.1)' : '0 -2px 8px rgba(0,0,0,0.1)'};">
                <!-- Left Section - Retake Button (hidden by default) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-retake" style="background: #ef4444; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üîÑ Retake
                  </button>
                </div>

                <!-- Center Section - Camera Button (hidden by default for gallery, shown during photo capture) -->
                <div style="display: flex; justify-content: center;">
                  <button id="camera-btn" style="background: #F2C31B; border: none; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; box-shadow: 0 4px 12px rgba(48,48,48,0.3); display: none;"></button>
                </div>

                <!-- Right Section - Save Button (hidden by default) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-save" style="background: #10b981; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üíæ Save
                  </button>
                </div>
              </div>
              
            </div>
          `;
        }
        
        
        
        getRoomTabsCarousel() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          const currentIndex = rooms.indexOf(this.currentRoom);

          // Create extended array for infinite loop effect (3x the original)
          const extendedRooms = [...rooms, ...rooms, ...rooms];
          const centerIndex = rooms.length + currentIndex; // Middle set + current position

          return extendedRooms.map((room, index) => {
            const relativePosition = index - centerIndex;
            const distance = Math.abs(relativePosition);

            // Only show tabs that are close to center (within 2 positions)
            if (distance > 2) {
              return '';
            }

            // Calculate positioning with smaller gaps
            const isActive = relativePosition === 0;
            const translateX = relativePosition * 80; // Reduced from 120px to 80px
            const opacity = distance === 0 ? 1 : Math.max(0.5, 1 - (distance * 0.25));
            const scale = distance === 0 ? 1.1 : Math.max(0.85, 1 - (distance * 0.08));

            return `
              <button class="room-tab" data-room="${room}" data-position="${relativePosition}"
                      style="position: absolute;
                             left: 50%;
                             top: 50%;
                             transform: translate(-50%, -50%) translateX(${translateX}px) scale(${scale});
                             padding: 10px 14px;
                             border: none;
                             border-radius: 12px;
                             font-size: ${isActive ? '15px' : '13px'};
                             cursor: pointer;
                             background: ${isActive ? '#F2C31B' : 'rgba(225,225,225,0.9)'};
                             color: ${isActive ? '#303030' : '#666'};
                             transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                             opacity: ${opacity};
                             white-space: nowrap;
                             z-index: ${10 - distance};
                             font-weight: ${isActive ? '600' : '400'};
                             box-shadow: ${isActive ? '0 4px 12px rgba(242,195,27,0.3)' : '0 2px 4px rgba(0,0,0,0.1)'};
                             letter-spacing: ${isActive ? '0.5px' : '0px'};">
                ${room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ')}
              </button>
            `;
          }).filter(tab => tab !== '').join('');
        }
        
        getAllPhotosHTML() {
          
          // Room icons for display
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Debug: Check all photos first

          // Get all stored photos (before, after, and combined/mix photos)
          const allPhotos = this.photos
            .filter(photo => {
              // Include before photos
              if (photo.mode === 'before') return true;
              
              // Include after photos
              if (photo.mode === 'after') return true;
              
              // Include archived photos
              if (photo.mode === 'archived') return true;
              
              // Include mix/combined photos
              if (photo.mode === 'mix') return true;
              
              return false;
            });


          // Group photos by room and organize them: before, after, combined
          // Handle multiple photos of the same type by grouping them by name/sequence
          const photosByRoomAndName = {};
          allPhotos.forEach(photo => {
            if (!photosByRoomAndName[photo.room]) {
              photosByRoomAndName[photo.room] = {};
            }
            
            // For combined photos with long names, try to match them to the correct before/after set
            let photoKey = photo.name;
            
            if (photo.mode === 'mix' && photo.name.includes('_Combined_')) {
              // Try to find matching before/after photos by timestamp proximity
              const beforePhotos = allPhotos.filter(p => p.mode === 'before' && p.room === photo.room);
              const afterPhotos = allPhotos.filter(p => p.mode === 'after' && p.room === photo.room);
              
              // Find the closest timestamp match
              let closestMatch = null;
              let minTimeDiff = Infinity;
              
              [...beforePhotos, ...afterPhotos].forEach(matchPhoto => {
                const timeDiff = Math.abs(photo.timestamp - matchPhoto.timestamp);
                if (timeDiff < minTimeDiff && timeDiff < 60000) { // Within 1 minute
                  minTimeDiff = timeDiff;
                  closestMatch = matchPhoto;
                }
              });
              
              if (closestMatch) {
                photoKey = closestMatch.name; // Use the matched photo's name
              }
            }
            
            if (!photosByRoomAndName[photo.room][photoKey]) {
              photosByRoomAndName[photo.room][photoKey] = {
                before: null,
                after: null,
                combined: null
              };
            }
            
            if (photo.mode === 'before' || photo.mode === 'archived') {
              photosByRoomAndName[photo.room][photoKey].before = photo;
            } else if (photo.mode === 'after') {
              photosByRoomAndName[photo.room][photoKey].after = photo;
            } else if (photo.mode === 'mix') {
              photosByRoomAndName[photo.room][photoKey].combined = photo;
            }
          });

          // Create ordered array: before, after, combined for each room and photo set
          // Sort photo sets by name to ensure consistent ordering (Kitchen 1, Kitchen 2, Kitchen 3)
          const orderedPhotos = [];
          Object.keys(photosByRoomAndName).forEach(room => {
            const roomPhotoSets = photosByRoomAndName[room];
            const sortedPhotoSetNames = Object.keys(roomPhotoSets).sort((a, b) => {
              // Extract numbers from names for proper sorting
              const aNum = parseInt(a.replace(/\D/g, '')) || 0;
              const bNum = parseInt(b.replace(/\D/g, '')) || 0;
              return aNum - bNum;
            });
            
            sortedPhotoSetNames.forEach(photoSetName => {
              const photoSet = roomPhotoSets[photoSetName];
              
              // Add before photo (or dummy if missing)
              if (photoSet.before) {
                orderedPhotos.push(photoSet.before);
              } else {
                orderedPhotos.push({ 
                  id: `dummy-before-${photoSetName}`, 
                  mode: 'dummy-before', 
                  room: room, 
                  name: photoSetName,
                  isDummy: true 
                });
              }
              
              // Add after photo (or dummy if missing)
              if (photoSet.after) {
                orderedPhotos.push(photoSet.after);
              } else {
                orderedPhotos.push({ 
                  id: `dummy-after-${photoSetName}`, 
                  mode: 'dummy-after', 
                  room: room, 
                  name: photoSetName,
                  isDummy: true 
                });
              }
              
              // Add combined photo (or dummy if missing)
              if (photoSet.combined) {
                orderedPhotos.push(photoSet.combined);
              } else {
                orderedPhotos.push({ 
                  id: `dummy-combined-${photoSetName}`, 
                  mode: 'dummy-combined', 
                  room: room, 
                  name: photoSetName,
                  isDummy: true 
                });
              }
            });
          });



          if (orderedPhotos.length === 0) {
            return `
              <div style="text-align: center; padding: 40px 20px; color: #666;">
                <div style="font-size: 48px; margin-bottom: 20px;">üì∑</div>
                <h3 style="margin: 0 0 10px 0; color: #303030;">No Photos Yet</h3>
                <p style="margin: 0; font-size: 14px;">Take some photos to see them here!</p>
              </div>
            `;
          }

          // Group photos by room for better organization
          const photosByRoom = {};
          orderedPhotos.forEach(photo => {
            if (!photosByRoom[photo.room]) {
              photosByRoom[photo.room] = [];
            }
            photosByRoom[photo.room].push(photo);
          });


          let html = '';
          
          // Display photos grouped by room
          Object.keys(photosByRoom).forEach(room => {
            const roomPhotos = photosByRoom[room];
            const actualPhotos = roomPhotos.filter(p => !p.isDummy); // Count only real photos
            const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
            const roomIcon = roomIcons[room] || 'üè†';
            
            
            html += `
              <div style="margin-bottom: 30px;">
                <h3 style="margin: 0 0 15px 0; padding: 0 10px; color: #303030; font-size: 18px; display: flex; align-items: center; justify-content: space-between;">
                  <span style="display: flex; align-items: center; gap: 8px;">${roomIcon} ${roomName} (${actualPhotos.length})</span>
                  <span style="font-size: 12px; color: #666; font-weight: normal;">
                    ${roomPhotos.length > 0 ? new Date(roomPhotos[0].timestamp).toLocaleDateString() : ''}
                  </span>
                </h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 0 10px;">
                  <div style="text-align: center; font-size: 12px; font-weight: bold; color: #F2C31B; padding: 5px;">BEFORE</div>
                  <div style="text-align: center; font-size: 12px; font-weight: bold; color: #3B82F6; padding: 5px;">AFTER</div>
                  <div style="text-align: center; font-size: 12px; font-weight: bold; color: #10B981; padding: 5px;">COMBINED</div>
            `;
            
            roomPhotos.forEach((photo, index) => {
              // For combined photos with long names, use the photo set name instead
              let displayName = photo.name || `${room} ${index + 1}`;
              
              if (photo.mode === 'mix' && photo.name.includes('_Combined_')) {
                // Extract the base name from the current photo set
                const currentPhotoSetName = roomPhotos.find(p => p.mode === 'before')?.name || 
                                          roomPhotos.find(p => p.mode === 'after')?.name;
                if (currentPhotoSetName) {
                  displayName = currentPhotoSetName;
                }
              }
              
              const photoIndex = photo.isDummy ? -1 : this.photos.indexOf(photo);
              
              // Handle dummy photos
              if (photo.isDummy) {
                let borderColor = '#E1E1E1';
                let photoLabel = '';
                let icon = 'üì∑';
                
                if (photo.mode === 'dummy-before') {
                  borderColor = '#F2C31B';
                  icon = 'üì∏';
                } else if (photo.mode === 'dummy-after') {
                  borderColor = '#3B82F6';
                  icon = 'üì∑';
                } else if (photo.mode === 'dummy-combined') {
                  borderColor = '#10B981';
                  icon = 'üîÑ';
                }
                
                html += `
                  <div class="dummy-card" data-room="${photo.room}" data-name="${photo.name}" data-mode="${photo.mode}" style="border: 2px dashed ${borderColor}; border-radius: 8px; overflow: hidden; position: relative; aspect-ratio: 1; background: #f8f9fa; display: flex; align-items: center; justify-content: center; opacity: 0.6; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.opacity='0.8'; this.style.background='#e9ecef';" onmouseout="this.style.opacity='0.6'; this.style.background='#f8f9fa';">
                    <div style="text-align: center; color: #666;">
                      <div style="font-size: 24px; margin-bottom: 8px;">${icon}</div>
                      <div style="font-size: 8px; color: #999;">Click to add</div>
                    </div>
                  </div>
                `;
                return;
              }
              
              if (photo.mode === 'after') {
                // After photo - show with blue border
                const borderColor = '#3B82F6';
                
                html += `
                  <div class="photo-item" data-photo-index="${photoIndex}" style="border: 2px solid ${borderColor}; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1; cursor: pointer;">
                    <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                    
                    <!-- Photo info -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 5px 8px; font-size: 10px;">
                      <div style="font-weight: bold;">${displayName}</div>
                    </div>
                  </div>
                `;
              } else {
                // Single photo (before, archived, or mix/combined)
                let borderColor = '#E1E1E1';
                let photoLabel = '';
                
                if (photo.mode === 'before') {
                  borderColor = '#F2C31B';
                } else if (photo.mode === 'mix') {
                  borderColor = '#10B981';
                } else if (photo.mode === 'archived') {
                  borderColor = '#6B7280';
                }
                
                html += `
                  <div class="photo-item" data-photo-index="${photoIndex}" style="border: 2px solid ${borderColor}; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1; cursor: pointer;">
                    <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                    
                    <!-- Photo info -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 5px 8px; font-size: 10px;">
                      <div style="font-weight: bold;">${displayName}</div>
                    </div>
                  </div>
                `;
              }
            });
            
            html += `
                </div>
              </div>
            `;
          });

          return html;
        }
        
        showAllPhotosModal() {
          // Clean up any existing modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2500"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2500;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
          `;

          modal.innerHTML = `
            <div style="
              width: 100%;
              max-width: 500px;
              height: 90vh;
              background: white;
              border-radius: 12px;
              display: flex;
              flex-direction: column;
              overflow: hidden;
              box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            ">
              <!-- Header -->
              <div style="
                padding: 20px;
                background: #F2C31B;
                color: #303030;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-shrink: 0;
              ">
                <h2 style="margin: 0; font-size: 20px; font-weight: bold;">üì∑ All Photos</h2>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                  <button id="delete-all-photos-btn" style="
                    background: #dc2626;
                    color: white;
                    border: none;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    font-weight: bold;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    transition: background 0.2s;
                  " onmouseover="this.style.background='#b91c1c'" onmouseout="this.style.background='#dc2626'">
                    üóëÔ∏è Delete All
                  </button>
                  
                  <button id="close-all-photos-modal" style="
                    background: transparent;
                    border: none;
                    color: #303030;
                    font-size: 24px;
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 50%;
                    width: 35px;
                    height: 35px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                  ">√ó</button>
                </div>
              </div>
              
              <!-- Scrollable content -->
              <div id="all-photos-content" style="
                flex: 1;
                overflow-y: auto;
                padding: 20px;
                background: #f8f9fa;
              ">
                ${this.getAllPhotosHTML()}
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Prevent background scrolling
          document.body.style.overflow = 'hidden';

          // Add event listeners
          document.getElementById('close-all-photos-modal').addEventListener('click', () => {
            this.closeAllPhotosModal(modal);
          });

          // Delete All button functionality
          document.getElementById('delete-all-photos-btn').addEventListener('click', () => {
            // Close the gallery modal first
            this.closeAllPhotosModal(modal);
            
            // Show the delete all confirmation (same as upload button)
            setTimeout(() => {
              this.showDeleteAllConfirmation();
            }, 100);
          });


          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              this.closeAllPhotosModal(modal);
            }
          });

          // Add photo click listeners for fullscreen view
          this.attachGalleryPhotoListeners(modal);
        }

        attachGalleryPhotoListeners(modal = null) {
          setTimeout(() => {
            // If no modal provided, try to find it
            if (!modal) {
              modal = document.querySelector('[style*="position: fixed"][style*="z-index: 2500"]');
            }
            
            if (!modal) return;
            
            const photoItems = modal.querySelectorAll('.photo-item');
            
            photoItems.forEach((item, index) => {
              // Remove any existing listeners by cloning the element
              const newItem = item.cloneNode(true);
              item.parentNode.replaceChild(newItem, item);
              
              newItem.addEventListener('click', (e) => {
                
                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                if (photoIndex >= 0 && photoIndex < this.photos.length) {
                  const photo = this.photos[photoIndex];
                  
                  // Close the all photos modal first
                  this.closeAllPhotosModal(modal);
                  
                  // Then show the photo with its specific functionality
                  setTimeout(() => {
                    this.showPhotoFullscreenFromModal(photo);
                  }, 100);
                } else {
                  console.error('getAllPhotosModal - Invalid photo index:', photoIndex);
                }
              });
            });
            
            // Add dummy card click handlers for camera functionality
            const dummyCards = modal.querySelectorAll('.dummy-card');
            dummyCards.forEach((card) => {
              // Remove any existing listeners by cloning the element
              const newCard = card.cloneNode(true);
              card.parentNode.replaceChild(newCard, card);
              
              newCard.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                const name = e.currentTarget.dataset.name;
                const mode = e.currentTarget.dataset.mode;
                
                console.log('Dummy card clicked:', { room, name, mode });
                
                // Close the all photos modal first
                this.closeAllPhotosModal(modal);
                
                // Open camera based on the dummy type
                setTimeout(() => {
                  if (mode === 'dummy-before') {
                    this.openCameraFromGallery(room, name, 'before');
                  } else if (mode === 'dummy-after') {
                    this.openCameraFromGallery(room, name, 'after');
                  }
                  // Note: dummy-combined cards don't need camera functionality
                  // as combined photos are auto-generated when both before/after exist
                }, 100);
              });
            });
          }, 100);
        }

        closeAllPhotosModal(modal) {
          if (modal && modal.parentNode) {
            document.body.removeChild(modal);
          }
          // Restore background scrolling
          document.body.style.overflow = '';
        }

        openCameraFromGallery(room, name, mode) {
          console.log('Opening camera from gallery:', { room, name, mode });
          
          // Set up context for gallery return
          this.galleryReturnContext = {
            returnToGallery: true,
            room: room,
            name: name,
            mode: mode
          };
          
          // Set the current room and mode
          this.currentRoom = room;
          
          if (mode === 'before') {
            // Set specific photo name for before photo
            this.pendingPhotoName = name;
            this.openCamera('before');
          } else if (mode === 'after') {
            // Find the corresponding before photo to open comparison camera
            const beforePhoto = this.photos.find(p => 
              p.room === room && 
              p.name === name && 
              p.mode === 'before'
            );
            
            if (beforePhoto) {
              // Set the before photo reference for the comparison camera
              this.currentBeforePhoto = beforePhoto;
              this.pendingPhotoName = name;
              
              // Open the comparison camera view (after mode) with the before photo
              this.showPhotoFullscreen(beforePhoto);
            } else {
              console.error('Cannot take after photo without corresponding before photo');
              // Return to gallery if error
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 100);
            }
          }
        }

        async showPhotoFullscreenFromModal(photo) {
          // For gallery view, always show enlarged photo without camera functionality
          this.showPhotoEnlarged(photo);
        }

        async showPhotoEnlarged(photo) {
          // Always show enlarged view regardless of photo mode - no camera functionality
          // Clean up any existing photo fullscreen modals first
          const existingPhotoModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingPhotoModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;

          // Use the same template as the regular fullscreen but without camera functionality
          const orientation = this.detectPhotoOrientation(photo.naturalWidth || 800, photo.naturalHeight || 600);
          const templateType = photo.templateType || 'default';
          
          // Use the same HTML structure as the regular fullscreen
          modal.innerHTML = this.getEnlargedPhotoHTML(photo, orientation, templateType);
          
          document.body.appendChild(modal);
          document.body.style.overflow = 'hidden';

          // Set up the same functionality as regular fullscreen
          this.setupEnlargedPhotoListeners(modal, photo);
        }

        getEnlargedPhotoHTML(photo, orientation, templateType) {
          return `
            <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; overflow: auto; background: rgba(0,0,0,0.95); padding-top: 80px; padding-bottom: 120px; box-sizing: border-box;">
              <!-- Scrollable container for actual size viewing -->
              <div id="photo-container" style="position: relative; display: flex; align-items: center; justify-content: center; max-width: 95vw; max-height: calc(100vh - 200px); overflow: auto;">
                <img id="fullscreen-photo" src="${photo.dataUrl}" style="display: block; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);" />
              </div>
              
              <!-- Photo info overlay -->
              <div style="position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; backdrop-filter: blur(10px); z-index: 10;">
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  ${new Date(photo.timestamp).toLocaleString()}
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Orientation: ${orientation} | Template: ${templateType}
                </div>
              </div>
              
              ${this.getTemplateSelector(photo, templateType)}
              
              <!-- Close button -->
              <button id="close-photo-btn" style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; backdrop-filter: blur(10px); z-index: 10;">
                ‚úï
              </button>
            </div>
          `;
        }

        getTemplateSelector(photo, templateType) {
          // Show template selector for all photos when in enlarged view, not just combined
          return `
            <!-- Template selector for photos (larger icons, 2 rows) -->
            <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); z-index: 10; box-shadow: 0 4px 16px rgba(0,0,0,0.4);">
              <!-- First row: Default and Landscape -->
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px;">
                <!-- Default 4:3 -->
                <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 12px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'default' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'default' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'default' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                  <input type="radio" name="template-selector" value="default" style="display: none;" ${templateType === 'default' ? 'checked' : ''}>
                  <div style="width: 32px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-size: 8px; color: #303030; font-weight: bold;">4:3</div>
                  </div>
                  <div style="font-size: 11px; font-weight: bold; text-align: center;">Default</div>
                  <div style="font-size: 9px; opacity: 0.8; text-align: center;">Standard</div>
                </label>

                <!-- Landscape 16:9 -->
                <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 12px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'landscape' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                  <input type="radio" name="template-selector" value="landscape" style="display: none;" ${templateType === 'landscape' ? 'checked' : ''}>
                  <div style="width: 40px; height: 22px; background: #F2C31B; border-radius: 2px; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-size: 8px; color: #303030; font-weight: bold;">16:9</div>
                  </div>
                  <div style="font-size: 11px; font-weight: bold; text-align: center;">Landscape</div>
                  <div style="font-size: 9px; opacity: 0.8; text-align: center;">YouTube</div>
                </label>
              </div>

              <!-- Second row: Square, Portrait, Blog -->
              <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                <!-- Square 1:1 -->
                <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'square' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'square' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'square' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                  <input type="radio" name="template-selector" value="square" style="display: none;" ${templateType === 'square' ? 'checked' : ''}>
                  <div style="width: 24px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-size: 7px; color: #303030; font-weight: bold;">1:1</div>
                  </div>
                  <div style="font-size: 10px; font-weight: bold; text-align: center;">Square</div>
                  <div style="font-size: 8px; opacity: 0.8; text-align: center;">Instagram</div>
                </label>

                <!-- Portrait 4:5 -->
                <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'portrait' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                  <input type="radio" name="template-selector" value="portrait" style="display: none;" ${templateType === 'portrait' ? 'checked' : ''}>
                  <div style="width: 19px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-size: 7px; color: #303030; font-weight: bold;">4:5</div>
                  </div>
                  <div style="font-size: 10px; font-weight: bold; text-align: center;">Portrait</div>
                  <div style="font-size: 8px; opacity: 0.8; text-align: center;">LinkedIn</div>
                </label>

                <!-- Blog 3:2 -->
                <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'blog' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                  <input type="radio" name="template-selector" value="blog" style="display: none;" ${templateType === 'blog' ? 'checked' : ''}>
                  <div style="width: 28px; height: 19px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <div style="font-size: 7px; color: #303030; font-weight: bold;">3:2</div>
                  </div>
                  <div style="font-size: 10px; font-weight: bold; text-align: center;">Blog</div>
                  <div style="font-size: 8px; opacity: 0.8; text-align: center;">Articles</div>
                </label>
              </div>

            </div>
          `;
        }

        setupEnlargedPhotoListeners(modal, photo) {
          // Set default to fit screen mode
          const imgElement = modal.querySelector('#fullscreen-photo');
          const imgContainer = modal.querySelector('#photo-container');
          
          // Configure for fit-to-screen display
          imgElement.style.maxWidth = '100%';
          imgElement.style.maxHeight = '100%';
          imgElement.style.width = 'auto';
          imgElement.style.height = 'auto';
          imgContainer.style.maxWidth = '95vw';
          imgContainer.style.maxHeight = '95vh';
          imgContainer.style.overflow = 'hidden';

          // Template selector functionality (generate on-demand)
          const templateRadios = modal.querySelectorAll('input[name="template-selector"]');
          templateRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
              if (e.target.checked) {
                const newTemplate = e.target.value;
                console.log('Generating template on-demand:', newTemplate);
                
                // Update visual selection state
                this.updateTemplateVisualSelection(modal, newTemplate);
                
                // Show loading state
                const imgElement = modal.querySelector('#fullscreen-photo');
                if (imgElement) {
                  imgElement.style.opacity = '0.5';
                }
                
                // Handle template change based on photo type
                if (photo.mode === 'mix') {
                  // For combined photos, regenerate with new template
                  this.generateCombinedPhotoOnDemand(photo, newTemplate, modal);
                } else {
                  // For individual photos, crop the single photo to the selected template
                  this.cropIndividualPhotoOnDemand(photo, newTemplate, modal);
                }
              }
            });
          });

          document.getElementById('close-photo-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
            
            // Reopen the All Photos modal
            setTimeout(() => {
              this.showAllPhotosModal();
            }, 100);
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
              
              // Reopen the All Photos modal
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 100);
            }
          });
        }

        regenerateFromIndividualPhoto(photo, newTemplate, modal) {
          console.log('Regenerating from individual photo:', photo.mode, 'with template:', newTemplate);
          
          if (photo.mode === 'before') {
            // Find the corresponding after photo
            const afterPhoto = this.photos.find(p => 
              p.mode === 'after' && p.beforePhotoId === photo.id
            );
            
            if (afterPhoto) {
              // Find and remove existing combined photo
              const existingCombined = this.photos.find(p => 
                p.mode === 'mix' && p.room === photo.room && p.name === photo.name
              );
              if (existingCombined) {
                const combinedIndex = this.photos.findIndex(p => p.id === existingCombined.id);
                if (combinedIndex !== -1) {
                  this.photos.splice(combinedIndex, 1);
                }
              }
              
              // Create new combined photo with selected template
              this.createCombinedPhotoWithCallback(
                photo.dataUrl,
                afterPhoto.dataUrl,
                photo.room,
                photo.name,
                newTemplate,
                (createdPhoto) => {
                  // Show the newly created combined photo
                  this.updateModalWithNewPhoto(modal, createdPhoto);
                }
              );
            } else {
              // No after photo, just reset loading state
              const imgElement = modal.querySelector('#fullscreen-photo');
              if (imgElement) {
                imgElement.style.opacity = '1';
              }
            }
          } else if (photo.mode === 'after') {
            // Find the corresponding before photo
            const beforePhoto = this.photos.find(p => 
              p.mode === 'before' && p.id === photo.beforePhotoId
            );
            
            if (beforePhoto) {
              // Find and remove existing combined photo
              const existingCombined = this.photos.find(p => 
                p.mode === 'mix' && p.room === photo.room && p.name === photo.name
              );
              if (existingCombined) {
                const combinedIndex = this.photos.findIndex(p => p.id === existingCombined.id);
                if (combinedIndex !== -1) {
                  this.photos.splice(combinedIndex, 1);
                }
              }
              
              // Create new combined photo with selected template
              this.createCombinedPhotoWithCallback(
                beforePhoto.dataUrl,
                photo.dataUrl,
                photo.room,
                photo.name,
                newTemplate,
                (createdPhoto) => {
                  // Show the newly created combined photo
                  this.updateModalWithNewPhoto(modal, createdPhoto);
                }
              );
            } else {
              // No before photo, just reset loading state
              const imgElement = modal.querySelector('#fullscreen-photo');
              if (imgElement) {
                imgElement.style.opacity = '1';
              }
            }
          }
        }

        updateModalWithNewPhoto(modal, newPhoto) {
          // Update the modal to show the newly created combined photo
          const imgElement = modal.querySelector('#fullscreen-photo');
          if (imgElement) {
            imgElement.src = newPhoto.dataUrl;
            imgElement.style.opacity = '1';
          }
          
          // Update photo info
          const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
          if (infoDiv) {
            const orientation = this.detectPhotoOrientation(newPhoto.naturalWidth || 800, newPhoto.naturalHeight || 600);
            infoDiv.innerHTML = `
              <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                ${newPhoto.room.charAt(0).toUpperCase() + newPhoto.room.slice(1).replace('-', ' ')} - ${newPhoto.mode.charAt(0).toUpperCase() + newPhoto.mode.slice(1)}
              </div>
              <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                ${new Date(newPhoto.timestamp).toLocaleString()}
              </div>
              <div style="font-size: 12px; opacity: 0.7;">
                Orientation: ${orientation} | Template: ${newPhoto.templateType}
              </div>
            `;
          }
          
          // Update main photos container
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }
          
          // Update gallery modal if it's open
          const allPhotosContent = document.getElementById('all-photos-content');
          if (allPhotosContent) {
            allPhotosContent.innerHTML = this.getAllPhotosHTML();
            this.attachGalleryPhotoListeners();
          }
          
          // Save updated photos
          this.savePhotos();
          
          console.log('Modal updated with new photo:', newPhoto.templateType);
        }

        generateCombinedPhotoOnDemand(photo, templateType, modal) {
          console.log('Generating combined photo on-demand:', templateType);
          
          // Find the before and after photos
          let beforePhoto, afterPhoto;
          
          if (photo.mode === 'before') {
            beforePhoto = photo;
            afterPhoto = this.photos.find(p => p.mode === 'after' && p.beforePhotoId === photo.id);
          } else if (photo.mode === 'after') {
            afterPhoto = photo;
            beforePhoto = this.photos.find(p => p.mode === 'before' && p.id === photo.beforePhotoId);
          } else if (photo.mode === 'mix') {
            // For temporary combined photos, use the embedded references
            if (photo.beforePhoto && photo.afterPhoto) {
              beforePhoto = photo.beforePhoto;
              afterPhoto = photo.afterPhoto;
            } else {
              // Fallback: find the original pair
              beforePhoto = this.photos.find(p => p.mode === 'before' && p.room === photo.room && p.name === photo.name);
              afterPhoto = this.photos.find(p => p.mode === 'after' && p.room === photo.room && p.name === photo.name);
            }
          }
          
          if (!beforePhoto || !afterPhoto) {
            console.error('Cannot find before/after pair for on-demand generation');
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.style.opacity = '1';
            }
            return;
          }
          
          // Generate combined photo without storing it
          this.createCombinedPhotoInMemory(beforePhoto.dataUrl, afterPhoto.dataUrl, templateType, (combinedDataUrl) => {
            // Update modal with generated photo
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.src = combinedDataUrl;
              imgElement.style.opacity = '1';
            }
            
            // Update photo info to show it's a generated combined photo
            const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
            if (infoDiv) {
              const orientation = this.detectPhotoOrientation(beforePhoto.width || 800, beforePhoto.height || 600);
              infoDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${beforePhoto.room.charAt(0).toUpperCase() + beforePhoto.room.slice(1).replace('-', ' ')} - Combined (${templateType})
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  Generated on-demand
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Template: ${templateType} | Not stored locally
                </div>
              `;
            }
            
            // Update the current photo object's template type for future reference
            photo.templateType = templateType;
          });
        }

        createCombinedPhotoInMemory(beforeDataUrl, afterDataUrl, templateType, callback) {
          console.log('Creating combined photo in memory for template:', templateType);
          
          // Create image objects to get dimensions
          const beforeImg = new Image();
          const afterImg = new Image();
          
          let imagesLoaded = 0;
          const totalImages = 2;
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // Calculate template dimensions
              const templateDimensions = this.calculateTemplateDimensions(
                { width: beforeImg.width, height: beforeImg.height },
                { width: afterImg.width, height: afterImg.height },
                templateType
              );

              // Create canvas
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              
              canvas.width = templateDimensions.targetWidth;
              canvas.height = templateDimensions.targetHeight;
              
              // Fill white background
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              
              // Apply cropping and positioning
              ctx.save();
              ctx.beginPath();
              ctx.rect(0, 0, canvas.width, canvas.height);
              ctx.clip();
              
              if (templateDimensions.splitType === 'vertical') {
                this.drawVerticalSplit(ctx, beforeImg, afterImg, templateDimensions);
              } else {
                this.drawHorizontalSplit(ctx, beforeImg, afterImg, templateDimensions);
              }
              
              ctx.restore();
              
              // Add labels
              this.addPhotoLabels(ctx, canvas.width, canvas.height, templateDimensions.splitType);
              
              // Convert to data URL and return via callback
              const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
              callback(combinedDataUrl);
            }
          };
          
          // Load images
          beforeImg.onload = onImageLoad;
          afterImg.onload = onImageLoad;
          beforeImg.src = beforeDataUrl;
          afterImg.src = afterDataUrl;
        }

        updateTemplateVisualSelection(modal, selectedTemplate) {
          // Update the visual state of all template labels
          const templateLabels = modal.querySelectorAll('label');
          templateLabels.forEach(label => {
            const radio = label.querySelector('input[name="template-selector"]');
            if (radio) {
              const templateValue = radio.value;
              
              if (templateValue === selectedTemplate) {
                // Selected state - golden border and background
                label.style.border = '2px solid #F2C31B';
                label.style.background = 'rgba(242, 195, 27, 0.2)';
              } else {
                // Unselected state - transparent border and background
                label.style.border = '2px solid transparent';
                label.style.background = 'transparent';
              }
            }
          });
        }

        cropIndividualPhotoOnDemand(photo, templateType, modal) {
          console.log('Cropping individual photo on-demand:', photo.mode, 'to template:', templateType);
          
          // Create image object to get dimensions and crop
          const img = new Image();
          
          img.onload = () => {
            // Get template dimensions
            const templateSizes = this.getTemplateSizes();
            const targetTemplate = templateSizes[templateType] || templateSizes.default;
            
            // Detect photo orientation
            const orientation = this.detectPhotoOrientation(img.width, img.height);
            
            // Calculate crop dimensions for this individual photo
            const cropDimensions = this.calculatePhotoCropDimensions(
              img.width, img.height, templateType, orientation
            );
            
            // Create canvas with target template size
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = targetTemplate.width;
            canvas.height = targetTemplate.height;
            
            // Fill white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate how to fit the cropped photo into the template canvas
            const cropAspectRatio = cropDimensions.cropWidth / cropDimensions.cropHeight;
            const templateAspectRatio = targetTemplate.width / targetTemplate.height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (cropAspectRatio > templateAspectRatio) {
              // Crop is wider, fit to height
              drawHeight = targetTemplate.height;
              drawWidth = drawHeight * cropAspectRatio;
              drawX = (targetTemplate.width - drawWidth) / 2;
              drawY = 0;
            } else {
              // Crop is taller, fit to width
              drawWidth = targetTemplate.width;
              drawHeight = drawWidth / cropAspectRatio;
              drawX = 0;
              drawY = (targetTemplate.height - drawHeight) / 2;
            }
            
            // Draw the cropped photo
            ctx.drawImage(
              img,
              cropDimensions.cropX, cropDimensions.cropY, 
              cropDimensions.cropWidth, cropDimensions.cropHeight,
              drawX, drawY, drawWidth, drawHeight
            );
            
            // Add photo type label
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            
            const labelWidth = 120;
            const labelHeight = 30;
            const labelX = (canvas.width - labelWidth) / 2;
            const labelY = 20;
            
            ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(photo.mode.toUpperCase(), canvas.width / 2, labelY + 20);
            
            // Convert to data URL and update modal
            const croppedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
            
            // Update modal with cropped photo
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.src = croppedDataUrl;
              imgElement.style.opacity = '1';
            }
            
            // Update photo info
            const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
            if (infoDiv) {
              infoDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  Cropped to ${templateType} format
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Template: ${templateType} | Generated on-demand | Orientation: ${orientation}
                </div>
              `;
            }
            
            console.log('Individual photo cropped to template:', templateType);
          };
          
          img.src = photo.dataUrl;
        }
        
        getPhotosHTML() {

          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for this room, sorted by timestamp (oldest first)
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp); // Oldest first


          // Create grid layout with all photos and dummy squares
          const gridItems = [];
          

          // Add all existing photos
          beforePhotos.forEach((beforePhoto, i) => {
            // Check if there's a corresponding after photo linked to this before photo
            const afterPhoto = this.photos.find(p =>
              p.room === this.currentRoom &&
              p.mode === 'after' &&
              p.beforePhotoId === beforePhoto.id
            );

            if (afterPhoto) {
              // Check if there's a stored combined photo
              const combinedPhoto = this.photos.find(p => 
                p.mode === 'mix' && p.room === beforePhoto.room && p.name === beforePhoto.name
              );
              
              if (combinedPhoto) {
                // Show stored combined photo
                const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

                gridItems.push(`
                  <div class="photo-item" data-photo-index="${this.photos.indexOf(combinedPhoto)}" style="border: 1px solid #E1E1E1; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1;">
                    <img src="${combinedPhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover; filter: blur(3px);" />

                    <!-- Retake button in center -->
                    <button class="retake-combined-btn" data-before-photo-id="${beforePhoto.id}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #F2C31B; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 10;">
                      üîÑ Retake
                    </button>

                    <!-- Transparent title overlay -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(0,0,0,0.7));">
                      <div style="color: white; font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${displayName}</div>
                      <div style="color: rgba(255,255,255,0.9); font-size: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                    </div>

                    <!-- Delete button -->
                    <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(combinedPhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                      üóëÔ∏è
                    </button>
                  </div>
                `);
              } else {
                // Show split-screen preview if no combined photo exists yet
                const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

                gridItems.push(`
                  <div class="photo-item combined-preview" data-before-photo-id="${beforePhoto.id}" data-after-photo-id="${afterPhoto.id}" style="border: 1px solid #10B981; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1; background: #f8f9fa;">
                    <!-- 1:1 Combined preview mask -->
                    <div style="height: 100%; display: flex; flex-direction: column; position: relative;">
                      <!-- Before photo (top half) -->
                      <div style="height: 50%; overflow: hidden; position: relative;">
                        <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                        <div style="position: absolute; top: 2px; left: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold;">BEFORE</div>
                      </div>
                      <!-- Divider line -->
                      <div style="height: 2px; background: #000;"></div>
                      <!-- After photo (bottom half) -->
                      <div style="height: 50%; overflow: hidden; position: relative;">
                        <img src="${afterPhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 4px; border-radius: 2px; font-size: 8px; font-weight: bold;">AFTER</div>
                      </div>
                    </div>

                    <!-- Preview indicator -->
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(16, 185, 129, 0.9); color: white; padding: 6px 10px; border-radius: 6px; font-size: 11px; font-weight: bold; z-index: 10; backdrop-filter: blur(5px);">
                      üìê Preview
                    </div>

                    <!-- Retake button -->
                    <button class="retake-combined-btn" data-before-photo-id="${beforePhoto.id}" style="position: absolute; top: 8px; left: 8px; background: #F2C31B; color: #303030; border: none; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: bold; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10;">
                      üîÑ
                    </button>

                    <!-- Transparent title overlay -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(0,0,0,0.7));">
                      <div style="color: white; font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${displayName}</div>
                      <div style="color: rgba(255,255,255,0.9); font-size: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                    </div>

                    <!-- Delete button -->
                    <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(afterPhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                      üóëÔ∏è
                    </button>
                  </div>
                `);
              }
            } else {
              // Show only before photo
              const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

              gridItems.push(`
                <div class="photo-item" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="border: 3px solid #F2C31B; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s;">
                  <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 120px; object-fit: cover; cursor: pointer;" />
                  <div style="padding: 8px; font-size: 11px; color: #B3B3B3;">
                    <div style="font-weight: bold; margin-bottom: 2px; color: #303030;">${displayName}</div>
                    <div style="font-size: 10px; opacity: 0.8;">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                  </div>
                  <!-- Delete button -->
                  <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                    üóëÔ∏è
                  </button>
                </div>
              `);
            }
          });
          
          // Add one dummy square for taking more photos
          gridItems.push(`
            <div class="dummy-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; color: #999; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e8e8e8'; this.style.color='#666';" onmouseout="this.style.background='#f0f0f0'; this.style.color='#999';">
              ${roomIcons[this.currentRoom] || 'üì∑'}
            </div>
          `);

          return gridItems.join('');
        }
        
        getRoomPhotosByType(type) {
          const roomPhotos = this.photos.filter(photo => photo.room === this.currentRoom);
          console.log('getRoomPhotosByType - Type:', type, 'Current room:', this.currentRoom);
          console.log('getRoomPhotosByType - Room photos:', roomPhotos);
          
          if (type === 'photo') {
            const result = roomPhotos.filter(photo => photo.mode === 'before' || photo.mode === 'after');
            console.log('getRoomPhotosByType - Photo result:', result);
            return result;
          } else if (type === 'combined') {
            const result = roomPhotos.filter(photo => photo.mode === 'mix');
            console.log('getRoomPhotosByType - Combined result:', result);
            return result;
          } else if (type === 'all') {
            const result = roomPhotos.filter(photo => photo.mode === 'archived' || photo.mode === 'mix');
            console.log('getRoomPhotosByType - All result:', result);
            return result;
          }
          return roomPhotos;
        }
        
        getRoomFilteredPhotos() {
          // Always show photos by default, unless specifically viewing combined or all
          return this.getRoomPhotosByType(this.currentTab || 'photo');
        }
        
        addSwipeListeners() {
          // Only add listeners once
          if (this.swipeListenersAdded) return;
          this.swipeListenersAdded = true;
          
          // Ensure room order matches the visual tab order exactly
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          let startX = 0;
          let startY = 0;
          
          // Add touch events for swiping
          document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          });
          
          document.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const diffX = startX - endX;
            const diffY = startY - endY;
            
            // Only trigger swipe if horizontal movement is greater than vertical
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
              const currentIndex = rooms.indexOf(this.currentRoom);
              console.log('Swipe - Current room:', this.currentRoom, 'Index:', currentIndex);
              
              if (diffX > 0) {
                // Swipe left - next room (following tab order)
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
                console.log('Swipe left - Next room:', this.currentRoom, 'Index:', nextIndex);
              } else {
                // Swipe right - previous room (following tab order)
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
                console.log('Swipe right - Previous room:', this.currentRoom, 'Index:', prevIndex);
              }
              
              this.currentTab = 'photo';
              
              // Check if we're in a camera modal - if so, don't call init() to avoid regenerating the entire app
              const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
              
              if (isInCameraModal) {
                // Just update modal elements without regenerating the entire app
                setTimeout(() => {
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }, 100);
              } else {
                // Normal app update
                this.init();
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              }
            }
          });
          
          // Add keyboard support for cycling
          document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
              e.preventDefault();
              const currentIndex = rooms.indexOf(this.currentRoom);
              
              if (e.key === 'ArrowLeft') {
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
              } else {
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
              }
              
              this.currentTab = 'photo';
              
              // Check if we're in a camera modal - if so, don't call init() to avoid regenerating the entire app
              const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
              
              if (isInCameraModal) {
                // Just update modal elements without regenerating the entire app
                setTimeout(() => {
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }, 100);
              } else {
                // Normal app update
                this.init();
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              }
            }
          });
        }
        
        updateTabsCarousel() {
          // Just re-render the tabs - the carousel positioning is handled in getRoomTabsCarousel()
          const tabsCarousel = document.getElementById('tabs-carousel');
          if (tabsCarousel) {
            tabsCarousel.innerHTML = this.getRoomTabsCarousel();

            // Reattach event listeners after updating the DOM
            this.attachRoomTabListeners();
          }
        }

        attachRoomTabListeners() {

          // Room tabs click listeners - specifically for main gallery (not modal)
          const mainCarousel = document.getElementById('tabs-carousel');

          if (!mainCarousel) {
            const allElements = document.querySelectorAll('*[id*="tab"]');
            return;
          }

          const roomTabs = mainCarousel.querySelectorAll('.room-tab');

          roomTabs.forEach((btn, index) => {

            // Remove any existing listeners first
            btn.removeEventListener('click', this.roomTabClickHandler);

            // Add new listener
            btn.addEventListener('click', (e) => {
              console.log('üî• ROOM TAB CLICKED!', e.currentTarget.dataset.room);
              e.preventDefault();
              e.stopPropagation();

              // Get room from current target (the button) instead of target (might be inner element)
              const room = e.currentTarget.dataset.room;
              console.log('Room clicked:', room, 'Current room:', this.currentRoom);

              if (room && room !== this.currentRoom) {
                console.log('Switching from', this.currentRoom, 'to', room);
                this.currentRoom = room;
                this.currentTab = 'photo'; // Reset to photo tab when switching rooms

                // Update only the content area instead of full re-init
                const photosContainer = document.getElementById('photos-container');
                if (photosContainer) {
                  photosContainer.innerHTML = this.getPhotosHTML();
                  this.attachPhotoListeners();
                }

                // Update carousel and scroll
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
              } else {
                console.log('Same room clicked or invalid room');
              }
            });

            // Make sure buttons are interactive
            btn.style.pointerEvents = 'auto';
            btn.style.cursor = 'pointer';
            btn.style.backgroundColor = btn.style.backgroundColor || '#f0f0f0';

            // Add hover effect for testing
            btn.addEventListener('mouseenter', () => {
              console.log('üñ±Ô∏è Mouse entered room tab:', btn.dataset.room);
              btn.style.opacity = '0.8';
            });

            btn.addEventListener('mouseleave', () => {
              btn.style.opacity = '1';
            });

            // Add mousedown and mouseup for more testing
            btn.addEventListener('mousedown', () => {
              console.log('üñ±Ô∏è Mouse DOWN on room tab:', btn.dataset.room);
            });

            btn.addEventListener('mouseup', () => {
              console.log('üñ±Ô∏è Mouse UP on room tab:', btn.dataset.room);
            });

            // Check if element is being blocked
            btn.addEventListener('pointerdown', () => {
              console.log('üëÜ Pointer DOWN on room tab:', btn.dataset.room);
            });

          });

        }

        // Test function to manually check room tab functionality
        testRoomTabs() {
          const carousel = document.getElementById('tabs-carousel');
          console.log('Carousel found:', !!carousel);

          if (carousel) {
            const tabs = carousel.querySelectorAll('.room-tab');
            console.log('Tabs found:', tabs.length);

            tabs.forEach((tab, i) => {
              const rect = tab.getBoundingClientRect();
              const style = window.getComputedStyle(tab);
              console.log(`Tab ${i}:`, tab.dataset.room);
              console.log(`  Position:`, rect.x, rect.y, rect.width, rect.height);
              console.log(`  Z-index:`, style.zIndex);
              console.log(`  Pointer events:`, style.pointerEvents);

              // Check what element is actually at the center of the button
              const centerX = rect.x + rect.width / 2;
              const centerY = rect.y + rect.height / 2;
              const elementAtPoint = document.elementFromPoint(centerX, centerY);
              console.log(`  Element at center:`, elementAtPoint);
              console.log(`  Is the tab itself?`, elementAtPoint === tab);
            });

            // Try to click the first tab
            if (tabs.length > 0) {
              console.log('Simulating click on first tab...');
              tabs[0].click();
            }
          }
        }

        updateModalRoomTabs() {
          // Update room tabs in the modal
          const modalTabsCarousel = document.getElementById('modal-tabs-carousel');
          if (modalTabsCarousel) {
            modalTabsCarousel.innerHTML = this.getRoomTabsCarousel();
            console.log('Modal carousel updated for room:', this.currentRoom);

            // Reattach modal room tab listeners
            this.attachModalRoomTabListeners();
          }
        }

        attachModalRoomTabListeners() {
          // Room tab listeners specifically for the modal
          const modalCarousel = document.getElementById('modal-tabs-carousel');
          if (!modalCarousel) return;

          modalCarousel.querySelectorAll('.room-tab').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const room = e.currentTarget.dataset.room;
              if (room && room !== this.currentRoom) {
                this.currentRoom = room;
                this.updateModalRoomTabs();
                this.updateModalPhotoGrid();
              }
            });
          });
        }

        updateModalPhotoGrid() {
          // Update photo grid in the modal
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            // Store current scroll position and content height
            const previousScrollTop = beforePhotoGrid.scrollTop;
            const previousScrollHeight = beforePhotoGrid.scrollHeight;

            beforePhotoGrid.innerHTML = this.getBeforePhotosGridHTML();
            this.attachBeforePhotoListeners();

            // Smart scrolling to keep content visible above bottom panel
            setTimeout(() => {
              const currentScrollHeight = beforePhotoGrid.scrollHeight;
              const containerHeight = beforePhotoGrid.clientHeight;
              const bottomPanelHeight = 80; // Height of bottom panel

              // If content grew (new photos added), scroll up to accommodate
              if (currentScrollHeight > previousScrollHeight) {
                const heightDifference = currentScrollHeight - previousScrollHeight;

                // Calculate optimal scroll position to keep latest content visible
                // but not hidden behind bottom panel
                const maxVisibleScroll = currentScrollHeight - containerHeight + bottomPanelHeight;
                const newScrollTop = Math.min(previousScrollTop + heightDifference, maxVisibleScroll);

                beforePhotoGrid.scrollTop = Math.max(0, newScrollTop);
                console.log('üì∏ Auto-scrolled up to accommodate new photos');
              }
            }, 100);
          }
        }

        showActionButtons() {
          // Show retake and save buttons, hide camera button
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Show the bottom panel with appropriate layout
          if (bottomPanel) {
            bottomPanel.style.display = this.isLandscape ? 'flex' : 'grid';
          }

          if (retakeBtn) retakeBtn.style.display = 'flex';
          if (saveBtn) saveBtn.style.display = 'flex';
          if (cameraBtn) cameraBtn.style.display = 'none';
          
          // Adjust main content padding in landscape mode
          if (this.isLandscape) {
            this.adjustMainContentForRightPanel(true);
          }
          
          // Check if we're in after mode (comparison camera modal) and make bottom panel transparent
          if (bottomPanel) {
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');
            
            if (cameraModal && cameraModal.innerHTML.includes('comparison-camera')) {
              // After mode (comparison camera) - transparent panel
              bottomPanel.style.background = 'transparent';
              bottomPanel.style.boxShadow = 'none';
            } else {
              // Before mode - white panel to cover gallery
              bottomPanel.style.background = 'white';
              bottomPanel.style.boxShadow = 'none';
            }
          }
        }

        hideActionButtons() {
          // Hide retake and save buttons, keep camera button hidden for gallery
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Hide the entire bottom panel in gallery mode
          if (bottomPanel) bottomPanel.style.display = 'none';

          if (retakeBtn) retakeBtn.style.display = 'none';
          if (saveBtn) saveBtn.style.display = 'none';
          
          // Reset bottom panel styling to original
          if (bottomPanel) {
            bottomPanel.style.background = 'white';
            bottomPanel.style.boxShadow = '0 -2px 8px rgba(0,0,0,0.1)';
          }
          
          // Check if we're in a camera modal - if so, keep camera button visible
          const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                  document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                  document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
          if (cameraBtn) {
            if (isInCameraModal) {
              cameraBtn.style.display = 'block'; // Keep visible during camera modal
            } else {
              cameraBtn.style.display = 'none'; // Hide for gallery
            }
          }
        }

        showCameraButton() {
          // Show camera button during photo capture screens
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Show the bottom panel with appropriate layout
          if (bottomPanel) {
            bottomPanel.style.display = this.isLandscape ? 'flex' : 'grid';
          }
          
          if (cameraBtn) cameraBtn.style.display = 'block';
          
          // Adjust main content padding in landscape mode
          if (this.isLandscape) {
            this.adjustMainContentForRightPanel(true);
          }
          
          // Check if we're in a camera modal and apply appropriate styling
          if (bottomPanel && cameraBtn) {
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');
            
            if (cameraModal) {
              // Conditional styling based on camera mode
              if (cameraModal.innerHTML.includes('comparison-camera')) {
                // After mode (comparison camera) - transparent panel
                bottomPanel.style.background = 'transparent';
                bottomPanel.style.boxShadow = 'none';
              } else {
                // Before mode - white panel to cover gallery
                bottomPanel.style.background = 'white';
                bottomPanel.style.boxShadow = 'none';
              }

              // Make individual sections transparent
              const sections = bottomPanel.querySelectorAll('div');
              sections.forEach(section => {
                section.style.background = 'transparent';
              });
              
              cameraBtn.style.background = '#F2C31B';
              cameraBtn.style.border = '2px solid rgba(255,255,255,0.8)';
              cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
            } else {
              // Not in camera modal - keep panel transparent (room tabs are at bottom)
              bottomPanel.style.background = 'transparent';
              bottomPanel.style.boxShadow = 'none';
              cameraBtn.style.background = '#F2C31B';
              cameraBtn.style.border = 'none';
              cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
            }
          }
        }

        hideCameraButton() {
          // Hide camera button and reset styling
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Hide the entire bottom panel
          if (bottomPanel) bottomPanel.style.display = 'none';
          
          // Restore main content padding in landscape mode
          if (this.isLandscape) {
            this.adjustMainContentForRightPanel(false);
          }
          
          if (cameraBtn) {
            cameraBtn.style.display = 'none';
            // Reset camera button styling to original
            cameraBtn.style.background = '#F2C31B';
            cameraBtn.style.border = 'none';
            cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
          }
          
          // Keep bottom panel white when hidden (to cover any gallery content)
          if (bottomPanel) {
            bottomPanel.style.background = 'white';
            bottomPanel.style.boxShadow = 'none';

            // Reset individual sections to transparent (they sit on white background)
            const sections = bottomPanel.querySelectorAll('div');
            sections.forEach(section => {
              section.style.background = 'transparent';
            });
          }
        }

        adjustMainContentForRightPanel(show) {
          // Adjust main content padding when right panel is shown/hidden in landscape mode
          const mainContent = document.getElementById('main-scrollable-content');
          if (mainContent && this.isLandscape) {
            if (show) {
              mainContent.style.paddingRight = '90px'; // Account for 80px panel + 10px margin
            } else {
              mainContent.style.paddingRight = '10px'; // Restore original padding
            }
          }
        }

        updateGridsOnOrientationChange() {
          // Update main gallery grid
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            if (this.isLandscape) {
              photosContainer.style.gridTemplateColumns = 'repeat(5, 1fr)';
            } else {
              photosContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
            }
          }

          // Update before photo grid if it exists
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            const gridContainer = beforePhotoGrid.querySelector('div');
            if (gridContainer) {
              const squareSize = this.calculateSquareSize(3);
              // Always use 3 columns in both orientations
              gridContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
              gridContainer.style.gridAutoRows = `minmax(${squareSize}px, 1fr)`;
            }
          }
        }
        
        hideMainRoomTabs() {
          // Hide main room tabs when in camera mode
          const stickyTabsContainer = document.getElementById('sticky-tabs-container');
          if (stickyTabsContainer) {
            stickyTabsContainer.style.display = 'none';
          }
        }
        
        showMainRoomTabs() {
          // Show main room tabs when returning to gallery
          const stickyTabsContainer = document.getElementById('sticky-tabs-container');
          if (stickyTabsContainer) {
            stickyTabsContainer.style.display = 'flex';
          }

          // Also ensure header is visible
          this.showHeader();
        }

        showHeader() {
          // Ensure header is visible - find the header element
          const headerUploadBtn = document.getElementById('header-upload-btn');
          if (headerUploadBtn) {
            // Header exists, make sure its parent is visible
            const header = headerUploadBtn.closest('div');
            if (header) {
              header.style.display = 'flex';
              header.style.visibility = 'visible';
              header.style.opacity = '1';
            }
          } else {
            // If header is missing, something went wrong - reinitialize
            setTimeout(() => {
              this.init();
            }, 100);
          }
        }

        // Helper function to restore scrolling if no camera modals are open
        restoreScrollingIfNoCameraModals() {
          // Check if there are any camera-related modals still open
          const cameraModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 1000"], [style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          if (cameraModals.length === 0) {
            // No camera modals are open, restore scrolling
            document.body.style.overflow = '';
          }
        }

        addScrollListener() {
          // Throttle scroll events for performance
          let scrollTimeout;

          window.addEventListener('scroll', () => {
            if (scrollTimeout) {
              clearTimeout(scrollTimeout);
            }

            scrollTimeout = setTimeout(() => {
              this.checkVisibleRoom();
            }, 100); // Check every 100ms during scroll
          });
        }

        checkVisibleRoom() {
          // Room sections removed - scroll-based room switching disabled
          // Users can only switch rooms through tabs
        }
        
        attachPhotoListeners() {
          // Only attach listeners for photo elements (called after photo grid updates)
          // Clear any existing listeners first to prevent duplicates
          setTimeout(() => {
            document.querySelectorAll('.photo-item').forEach(item => {
              // Remove any existing listeners by cloning the element
              const newItem = item.cloneNode(true);
              item.parentNode.replaceChild(newItem, item);
              
              // Photo click to view fullscreen
              newItem.addEventListener('click', (e) => {
                // Don't trigger if clicking delete button or retake button
                if (e.target.classList.contains('delete-photo-btn') || 
                    e.target.classList.contains('retake-combined-btn')) {
                  return;
                }

                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                if (photoIndex >= 0 && photoIndex < this.photos.length) {
                  this.showPhotoFullscreen(this.photos[photoIndex]);
                }
              });

              // Add hover effect
              newItem.addEventListener('mouseenter', (e) => {
                e.currentTarget.style.transform = 'scale(1.02)';
              });

              newItem.addEventListener('mouseleave', (e) => {
                e.currentTarget.style.transform = 'scale(1)';
              });
            });

            // Delete button functionality for photos
            document.querySelectorAll('.delete-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const photoIndex = parseInt(e.target.dataset.photoIndex);
                this.deletePhoto(photoIndex);
              });
            });

            // Retake button functionality for combined photos
            document.querySelectorAll('.retake-combined-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const beforePhotoId = parseInt(e.target.dataset.beforePhotoId);
                const beforePhoto = this.photos.find(p => p.id === beforePhotoId);
                if (beforePhoto) {
                  // Open the comparison camera for retaking the after photo
                  this.showPhotoFullscreen(beforePhoto);
                }
              });
            });


            // Dummy photos click handlers
            document.querySelectorAll('.dummy-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                this.openCameraForRoom(room);
              });
            });
            
            // Auto-scroll to bottom to show latest photos (main gallery only)
            setTimeout(() => {
              const mainScrollableContent = document.getElementById('main-scrollable-content');
              if (mainScrollableContent) {
                
                if (mainScrollableContent.scrollHeight > mainScrollableContent.clientHeight) {
                  mainScrollableContent.scrollTop = mainScrollableContent.scrollHeight;
                } else {
                }
              } else {
              }
            }, 200);
          }, 100);
        }

        attachEventListeners() {
          // Room tabs with swipe support - attach with delay to ensure DOM is ready
          setTimeout(() => {
            this.attachRoomTabListeners();
          }, 100);
          
          // Add swipe functionality to room tabs
          this.addSwipeListeners();

          // Camera button - only visible during photo capture screens
          const cameraBtn = document.getElementById('camera-btn');
          if (cameraBtn) {
            cameraBtn.addEventListener('click', () => {
              // Check if we're in a camera modal (before or after mode)
              const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                                 document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                                 document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');

              if (cameraModal) {
                // We're in a camera modal, capture photo
                if (cameraModal.innerHTML.includes('camera-video')) {
                  // Before mode - regular camera
                  console.log('Capturing from regular camera modal');
                  this.captureFromCameraModal();
                } else if (cameraModal.innerHTML.includes('comparison-camera')) {
                  // After mode - comparison camera
                  console.log('Capturing from comparison camera modal');
                  this.captureFromComparisonModal();
                }
              }
            });
          }
          
          // Header upload button - delete all photos functionality
          const headerUploadBtn = document.getElementById('header-upload-btn');
          if (headerUploadBtn) {
            headerUploadBtn.addEventListener('click', () => {
              this.showDeleteAllConfirmation();
            });
          }
          
          // All Photos button - show all photos modal
          const allPhotosBtn = document.getElementById('all-photos-btn');
          if (allPhotosBtn) {
            allPhotosBtn.addEventListener('click', () => {
              this.showAllPhotosModal();
            });
          }
          
          // Location select
          const locationSelect = document.getElementById('location-select');
          if (locationSelect) {
            locationSelect.addEventListener('change', (e) => {
              console.log('Location changed to:', e.target.value);
              // You can add location-specific functionality here
            });
          }
          
          // Retake and Save button handlers
          const retakeBtn = document.getElementById('btn-retake');
          if (retakeBtn) {
            retakeBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Store the room before closing split screen
                const room = this.currentSplitScreen.room;

                // Close current split screen
                this.closeSplitScreenPreview();

                // Clean up any remaining modals (exclude permanent UI elements)
                const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
                existingModals.forEach(modal => {
                  try {
                    if (modal.parentNode &&
                        !modal.id.includes('bottom-panel') &&
                        !modal.id.includes('sticky-tabs-container') &&
                        modal.id !== 'bottom-panel' &&
                        modal.id !== 'sticky-tabs-container') {
                      if (modal.parentNode === document.body) {
                        document.body.removeChild(modal);
                      } else {
                        modal.parentNode.removeChild(modal);
                      }
                    }
                  } catch (error) {
                    console.log('Modal already removed:', error);
                  }
                });

                // Restore scrolling if no camera modals remain
                this.restoreScrollingIfNoCameraModals();

                // Small delay to ensure cleanup completes
                setTimeout(() => {
                  // Find the before photo and reopen comparison camera
                  const beforePhoto = this.photos.find(p =>
                    p.room === room && p.mode === 'before'
                  );

                  if (beforePhoto) {
                    this.showPhotoFullscreen(beforePhoto);
                  }
                }, 100);
              }
            });
          }

          const saveBtn = document.getElementById('btn-save');
          if (saveBtn) {
            saveBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Save the combined photo
                this.captureSplitScreenPhoto(
                  this.currentSplitScreen.beforeDataUrl,
                  this.currentSplitScreen.afterDataUrl,
                  this.currentSplitScreen.room
                );

                // Close split screen and return to gallery
                this.closeSplitScreenPreview();
              }
            });
          }
          
          // Photo event listeners moved to attachPhotoListeners() to prevent duplicates
          this.attachPhotoListeners();
        }
        
        
        updateTabs() {
          document.querySelectorAll('.photo-tab').forEach(tab => {
            const tabType = tab.dataset.tab;
            if (tabType === this.currentTab) {
              tab.style.background = '#F2C31B';
              tab.style.color = '#303030';
            } else {
              tab.style.background = 'transparent';
              tab.style.color = '#B3B3B3';
            }
          });
        }
        
        deletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            const photo = this.photos[photoIndex];
            const photoType = photo.mode === 'mix' ? 'combined before/after' : photo.mode;

            this.showDeleteConfirmation(photoType, photo.room, photoIndex);
          }
        }

        showDeleteConfirmation(photoType, room, photoIndex) {
          // Clean up any existing confirmation modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 3000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 3000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
              <!-- Title -->
              <h3 style="text-align: center; font-size: 20px; font-weight: bold; color: #1f2937; margin-bottom: 24px;">
                Are you sure?
              </h3>
              
              <!-- Buttons -->
              <div style="display: flex; gap: 12px;">
                <button id="cancel-delete-btn" style="flex: 1; padding: 12px 20px; border: 2px solid #d1d5db; background: white; color: #374151; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  Cancel
                </button>
                <button id="confirm-delete-btn" style="flex: 1; padding: 12px 20px; border: none; background: #F2C31B; color: #303030; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  Delete
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Add hover effects
          const cancelBtn = document.getElementById('cancel-delete-btn');
          const confirmBtn = document.getElementById('confirm-delete-btn');

          cancelBtn.addEventListener('mouseenter', () => {
            cancelBtn.style.background = '#f9fafb';
            cancelBtn.style.borderColor = '#9ca3af';
          });
          cancelBtn.addEventListener('mouseleave', () => {
            cancelBtn.style.background = 'white';
            cancelBtn.style.borderColor = '#d1d5db';
          });

          confirmBtn.addEventListener('mouseenter', () => {
            confirmBtn.style.background = '#e6b800';
          });
          confirmBtn.addEventListener('mouseleave', () => {
            confirmBtn.style.background = '#F2C31B';
          });

          // Event listeners
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          confirmBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
            this.confirmDeletePhoto(photoIndex);
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        confirmDeletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            this.photos.splice(photoIndex, 1);
            
            // Save changes to localStorage
            this.savePhotos();
            
            // Reassign names to maintain proper sequential numbering
            this.reassignPhotoNames();

            // Update photo grid without full DOM regeneration
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners(); // Re-attach event listeners for updated photo elements
            }

            // Update before photo grid in modal if it exists
            this.updateModalPhotoGrid();
          }
        }

        showDeleteAllConfirmation() {
          // Clean up any existing confirmation modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 3000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 3000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 400px; width: 90%; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
              <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
              <h2 style="margin: 0 0 15px 0; color: #303030; font-size: 20px;">Delete All Photos?</h2>
              <p style="margin: 0 0 25px 0; color: #666; line-height: 1.4;">
                This will permanently delete all ${this.photos.length} photos from all rooms. This action cannot be undone.
              </p>
              <div style="display: flex; gap: 15px;">
                <button id="cancel-delete-all" style="flex: 1; background: #f3f4f6; color: #374151; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 500;">
                  Cancel
                </button>
                <button id="confirm-delete-all" style="flex: 1; background: #dc2626; color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 500;">
                  Delete All
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          const cancelBtn = document.getElementById('cancel-delete-all');
          const confirmBtn = document.getElementById('confirm-delete-all');

          // Event listeners
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          confirmBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
            this.deleteAllPhotos();
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        deleteAllPhotos() {
          console.log(`üóëÔ∏è Deleting all ${this.photos.length} photos...`);

          // Clear the photos array
          this.photos = [];

          // Clear localStorage
          localStorage.removeItem('cleaning-photos');

          // Update the UI to show empty state
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }

          // Update before photo grid in modal if it exists
          this.updateModalPhotoGrid();


          // Show confirmation message
          setTimeout(() => {
            alert('All photos have been deleted successfully!');
          }, 100);
        }

        async showPhotoFullscreen(photo) {
          // Clean up any existing photo fullscreen modals first
          const existingPhotoModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingPhotoModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;
          
          if (photo.mode === 'before') {
            // Store the specific before photo that was clicked for later reference
            this.currentBeforePhoto = photo;
            
            // Split screen: before photo and camera
            modal.innerHTML = this.getComparisonModalHTML(photo);

            document.body.appendChild(modal);

            // Prevent background scrolling when modal is open
            document.body.style.overflow = 'hidden';

            // Hide main room tabs and show camera button for photo capture
            this.hideMainRoomTabs();
            this.showCameraButton();
            
            // Initialize camera for comparison
            try {
              let stream;
              try {
                const aspectRatio = this.getAspectRatio();
                const targetAspectRatio = aspectRatio.width / aspectRatio.height;
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                  video: { 
                    facingMode: 'environment', // Default to back camera
                    aspectRatio: targetAspectRatio
                  }
                });
              } catch (backCameraError) {
                console.log('Back camera not available, trying any camera:', backCameraError);
                const aspectRatio = this.getAspectRatio();
                const targetAspectRatio = aspectRatio.width / aspectRatio.height;
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                  video: { aspectRatio: targetAspectRatio }
                });
              }
              
              const video = document.getElementById('comparison-camera');
              video.srcObject = stream;
              
              let currentFacingMode = 'environment';
              
              
              // Close button
              document.getElementById('close-comparison-btn').addEventListener('click', () => {
                stream.getTracks().forEach(track => track.stop());
                document.body.removeChild(modal);
                this.hideCameraButton();
                this.showMainRoomTabs(); // Show room tabs when returning to gallery
                this.currentBeforePhoto = null; // Clear the reference

                // Restore background scrolling when modal is closed
                document.body.style.overflow = '';
              });
              
            } catch (error) {
              alert('Camera access denied or failed: ' + error.message);
              document.body.removeChild(modal);
              this.hideCameraButton();
              this.showMainRoomTabs(); // Show room tabs when returning to gallery
              this.currentBeforePhoto = null; // Clear the reference

              // Restore background scrolling when modal is closed
              document.body.style.overflow = '';
            }
            
          } else if (photo.mode === 'after') {
            // For after photos, find the linked before photo and open comparison camera for retaking
            const linkedBeforePhoto = this.photos.find(p => 
              p.id === photo.beforePhotoId && p.mode === 'before'
            );
            
            if (linkedBeforePhoto) {
              // Store the specific before photo that was clicked for later reference
              this.currentBeforePhoto = linkedBeforePhoto;
              
              // Split screen: before photo and camera
              modal.innerHTML = this.getComparisonModalHTML(linkedBeforePhoto);

              document.body.appendChild(modal);

              // Prevent background scrolling when modal is open
              document.body.style.overflow = 'hidden';

              // Hide main room tabs and show camera button for photo capture
              this.hideMainRoomTabs();
              this.showCameraButton();
              
              // Initialize camera for comparison
              try {
                let stream;
                try {
                  const aspectRatio = this.getAspectRatio();
                  const targetAspectRatio = aspectRatio.width / aspectRatio.height;
                  
                  stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                      facingMode: 'environment', // Default to back camera
                      aspectRatio: targetAspectRatio
                    }
                  });
                } catch (backCameraError) {
                  console.log('Back camera not available, trying any camera:', backCameraError);
                  const aspectRatio = this.getAspectRatio();
                  const targetAspectRatio = aspectRatio.width / aspectRatio.height;
                  
                  stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { aspectRatio: targetAspectRatio }
                  });
                }
                
                const video = document.getElementById('comparison-camera');
                video.srcObject = stream;
                
                let currentFacingMode = 'environment';
                
                
                // Close button
                document.getElementById('close-comparison-btn').addEventListener('click', () => {
                  stream.getTracks().forEach(track => track.stop());
                  document.body.removeChild(modal);
                  this.hideCameraButton();
                  this.showMainRoomTabs(); // Show room tabs when returning to gallery
                  this.currentBeforePhoto = null; // Clear the reference

                  // Restore background scrolling when modal is closed
                  document.body.style.overflow = '';
                });
                
              } catch (error) {
                alert('Camera access denied or failed: ' + error.message);
                document.body.removeChild(modal);
                this.hideCameraButton();
                this.showMainRoomTabs(); // Show room tabs when returning to gallery
                this.currentBeforePhoto = null; // Clear the reference

                // Restore background scrolling when modal is closed
                document.body.style.overflow = '';
              }
            } else {
              // Fallback: Regular fullscreen if no linked before photo found
              modal.innerHTML = `
                <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center;">
                  <img src="${photo.dataUrl}" style="width: 100vw; height: 100vh; object-fit: cover;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 40px 20px 20px; text-align: center; color: white;">
                    <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                    </div>
                    <div style="font-size: 16px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Close button -->
                  <button id="close-photo-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                    ‚úï
                  </button>
                </div>
              `;
              
              document.body.appendChild(modal);

              // Prevent background scrolling when modal is open
              document.body.style.overflow = 'hidden';

              document.getElementById('close-photo-btn').addEventListener('click', () => {
                document.body.removeChild(modal);

                // Restore UI elements when closing regular photo fullscreen
                this.showMainRoomTabs();
                document.body.style.overflow = '';
              });

              // Close on background click
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  document.body.removeChild(modal);

                  // Restore UI elements when closing regular photo fullscreen
                  this.showMainRoomTabs();
                  document.body.style.overflow = '';
                }
              });
            }
          } else {
            // Regular fullscreen for other photo types - show actual dimensions without transformation
            const orientation = this.detectPhotoOrientation(photo.naturalWidth || 800, photo.naturalHeight || 600);
            const templateType = photo.templateType || 'default';
            
            modal.innerHTML = `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: flex-start; justify-content: center; overflow: auto; background: rgba(0,0,0,0.95); padding-top: 80px; padding-bottom: 200px; box-sizing: border-box;">
                <!-- Scrollable container for actual size viewing -->
                <div id="photo-container" style="position: relative; display: flex; align-items: center; justify-content: center; max-width: 95vw; max-height: calc(100vh - 280px); overflow: auto; margin-top: 20px;">
                  <img id="fullscreen-photo" src="${photo.dataUrl}" style="display: block; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);" />
                </div>
                
                <!-- Photo info overlay -->
                <div style="position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; backdrop-filter: blur(10px); z-index: 10;">
                  <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                    ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                  </div>
                  <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                    ${new Date(photo.timestamp).toLocaleString()}
                  </div>
                  <div style="font-size: 12px; opacity: 0.7;">
                    Orientation: ${orientation} | Template: ${templateType}
                  </div>
                </div>
                
                <!-- Template selector for combined photos (larger icons, 2 rows) -->
                ${photo.mode === 'mix' ? `
                <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); z-index: 10; box-shadow: 0 4px 16px rgba(0,0,0,0.4);">
                  <!-- First row: Default and Landscape -->
                  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px;">
                    <!-- Default 4:3 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 12px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'default' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'default' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'default' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="default" style="display: none;" ${templateType === 'default' ? 'checked' : ''}>
                      <div style="width: 32px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 8px; color: #303030; font-weight: bold;">4:3</div>
                      </div>
                      <div style="font-size: 11px; font-weight: bold; text-align: center;">Default</div>
                      <div style="font-size: 9px; opacity: 0.8; text-align: center;">Standard</div>
                    </label>

                    <!-- Landscape 16:9 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 12px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'landscape' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="landscape" style="display: none;" ${templateType === 'landscape' ? 'checked' : ''}>
                      <div style="width: 40px; height: 22px; background: #F2C31B; border-radius: 2px; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 8px; color: #303030; font-weight: bold;">16:9</div>
                      </div>
                      <div style="font-size: 11px; font-weight: bold; text-align: center;">Landscape</div>
                      <div style="font-size: 9px; opacity: 0.8; text-align: center;">YouTube</div>
                    </label>
                  </div>

                  <!-- Second row: Square, Portrait, Blog -->
                  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                    <!-- Square 1:1 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'square' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'square' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'square' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="square" style="display: none;" ${templateType === 'square' ? 'checked' : ''}>
                      <div style="width: 24px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 7px; color: #303030; font-weight: bold;">1:1</div>
                      </div>
                      <div style="font-size: 10px; font-weight: bold; text-align: center;">Square</div>
                      <div style="font-size: 8px; opacity: 0.8; text-align: center;">Instagram</div>
                    </label>

                    <!-- Portrait 4:5 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'portrait' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="portrait" style="display: none;" ${templateType === 'portrait' ? 'checked' : ''}>
                      <div style="width: 19px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 7px; color: #303030; font-weight: bold;">4:5</div>
                      </div>
                      <div style="font-size: 10px; font-weight: bold; text-align: center;">Portrait</div>
                      <div style="font-size: 8px; opacity: 0.8; text-align: center;">LinkedIn</div>
                    </label>

                    <!-- Blog 3:2 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'blog' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="blog" style="display: none;" ${templateType === 'blog' ? 'checked' : ''}>
                      <div style="width: 28px; height: 19px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 7px; color: #303030; font-weight: bold;">3:2</div>
                      </div>
                      <div style="font-size: 10px; font-weight: bold; text-align: center;">Blog</div>
                      <div style="font-size: 8px; opacity: 0.8; text-align: center;">Articles</div>
                    </label>
                  </div>

                </div>
                ` : ''}

                
                <!-- Close button -->
                <button id="close-photo-btn" style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; backdrop-filter: blur(10px); z-index: 10;">
                  ‚úï
                </button>
              </div>
            `;
            
            document.body.appendChild(modal);

            // Prevent background scrolling when modal is open
            document.body.style.overflow = 'hidden';

            // Set default to fit screen mode
            const imgElement = modal.querySelector('#fullscreen-photo');
            const imgContainer = modal.querySelector('#photo-container');
            
            // Configure for fit-to-screen display
            imgElement.style.maxWidth = '100%';
            imgElement.style.maxHeight = '100%';
            imgElement.style.width = 'auto';
            imgElement.style.height = 'auto';
            imgContainer.style.maxWidth = '95vw';
            imgContainer.style.maxHeight = '95vh';
            imgContainer.style.overflow = 'hidden';

            // Template selector functionality (only for combined photos)
            if (photo.mode === 'mix') {
              const templateRadios = modal.querySelectorAll('input[name="template-selector"]');
              templateRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                  if (e.target.checked) {
                    const newTemplate = e.target.value;
                    console.log('Changing template for this photo to:', newTemplate);
                    
                    // Show loading state
                    const imgElement = modal.querySelector('#fullscreen-photo');
                    if (imgElement) {
                      imgElement.style.opacity = '0.5';
                    }
                    
                    // Regenerate this specific photo with new template
                    this.regenerateSpecificPhoto(photo, newTemplate, modal);
                  }
                });
              });
            }

            document.getElementById('close-photo-btn').addEventListener('click', () => {
              document.body.removeChild(modal);

              // Restore UI elements when closing regular photo fullscreen
              this.showMainRoomTabs();
              document.body.style.overflow = '';
            });

            // Close on background click
            modal.addEventListener('click', (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);

                // Restore UI elements when closing regular photo fullscreen
                this.showMainRoomTabs();
                document.body.style.overflow = '';
              }
            });
          }
        }
        
        captureComparisonPhoto(video, stream, beforePhoto) {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Calculate dimensions with correct aspect ratio
          const { width, height } = this.calculateCanvasDimensions(video.videoWidth, video.videoHeight, 800);

          canvas.width = width;
          canvas.height = height;

          // Calculate source rectangle to maintain aspect ratio
          const videoAspectRatio = video.videoWidth / video.videoHeight;
          const targetAspectRatio = width / height;
          
          let sourceX = 0, sourceY = 0, sourceWidth = video.videoWidth, sourceHeight = video.videoHeight;

          if (videoAspectRatio > targetAspectRatio) {
            // Video is wider, crop from sides
            sourceWidth = video.videoHeight * targetAspectRatio;
            sourceX = (video.videoWidth - sourceWidth) / 2;
          } else if (videoAspectRatio < targetAspectRatio) {
            // Video is taller, crop from top/bottom
            sourceHeight = video.videoWidth / targetAspectRatio;
            sourceY = (video.videoHeight - sourceHeight) / 2;
          }

          ctx.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);

          const dataUrl = canvas.toDataURL('image/jpeg', 0.6);

          // Automatically save the "after" photo
          this.saveAfterPhotoToAll(dataUrl, beforePhoto);

          // Stop camera stream
          stream.getTracks().forEach(track => track.stop());

          // Close modal overlays only (exclude permanent UI elements)
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
          existingModals.forEach(modal => {
            try {
              if (modal.parentNode &&
                  !modal.id.includes('bottom-panel') &&
                  !modal.id.includes('sticky-tabs-container') &&
                  modal.id !== 'bottom-panel' &&
                  modal.id !== 'sticky-tabs-container') {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else if (modal.parentNode) {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Restore scrolling if no camera modals remain
          this.restoreScrollingIfNoCameraModals();

          // Small delay to ensure cleanup completes before updating gallery
          setTimeout(() => {
            // Check if photo was taken from gallery dummy card
            if (this.galleryReturnContext && this.galleryReturnContext.returnToGallery) {
              console.log('Returning to gallery after photo from dummy card');
              
              // Clear the gallery return context
              this.galleryReturnContext = null;
              
              // Clear the before photo reference
              this.currentBeforePhoto = null;
              
              // Hide action buttons and restore UI
              this.hideActionButtons();
              this.showMainRoomTabs();
              document.body.style.overflow = '';
              
              // Return to All Photos gallery
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 200);
              
            } else {
              // Normal flow - update main gallery
              const photosContainer = document.getElementById('photos-container');
              if (photosContainer) {
                photosContainer.innerHTML = this.getPhotosHTML();
                this.attachPhotoListeners(); // Re-attach event listeners for new photo elements
              }

              // Hide action buttons and return to gallery view
              this.hideActionButtons();
              
              // Clear the before photo reference
              this.currentBeforePhoto = null;
              
              // Auto-cycle to next unpaired before photo in current room
              // Only auto-cycle if we're still in the same room where the photo was taken
              if (this.currentRoom === beforePhoto.room) {
                this.autoCycleToNextBeforePhoto(this.currentRoom);
              } else {
                // User switched rooms - just restore the UI and return to gallery
                this.showMainRoomTabs();
                this.hideActionButtons();
                document.body.style.overflow = '';
              }
            }
          }, 100);
        }
        
        autoCycleToNextBeforePhoto(room) {
          // Find all before photos in this room that don't have corresponding after photos
          const beforePhotos = this.photos.filter(p => p.room === room && p.mode === 'before');
          const afterPhotos = this.photos.filter(p => p.room === room && p.mode === 'after');
          
          // Find before photos that don't have a corresponding after photo
          const unpairedBeforePhotos = beforePhotos.filter(beforePhoto => {
            return !afterPhotos.some(afterPhoto => afterPhoto.beforePhotoId === beforePhoto.id);
          });
          
          if (unpairedBeforePhotos.length > 0) {
            // Sort by timestamp to get the next one chronologically
            unpairedBeforePhotos.sort((a, b) => a.timestamp - b.timestamp);
            const nextBeforePhoto = unpairedBeforePhotos[0];
            
            console.log('Auto-cycling to next before photo:', nextBeforePhoto);
            
            // Open comparison modal with the next before photo
            this.openComparisonModal(nextBeforePhoto);
          } else {
            console.log('All before photos in room', room, 'have been paired with after photos');

            // Restore UI when all photos are paired - return to gallery
            this.showMainRoomTabs();
            this.hideActionButtons();
            document.body.style.overflow = '';

            // Update the photo grid to show current room
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners();
            }
          }
        }
        
        openComparisonModal(beforePhoto) {
          // Create modal container
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: black; z-index: 2000; display: flex; align-items: center; justify-content: center;
          `;
          
          // Store the specific before photo that was clicked for later reference
          this.currentBeforePhoto = beforePhoto;
          
          // Split screen: before photo and camera
          modal.innerHTML = this.getComparisonModalHTML(beforePhoto);
          
          document.body.appendChild(modal);

          // Prevent background scrolling when modal is open
          document.body.style.overflow = 'hidden';

          // Hide main room tabs and show camera button for photo capture
          this.hideMainRoomTabs();
          this.showCameraButton();
          
          // Initialize camera for comparison
          this.initializeComparisonCamera(modal);
        }
        
        async initializeComparisonCamera(modal) {
          try {
            let stream;
            try {
              // Try to get back camera first
              const aspectRatio = this.getAspectRatio();
              const targetAspectRatio = aspectRatio.width / aspectRatio.height;
              
              stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                  facingMode: 'environment',
                  aspectRatio: targetAspectRatio
                } 
              });
            } catch (backCameraError) {
              console.log('Back camera not available, trying any camera:', backCameraError);
              const aspectRatio = this.getAspectRatio();
              const targetAspectRatio = aspectRatio.width / aspectRatio.height;
              
              stream = await navigator.mediaDevices.getUserMedia({ 
                video: { aspectRatio: targetAspectRatio }
              });
            }
            
            const video = document.getElementById('comparison-camera');
            video.srcObject = stream;
            
            let currentFacingMode = 'environment';
            
            // Close button
            document.getElementById('close-comparison-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(modal);
              this.hideCameraButton();
              this.showMainRoomTabs(); // Show room tabs when returning to gallery
              this.currentBeforePhoto = null; // Clear the reference

              // Restore background scrolling when modal is closed
              document.body.style.overflow = '';
            });
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
            document.body.removeChild(modal);
            this.hideCameraButton();
            this.showMainRoomTabs(); // Show room tabs when returning to gallery
            this.currentBeforePhoto = null; // Clear the reference

            // Restore background scrolling when modal is closed
            document.body.style.overflow = '';
          }
        }
        
        generatePhotoName(room, mode) {
          // Get all photos for this room and mode, sorted by timestamp (oldest first)
          const roomPhotos = this.photos
            .filter(p => p.room === room && p.mode === mode)
            .sort((a, b) => a.timestamp - b.timestamp);
          
          // The position should be based on the chronological order in the grid
          // Since photos are sorted by timestamp, the position is the index + 1
          const position = roomPhotos.length + 1;
          
          // Create simple name: "kitchen 1", "kitchen 2", etc.
          const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
          return `${roomName} ${position}`;
        }

        // Function to reassign names to all photos based on their current grid position
        reassignPhotoNames() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          
          rooms.forEach(room => {
            // Get all before photos for this room, sorted by timestamp (oldest first)
            const beforePhotos = this.photos
              .filter(p => p.room === room && p.mode === 'before')
              .sort((a, b) => a.timestamp - b.timestamp);
            
            // Reassign names based on chronological position
            beforePhotos.forEach((photo, index) => {
              const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
              const newName = `${roomName} ${index + 1}`;
              photo.name = newName;
              
              // Also update any linked after photos
              const afterPhoto = this.photos.find(p => 
                p.mode === 'after' && p.beforePhotoId === photo.id
              );
              if (afterPhoto) {
                afterPhoto.name = newName;
              }
            });
          });
          
          this.savePhotos();
        }

        saveAfterPhotoToAll(afterPhotoDataUrl, beforePhoto) {
          // Check if there's already an after photo linked to this before photo
          const existingAfterPhotoIndex = this.photos.findIndex(p => 
            p.mode === 'after' && p.beforePhotoId === beforePhoto.id
          );

          // Use the same name as the before photo
          const afterPhotoName = beforePhoto.name;

          const afterPhoto = {
            id: Date.now(),
            dataUrl: afterPhotoDataUrl,
            room: beforePhoto.room,
            mode: 'after', // Save as after photo for split-screen display
            name: afterPhotoName,
            timestamp: Date.now(),
            beforePhotoId: beforePhoto.id // Link to specific before photo
          };

          if (existingAfterPhotoIndex !== -1) {
            // Replace existing after photo
            this.photos[existingAfterPhotoIndex] = afterPhoto;
            console.log('Replaced existing after photo for before photo:', beforePhoto.id);
          } else {
            // Add new after photo
            this.photos.push(afterPhoto);
            console.log('Added new after photo for before photo:', beforePhoto.id);
          }

          // Automatically create combined photo using current template
          this.createCombinedPhoto(beforePhoto.dataUrl, afterPhotoDataUrl, beforePhoto.room, beforePhoto.name, this.currentTemplate);

          this.savePhotos();
        }
        
        createCombinedPhoto(beforeDataUrl, afterDataUrl, room, photoName, templateType = null) {
          // Use current global template if none specified
          const actualTemplateType = templateType || this.currentTemplate;
          console.log('Creating combined photo automatically for room:', room, 'with name:', photoName, 'template:', actualTemplateType);
          
          // Create image objects to get dimensions
          const beforeImg = new Image();
          const afterImg = new Image();
          
          let imagesLoaded = 0;
          const totalImages = 2;
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // All images loaded, now process them with enhanced sizing
              this.processEnhancedCombinedPhoto(beforeImg, afterImg, room, photoName, templateType);
            }
          };
          
          // Load images
          beforeImg.onload = onImageLoad;
          afterImg.onload = onImageLoad;
          beforeImg.src = beforeDataUrl;
          afterImg.src = afterDataUrl;
        }

        processEnhancedCombinedPhoto(beforeImg, afterImg, room, photoName, templateType) {
          // Calculate template dimensions using enhanced system
          const templateDimensions = this.calculateTemplateDimensions(
            { width: beforeImg.width, height: beforeImg.height },
            { width: afterImg.width, height: afterImg.height },
            templateType
          );

          // Create canvas with calculated dimensions
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = templateDimensions.targetWidth;
          canvas.height = templateDimensions.targetHeight;
          
          // Fill white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Apply cropping and positioning based on split type
          // Save the context state before clipping
          ctx.save();
          
          // Clip to the exact template dimensions
          ctx.beginPath();
          ctx.rect(0, 0, canvas.width, canvas.height);
          ctx.clip();
          
          if (templateDimensions.splitType === 'vertical') {
            this.drawVerticalSplit(ctx, beforeImg, afterImg, templateDimensions);
          } else {
            this.drawHorizontalSplit(ctx, beforeImg, afterImg, templateDimensions);
          }
          
          // Restore the context state
          ctx.restore();
          
          // Add labels
          this.addPhotoLabels(ctx, canvas.width, canvas.height, templateDimensions.splitType);
          
          // Convert to data URL and save
          const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
          this.saveCombinedPhoto(combinedDataUrl, room, photoName, templateType);
        }

        drawVerticalSplit(ctx, beforeImg, afterImg, templateDimensions) {
          const { beforeCrop, afterCrop, targetWidth, targetHeight } = templateDimensions;
          
          // For vertical split, each photo takes exactly half the height
          const halfHeight = targetHeight / 2;
          
          // Draw before photo (top half) - crop from center and fill the space
          const beforeAspectRatio = beforeCrop.cropWidth / beforeCrop.cropHeight;
          const topTargetAspectRatio = targetWidth / halfHeight;
          
          let beforeSrcX = beforeCrop.cropX;
          let beforeSrcY = beforeCrop.cropY;
          let beforeSrcWidth = beforeCrop.cropWidth;
          let beforeSrcHeight = beforeCrop.cropHeight;
          
          // Adjust source crop to match target aspect ratio
          if (beforeAspectRatio > topTargetAspectRatio) {
            // Source is wider, crop from sides
            const newSrcWidth = beforeCrop.cropHeight * topTargetAspectRatio;
            beforeSrcX = beforeCrop.cropX + (beforeCrop.cropWidth - newSrcWidth) / 2;
            beforeSrcWidth = newSrcWidth;
          } else if (beforeAspectRatio < topTargetAspectRatio) {
            // Source is taller, crop from top/bottom
            const newSrcHeight = beforeCrop.cropWidth / topTargetAspectRatio;
            beforeSrcY = beforeCrop.cropY + (beforeCrop.cropHeight - newSrcHeight) / 2;
            beforeSrcHeight = newSrcHeight;
          }
          
          // Draw before photo filling the top half exactly
          ctx.drawImage(
            beforeImg,
            beforeSrcX, beforeSrcY, beforeSrcWidth, beforeSrcHeight,
            0, 0, targetWidth, halfHeight
          );
          
          // Draw divider line
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(0, halfHeight);
          ctx.lineTo(targetWidth, halfHeight);
          ctx.stroke();
          
          // Draw after photo (bottom half) - crop from center and fill the space
          const afterAspectRatio = afterCrop.cropWidth / afterCrop.cropHeight;
          const bottomTargetAspectRatio = targetWidth / halfHeight;
          
          let afterSrcX = afterCrop.cropX;
          let afterSrcY = afterCrop.cropY;
          let afterSrcWidth = afterCrop.cropWidth;
          let afterSrcHeight = afterCrop.cropHeight;
          
          // Adjust source crop to match target aspect ratio
          if (afterAspectRatio > bottomTargetAspectRatio) {
            // Source is wider, crop from sides
            const newSrcWidth = afterCrop.cropHeight * bottomTargetAspectRatio;
            afterSrcX = afterCrop.cropX + (afterCrop.cropWidth - newSrcWidth) / 2;
            afterSrcWidth = newSrcWidth;
          } else if (afterAspectRatio < bottomTargetAspectRatio) {
            // Source is taller, crop from top/bottom
            const newSrcHeight = afterCrop.cropWidth / bottomTargetAspectRatio;
            afterSrcY = afterCrop.cropY + (afterCrop.cropHeight - newSrcHeight) / 2;
            afterSrcHeight = newSrcHeight;
          }
          
          // Draw after photo filling the bottom half exactly
          ctx.drawImage(
            afterImg,
            afterSrcX, afterSrcY, afterSrcWidth, afterSrcHeight,
            0, halfHeight, targetWidth, halfHeight
          );
        }

        drawHorizontalSplit(ctx, beforeImg, afterImg, templateDimensions) {
          const { beforeCrop, afterCrop, targetWidth, targetHeight } = templateDimensions;
          
          // For horizontal split, each photo takes exactly half the width
          const halfWidth = targetWidth / 2;
          
          // Draw before photo (left half) - crop from center and fill the space
          const beforeAspectRatio = beforeCrop.cropWidth / beforeCrop.cropHeight;
          const leftTargetAspectRatio = halfWidth / targetHeight;
          
          let beforeSrcX = beforeCrop.cropX;
          let beforeSrcY = beforeCrop.cropY;
          let beforeSrcWidth = beforeCrop.cropWidth;
          let beforeSrcHeight = beforeCrop.cropHeight;
          
          // Adjust source crop to match target aspect ratio
          if (beforeAspectRatio > leftTargetAspectRatio) {
            // Source is wider, crop from sides
            const newSrcWidth = beforeCrop.cropHeight * leftTargetAspectRatio;
            beforeSrcX = beforeCrop.cropX + (beforeCrop.cropWidth - newSrcWidth) / 2;
            beforeSrcWidth = newSrcWidth;
          } else if (beforeAspectRatio < leftTargetAspectRatio) {
            // Source is taller, crop from top/bottom
            const newSrcHeight = beforeCrop.cropWidth / leftTargetAspectRatio;
            beforeSrcY = beforeCrop.cropY + (beforeCrop.cropHeight - newSrcHeight) / 2;
            beforeSrcHeight = newSrcHeight;
          }
          
          // Draw before photo filling the left half exactly
          ctx.drawImage(
            beforeImg,
            beforeSrcX, beforeSrcY, beforeSrcWidth, beforeSrcHeight,
            0, 0, halfWidth, targetHeight
          );
          
          // Draw divider line
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(halfWidth, 0);
          ctx.lineTo(halfWidth, targetHeight);
          ctx.stroke();
          
          // Draw after photo (right half) - crop from center and fill the space
          const afterAspectRatio = afterCrop.cropWidth / afterCrop.cropHeight;
          const rightTargetAspectRatio = halfWidth / targetHeight;
          
          let afterSrcX = afterCrop.cropX;
          let afterSrcY = afterCrop.cropY;
          let afterSrcWidth = afterCrop.cropWidth;
          let afterSrcHeight = afterCrop.cropHeight;
          
          // Adjust source crop to match target aspect ratio
          if (afterAspectRatio > rightTargetAspectRatio) {
            // Source is wider, crop from sides
            const newSrcWidth = afterCrop.cropHeight * rightTargetAspectRatio;
            afterSrcX = afterCrop.cropX + (afterCrop.cropWidth - newSrcWidth) / 2;
            afterSrcWidth = newSrcWidth;
          } else if (afterAspectRatio < rightTargetAspectRatio) {
            // Source is taller, crop from top/bottom
            const newSrcHeight = afterCrop.cropWidth / rightTargetAspectRatio;
            afterSrcY = afterCrop.cropY + (afterCrop.cropHeight - newSrcHeight) / 2;
            afterSrcHeight = newSrcHeight;
          }
          
          // Draw after photo filling the right half exactly
          ctx.drawImage(
            afterImg,
            afterSrcX, afterSrcY, afterSrcWidth, afterSrcHeight,
            halfWidth, 0, halfWidth, targetHeight
          );
        }

        addPhotoLabels(ctx, canvasWidth, canvasHeight, splitType) {
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.font = 'bold 18px Arial';
              ctx.textAlign = 'center';
              
          const labelWidth = 100;
          const labelHeight = 30;
          
          if (splitType === 'vertical') {
            // Before label (top)
            const beforeLabelY = 20;
            ctx.fillRect(canvasWidth/2 - labelWidth/2, beforeLabelY, labelWidth, labelHeight);
              ctx.fillStyle = '#ffffff';
            ctx.fillText('BEFORE', canvasWidth/2, beforeLabelY + 20);
              
            // After label (bottom)
            const afterLabelY = canvasHeight/2 + 20;
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(canvasWidth/2 - labelWidth/2, afterLabelY, labelWidth, labelHeight);
              ctx.fillStyle = '#ffffff';
            ctx.fillText('AFTER', canvasWidth/2, afterLabelY + 20);
          } else {
            // Before label (left)
            const beforeLabelX = canvasWidth/4 - labelWidth/2;
            ctx.fillRect(beforeLabelX, 20, labelWidth, labelHeight);
            ctx.fillStyle = '#ffffff';
            ctx.fillText('BEFORE', beforeLabelX + labelWidth/2, 40);
            
            // After label (right)
            const afterLabelX = (3 * canvasWidth/4) - labelWidth/2;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(afterLabelX, 20, labelWidth, labelHeight);
            ctx.fillStyle = '#ffffff';
            ctx.fillText('AFTER', afterLabelX + labelWidth/2, 40);
          }
        }

        showTemplateSelector(beforePhoto, afterPhoto) {
          // Clean up any existing template selector modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2500"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Create modal container
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: rgba(0,0,0,0.8); z-index: 2500; 
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(10px);
          `;

          // Get template previews
          const templates = this.getTemplateOptions();

          modal.innerHTML = `
            <div style="
              background: white; 
              border-radius: 12px; 
              padding: 20px; 
              max-width: 90vw; 
              max-height: 90vh; 
              overflow-y: auto;
              box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            ">
              <h3 style="margin: 0 0 20px 0; text-align: center; color: #303030; font-size: 20px;">
                üìê Choose Template Size
              </h3>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                ${templates.map(template => `
                  <div class="template-option" data-template-type="${template.type}" style="
                    border: 2px solid #e1e5e9; 
                    border-radius: 8px; 
                    padding: 15px; 
                    text-align: center; 
                    cursor: pointer; 
                    transition: all 0.2s;
                    background: white;
                  " onmouseover="this.style.borderColor='#667eea'; this.style.background='#f8f9ff';" onmouseout="this.style.borderColor='#e1e5e9'; this.style.background='white';">
                    <div style="
                      width: 120px; 
                      height: ${template.previewHeight}px; 
                      background: #f0f0f0; 
                      border: 1px solid #ddd; 
                      margin: 0 auto 10px; 
                      border-radius: 4px;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      font-size: 12px;
                      color: #666;
                    ">
                      ${template.ratio}
                    </div>
                    <div style="font-weight: bold; margin-bottom: 5px; color: #303030;">
                      ${template.name}
                    </div>
                    <div style="font-size: 12px; color: #666;">
                      ${template.description}
                    </div>
                  </div>
                `).join('')}
              </div>

              <div style="display: flex; justify-content: center; gap: 15px;">
                <button id="cancel-template-btn" style="
                  background: #e1e5e9; 
                  color: #666; 
                  border: none; 
                  padding: 10px 20px; 
                  border-radius: 6px; 
                  cursor: pointer;
                  font-weight: bold;
                ">Cancel</button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Add click handlers for template options
          modal.querySelectorAll('.template-option').forEach(option => {
            option.addEventListener('click', () => {
              const templateType = option.dataset.templateType;
              this.regenerateCombinedPhoto(beforePhoto, afterPhoto, templateType);
              document.body.removeChild(modal);
            });
          });

          // Cancel button
          modal.querySelector('#cancel-template-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          // Close on backdrop click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });
        }

        getTemplateOptions() {
          return [
            {
              type: 'default',
              name: 'Default',
              ratio: '4:3',
              description: 'Original size (800√ó600)',
              previewHeight: 90
            },
            {
              type: 'square',
              name: 'Square',
              ratio: '1:1',
              description: 'Perfect for social media',
              previewHeight: 120
            },
            {
              type: 'portrait',
              name: 'Portrait',
              ratio: '4:5',
              description: 'Tall format (800√ó1000)',
              previewHeight: 150
            },
            {
              type: 'landscape',
              name: 'Landscape',
              ratio: '16:9',
              description: 'Wide format (800√ó450)',
              previewHeight: 68
            }
          ];
        }

        regenerateCombinedPhoto(beforePhoto, afterPhoto, templateType) {
          console.log('Regenerating combined photo with template:', templateType);
          
          // Remove existing combined photos for this before/after pair
          this.photos = this.photos.filter(p => 
            !(p.mode === 'mix' && p.name === beforePhoto.name && p.room === beforePhoto.room)
          );

          // Create new combined photo with selected template
          this.createCombinedPhoto(beforePhoto.dataUrl, afterPhoto.dataUrl, beforePhoto.room, beforePhoto.name, templateType);

          // Update UI
          setTimeout(() => {
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners();
            }
          }, 500); // Give time for photo generation
        }

        changeGlobalTemplate(newTemplate) {
          console.log('Changing global template from', this.currentTemplate, 'to', newTemplate);
          
          this.currentTemplate = newTemplate;
          
          // Show loading indicator
          const templateSelector = document.getElementById('template-selector');
          if (templateSelector) {
            templateSelector.style.opacity = '0.5';
            templateSelector.disabled = true;
          }
          
          // Find all combined photo pairs and regenerate them
          const beforeAfterPairs = [];
          
          // Group photos into before/after pairs
          this.photos.forEach(photo => {
            if (photo.mode === 'before') {
              const afterPhoto = this.photos.find(p => 
                p.mode === 'after' && p.beforePhotoId === photo.id
              );
              if (afterPhoto) {
                beforeAfterPairs.push({ before: photo, after: afterPhoto });
              }
            }
          });
          
          console.log('Found', beforeAfterPairs.length, 'photo pairs to regenerate');
          
          // Remove all existing combined photos
          this.photos = this.photos.filter(p => p.mode !== 'mix');
          
          // Regenerate all combined photos with new template
          let regeneratedCount = 0;
          const totalPairs = beforeAfterPairs.length;
          
          beforeAfterPairs.forEach((pair, index) => {
            setTimeout(() => {
              this.createCombinedPhoto(
                pair.before.dataUrl, 
                pair.after.dataUrl, 
                pair.before.room, 
                pair.before.name, 
                newTemplate
              );
              
              regeneratedCount++;
              
              // Update UI after all photos are regenerated
              if (regeneratedCount === totalPairs) {
                setTimeout(() => {
                  // Update main photos container
                  const photosContainer = document.getElementById('photos-container');
                  if (photosContainer) {
                    photosContainer.innerHTML = this.getPhotosHTML();
                    this.attachPhotoListeners();
                  }
                  
                  // Update gallery modal if it's open
                  const allPhotosContent = document.getElementById('all-photos-content');
                  if (allPhotosContent) {
                    allPhotosContent.innerHTML = this.getAllPhotosHTML();
                    // Reattach gallery photo listeners
                    this.attachGalleryPhotoListeners();
                  }
                  
                  // Re-enable template selector
                  if (templateSelector) {
                    templateSelector.style.opacity = '1';
                    templateSelector.disabled = false;
                  }
                  
                  // Save photos to localStorage after regeneration
                  this.savePhotos();
                  
                  // Backup: Ensure listeners are attached after a longer delay
                  setTimeout(() => {
                    const photosContainer = document.getElementById('photos-container');
                    if (photosContainer) {
                      this.attachPhotoListeners();
                    }
                    const allPhotosContent = document.getElementById('all-photos-content');
                    if (allPhotosContent) {
                      this.attachGalleryPhotoListeners();
                    }
                  }, 1000);
                  
                  console.log('Template change complete:', newTemplate);
                  console.log('Total photos after regeneration:', this.photos.length);
                }, 500);
              }
            }, index * 100); // Stagger the regeneration to avoid overwhelming the browser
          });
          
          // If no pairs to regenerate, just re-enable the selector
          if (totalPairs === 0) {
            if (templateSelector) {
              templateSelector.style.opacity = '1';
              templateSelector.disabled = false;
            }
          }
        }

        regenerateSpecificPhoto(photo, newTemplate, modal) {
          console.log('=== REGENERATE SPECIFIC PHOTO ===');
          console.log('Photo:', photo);
          console.log('New template:', newTemplate);
          console.log('Modal:', modal);
          console.log('Current photos count:', this.photos.length);
          
          // Find the before and after photos that created this combined photo
          const beforePhoto = this.photos.find(p => 
            p.mode === 'before' && p.room === photo.room && p.name === photo.name
          );
          const afterPhoto = this.photos.find(p => 
            p.mode === 'after' && p.room === photo.room && p.name === photo.name
          );
          
          console.log('Found before photo:', beforePhoto);
          console.log('Found after photo:', afterPhoto);
          
          if (!beforePhoto || !afterPhoto) {
            console.error('Could not find before/after photos for regeneration');
            console.error('Looking for room:', photo.room, 'name:', photo.name);
            console.error('Available photos:', this.photos.map(p => ({mode: p.mode, room: p.room, name: p.name})));
            
            // Reset image opacity and show error
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.style.opacity = '1';
            }
            return;
          }
          
          // Store original photo info before removal
          const originalPhotoInfo = {
            id: photo.id,
            room: photo.room,
            name: photo.name,
            timestamp: photo.timestamp
          };
          
          // Remove the old combined photo from the array
          const photoIndex = this.photos.findIndex(p => p.id === photo.id);
          if (photoIndex !== -1) {
            console.log('Removing old photo at index:', photoIndex);
            this.photos.splice(photoIndex, 1);
          }
          
          // Create new combined photo with the selected template and store reference
          this.createCombinedPhotoWithCallback(
            beforePhoto.dataUrl, 
            afterPhoto.dataUrl, 
            originalPhotoInfo.room, 
            originalPhotoInfo.name, 
            newTemplate,
            (createdPhoto) => {
              // Callback with the newly created photo
              this.handlePhotoRegenerated(createdPhoto, modal, originalPhotoInfo);
            }
          );
          
        }

        createCombinedPhotoWithCallback(beforeDataUrl, afterDataUrl, room, photoName, templateType = null, callback) {
          // Use current global template if none specified
          const actualTemplateType = templateType || this.currentTemplate;
          console.log('Creating combined photo with callback for room:', room, 'with name:', photoName, 'template:', actualTemplateType);
          
          // Create image objects to get dimensions
          const beforeImg = new Image();
          const afterImg = new Image();
          
          let imagesLoaded = 0;
          const totalImages = 2;
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // All images loaded, now process them with enhanced sizing
              const createdPhoto = this.processEnhancedCombinedPhotoWithCallback(beforeImg, afterImg, room, photoName, actualTemplateType, callback);
            }
          };
          
          // Load images
          beforeImg.onload = onImageLoad;
          afterImg.onload = onImageLoad;
          beforeImg.src = beforeDataUrl;
          afterImg.src = afterDataUrl;
        }

        processEnhancedCombinedPhotoWithCallback(beforeImg, afterImg, room, photoName, templateType, callback) {
          // Calculate template dimensions using enhanced system
          const templateDimensions = this.calculateTemplateDimensions(
            { width: beforeImg.width, height: beforeImg.height },
            { width: afterImg.width, height: afterImg.height },
            templateType
          );

          // Create canvas with calculated dimensions
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = templateDimensions.targetWidth;
          canvas.height = templateDimensions.targetHeight;
          
          // Fill white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Apply cropping and positioning based on split type
          // Save the context state before clipping
          ctx.save();
          
          // Clip to the exact template dimensions
          ctx.beginPath();
          ctx.rect(0, 0, canvas.width, canvas.height);
          ctx.clip();
          
          if (templateDimensions.splitType === 'vertical') {
            this.drawVerticalSplit(ctx, beforeImg, afterImg, templateDimensions);
          } else {
            this.drawHorizontalSplit(ctx, beforeImg, afterImg, templateDimensions);
          }
          
          // Restore the context state
          ctx.restore();
          
          // Add labels
          this.addPhotoLabels(ctx, canvas.width, canvas.height, templateDimensions.splitType);
          
          // Convert to data URL and save with callback
          const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
          const createdPhoto = this.saveCombinedPhotoWithCallback(combinedDataUrl, room, photoName, templateType, callback);
          return createdPhoto;
        }

        saveCombinedPhotoWithCallback(combinedDataUrl, room, photoName, templateType = 'default', callback) {
          console.log('saveCombinedPhoto with callback called with name:', photoName, 'template:', templateType);
          
          // Create the combined photo with the same name as before/after photos
          const combinedPhoto = {
            id: Date.now(),
            dataUrl: combinedDataUrl,
            room: room,
            mode: 'mix',
            name: photoName, // Use the same name as before/after photos
            templateType: templateType, // Store template type for future reference
            timestamp: Date.now()
          };
          
          console.log('Created combined photo with callback:', combinedPhoto);
          
          // Add the combined photo
          this.photos.push(combinedPhoto);
          
          // Call the callback immediately with the created photo
          if (callback) {
            callback(combinedPhoto);
          }
          
          return combinedPhoto;
        }

        handlePhotoRegenerated(createdPhoto, modal, originalPhotoInfo) {
          console.log('Handling photo regeneration with created photo:', createdPhoto);
          
          // Update the image in the modal
          const imgElement = modal.querySelector('#fullscreen-photo');
          if (imgElement) {
            imgElement.src = createdPhoto.dataUrl;
            imgElement.style.opacity = '1'; // Remove loading state
            
            // Update the photo info
            const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
            if (infoDiv) {
              const orientation = this.detectPhotoOrientation(createdPhoto.naturalWidth || 800, createdPhoto.naturalHeight || 600);
              infoDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${createdPhoto.room.charAt(0).toUpperCase() + createdPhoto.room.slice(1).replace('-', ' ')} - ${createdPhoto.mode.charAt(0).toUpperCase() + createdPhoto.mode.slice(1)}
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  ${new Date(createdPhoto.timestamp).toLocaleString()}
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Orientation: ${orientation} | Template: ${createdPhoto.templateType}
                </div>
              `;
            }
          }
          
          // Update main photos container
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }
          
          // Update gallery modal if it's open
          const allPhotosContent = document.getElementById('all-photos-content');
          if (allPhotosContent) {
            allPhotosContent.innerHTML = this.getAllPhotosHTML();
            this.attachGalleryPhotoListeners();
          }
          
          // Save updated photos
          this.savePhotos();
          
          // Reattach template selector listeners to the modal
          this.reattachTemplateListeners(modal, createdPhoto);
          
          console.log('Photo regeneration complete with template:', createdPhoto.templateType);
        }

        reattachTemplateListeners(modal, photo) {
          console.log('Reattaching template listeners for photo:', photo);
          
          if (!modal || !photo || photo.mode !== 'mix') {
            console.log('Skipping template listener reattachment - not a combined photo');
            return;
          }
          
          // Reattach radio button listeners (always visible now)
          const templateRadios = modal.querySelectorAll('input[name="template-selector"]');
          console.log('Found template radios:', templateRadios.length);
          
          templateRadios.forEach(radio => {
            // Remove existing listeners by cloning
            const newRadio = radio.cloneNode(true);
            radio.parentNode.replaceChild(newRadio, radio);
            
            // Add fresh event listener
            newRadio.addEventListener('change', (e) => {
              if (e.target.checked) {
                const newTemplate = e.target.value;
                console.log('Template changed to:', newTemplate);
                
                // Show loading state
                const imgElement = modal.querySelector('#fullscreen-photo');
                if (imgElement) {
                  imgElement.style.opacity = '0.5';
                }
                
                // Regenerate this specific photo with new template
                this.regenerateSpecificPhoto(photo, newTemplate, modal);
              }
            });
          });
          
          console.log('Template listeners reattached successfully');
        }
        
        
        showSplitScreenPreview(beforeDataUrl, afterDataUrl, room) {
          // Clean up any existing split screen modals first
          const existingSplitScreens = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingSplitScreens.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Create a new modal for split screen preview
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;

          modal.innerHTML = this.getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room);
          document.body.appendChild(modal);

          // Show action buttons in bottom panel
          this.showActionButtons();

          // Store current split screen data for button handlers
          this.currentSplitScreen = {
            beforeDataUrl,
            afterDataUrl,
            room,
            modal
          };

          // Close button event listener
          document.getElementById('close-split-btn').addEventListener('click', () => {
            this.closeSplitScreenPreview();
          });
        }

        closeSplitScreenPreview() {
          if (this.currentSplitScreen && this.currentSplitScreen.modal) {
            try {
              if (this.currentSplitScreen.modal.parentNode) {
                if (this.currentSplitScreen.modal.parentNode === document.body) {
                  document.body.removeChild(this.currentSplitScreen.modal);
                } else {
                  this.currentSplitScreen.modal.parentNode.removeChild(this.currentSplitScreen.modal);
                }
              }
            } catch (error) {
              console.log('Split screen modal already removed:', error);
            }
          }

          // Clean up any remaining split screen modals that might be orphaned
          const splitScreenModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          splitScreenModals.forEach(modal => {
            try {
              if (modal.parentNode) {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Hide action buttons and show camera button
          this.hideActionButtons();

          // Clear current split screen data
          this.currentSplitScreen = null;
        }
        
        captureSplitScreenPhoto(beforeDataUrl, afterDataUrl, room) {
          // Create a temporary fullscreen container for the split-screen photo
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: white; z-index: 9999;
          `;
          
          tempContainer.innerHTML = `
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column;">
              <!-- Before photo (top half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  BEFORE
                </div>
              </div>
              
              <!-- Divider line -->
              <div style="width: 100%; height: 4px; background: #000;"></div>
              
              <!-- After photo (bottom half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  AFTER
                </div>
              </div>
            </div>
          `;
          
          document.body.appendChild(tempContainer);
          
          // Use html2canvas to capture the entire screen
          setTimeout(() => {
            this.captureScreenAsImage(tempContainer, room);
          }, 500); // Give time for images to load
        }
        
        captureScreenAsImage(container, room) {
          // Create a canvas to capture the screen
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match the container
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          
          // Fill white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Get all images from the container
          const images = container.querySelectorAll('img');
          let imagesLoaded = 0;
          const totalImages = images.length;
          
          if (totalImages === 0) {
            // No images, just save the container
            this.saveCombinedPhoto(canvas.toDataURL('image/jpeg', 0.9), room);
            document.body.removeChild(container);
            return;
          }
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // All images loaded, now draw them
              const halfHeight = canvas.height / 2;
              
              // Draw before photo (top half)
              const beforeImg = images[0];
              ctx.drawImage(beforeImg, 0, 0, canvas.width, halfHeight);
              
              // Draw divider line
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(0, halfHeight);
              ctx.lineTo(canvas.width, halfHeight);
              ctx.stroke();
              
              // Draw after photo (bottom half)
              const afterImg = images[1];
              ctx.drawImage(afterImg, 0, halfHeight, canvas.width, halfHeight);
              
              // Add labels
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.font = 'bold 18px Arial';
              ctx.textAlign = 'center';
              
              // Before label
              ctx.fillRect(canvas.width/2 - 50, 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('BEFORE', canvas.width/2, 40);
              
              // After label
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.fillRect(canvas.width/2 - 50, halfHeight + 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('AFTER', canvas.width/2, halfHeight + 40);
              
              // Convert to data URL and save
              const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
              this.saveCombinedPhoto(combinedDataUrl, room);
              
              // Clean up
              document.body.removeChild(container);
            }
          };
          
          // Set up image load handlers
          images.forEach(img => {
            if (img.complete) {
              onImageLoad();
            } else {
              img.onload = onImageLoad;
            }
          });
        }
        
        saveCombinedPhoto(combinedDataUrl, room, photoName, templateType = 'default') {
          console.log('saveCombinedPhoto called with name:', photoName, 'template:', templateType);
          
          // Create the combined photo with the same name as before/after photos
          const combinedPhoto = {
            id: Date.now(),
            dataUrl: combinedDataUrl,
            room: room,
            mode: 'mix',
            name: photoName, // Use the same name as before/after photos
            templateType: templateType, // Store template type for future reference
            timestamp: Date.now()
          };
          
          console.log('Created combined photo:', combinedPhoto);
          
          // Add the combined photo
          this.photos.push(combinedPhoto);
          
          // Keep before photo in main gallery (don't move to archived)
          // The combined photo will appear in All Photos gallery separately
          
          this.savePhotos();

          // Photo saved successfully - modal closing handled by caller
        }
        
        async openCameraForRoom(room) {
          // Set the current room
          this.currentRoom = room;
          
          // Open camera
          await this.openCamera();
        }
        
        async openCamera() {
          console.log('Opening camera...');

          // Prevent multiple camera modals from opening simultaneously
          if (this.isOpeningCamera) {
            console.log('Camera already opening, ignoring request');
            return;
          }
          this.isOpeningCamera = true;

          try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
              alert('Camera not supported on this device');
              this.isOpeningCamera = false;
              return;
            }

            // Clean up any existing camera modals first
            const existingCameraModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 1000"]');
            existingCameraModals.forEach(existing => {
              if (existing.parentNode) {
                document.body.removeChild(existing);
              }
            });

            // Restore scrolling if no camera modals remain
            this.restoreScrollingIfNoCameraModals();

            // Try to use back camera first, fallback to any camera
            let stream;
            try {
              const aspectRatio = this.getAspectRatio();
              const targetAspectRatio = aspectRatio.width / aspectRatio.height;
              
              stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                  facingMode: 'environment', // Back camera
                  aspectRatio: targetAspectRatio
                }
              });
            } catch (backCameraError) {
              console.log('Back camera not available, trying any camera:', backCameraError);
              const aspectRatio = this.getAspectRatio();
              const targetAspectRatio = aspectRatio.width / aspectRatio.height;
              
              stream = await navigator.mediaDevices.getUserMedia({ 
                video: { aspectRatio: targetAspectRatio }
              });
            }

            // Create fullscreen camera modal
            const modal = document.createElement('div');
            modal.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
              background: black; z-index: 1000; display: flex; 
              flex-direction: column; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = this.getBeforePhotoModalHTML();
            
            document.body.appendChild(modal);
            console.log('Before photo modal created and added to DOM');

            // Prevent background scrolling when modal is open
            document.body.style.overflow = 'hidden';

            // Hide main room tabs and show camera button for photo capture
            this.hideMainRoomTabs();
            this.showCameraButton();
            
            const video = document.getElementById('camera-video');
            console.log('Video element found:', video);
            if (video) {
              video.srcObject = stream;
              console.log('Stream assigned to video');
            } else {
              console.error('Video element not found!');
            }
            
            // Store current facing mode
            let currentFacingMode = 'environment'; // Start with back camera
            
            // Capture will be handled by the bottom panel camera button
            
            document.getElementById('close-before-modal-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              if (modal && modal.parentNode) {
                document.body.removeChild(modal);
              }
              this.isOpeningCamera = false; // Reset flag
              this.hideCameraButton(); // Hide camera button when closing modal
              this.showMainRoomTabs(); // Show room tabs when returning to gallery

              // Restore background scrolling when modal is closed
              document.body.style.overflow = '';
            });

            // Attach listeners to before photo items
            this.attachBeforePhotoListeners();
            
            // Auto-scroll to bottom to show latest photos
            setTimeout(() => {
              const beforePhotoGrid = document.getElementById('before-photo-grid');
              if (beforePhotoGrid) {
                beforePhotoGrid.scrollTop = beforePhotoGrid.scrollHeight;
              }
            }, 200);
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
            this.isOpeningCamera = false; // Reset flag on error
            this.hideCameraButton();
            this.showMainRoomTabs(); // Show room tabs when returning to gallery
          }
        }
        
        captureFromCameraModal() {
          // Get the camera video element
          const video = document.getElementById('camera-video');
          if (!video || !video.srcObject) {
            console.error('Camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Capture the before photo
          this.capturePhoto(video, stream);
        }
        
        captureFromComparisonModal() {
          // Get the comparison camera video element
          const video = document.getElementById('comparison-camera');
          if (!video || !video.srcObject) {
            console.error('Comparison camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Use the specific before photo that was clicked to open the comparison modal
          const beforePhoto = this.currentBeforePhoto;

          if (!beforePhoto) {
            console.error('No before photo reference found - this should not happen');
            return;
          }
          
          // Capture the after photo
          this.captureComparisonPhoto(video, stream, beforePhoto);
        }
        
        // Helper function to get aspect ratio based on device orientation
        getAspectRatio() {
          const isLandscape = window.innerWidth > window.innerHeight;
          if (isLandscape) {
            return { width: 8, height: 9 }; // 8:9 for horizontal
          } else {
            return { width: 1, height: 1.15 }; // 1:1.15 for vertical
          }
        }

        // Enhanced photo sizing and cropping system
        // Default sizes for different templates
        getTemplateSizes() {
          return {
            'default': { width: 800, height: 600 }, // 4:3 default
            'square': { width: 800, height: 800 },   // 1:1 square - Instagram & Facebook
            'portrait': { width: 800, height: 1000 }, // 4:5 portrait - Instagram & LinkedIn
            'landscape': { width: 800, height: 450 }, // 16:9 landscape - Facebook & YouTube
            'blog': { width: 800, height: 533 }      // 3:2 blog - blogs & web articles
          };
        }

        // Detect photo orientation based on aspect ratio
        detectPhotoOrientation(width, height) {
          const aspectRatio = width / height;
          
          // Optimized ratios:
          // Vertical photos: 1:1.15 (‚âà0.87) - optimal for minimal crop on 1:1 and 4:5
          // Horizontal photos: 8:9 (‚âà0.889) - optimal for 16:9 when combined side-by-side
          if (aspectRatio <= 0.87) {
            return 'vertical'; // 1:1.15 ratio (W:H ‚âà 0.87)
          } else {
            return 'horizontal'; // 8:9 ratio (W:H ‚âà 0.889)
          }
        }

        // Calculate crop dimensions for individual photos based on template and orientation
        calculatePhotoCropDimensions(photoWidth, photoHeight, templateType, orientation) {
          const W = photoWidth;
          const H = photoHeight;
          
          let cropWidth, cropHeight;
          
          switch (templateType) {
            case 'square': // 1:1
              if (orientation === 'vertical') {
                // Vertical photos (1:1.15): Crop ~13% vertically for minimal loss
                cropWidth = W;
                cropHeight = W; // Square crop using full width
              } else {
                // Horizontal photos (8:9): Crop ~10-20% for square
                const minDimension = Math.min(W, H);
                cropWidth = minDimension;
                cropHeight = minDimension;
              }
              break;
              
            case 'portrait': // 4:5
              if (orientation === 'vertical') {
                // Vertical photos (1:1.15): Crop ~7% vertically for minimal loss
                cropWidth = W;
                cropHeight = W * 1.25; // 4:5 ratio
              } else {
                // Horizontal photos (8:9): Crop ~10-20% for portrait
                cropHeight = H;
                cropWidth = cropHeight * 0.8; // 4:5 ratio
              }
              break;
              
            case 'landscape': // 16:9
              if (orientation === 'vertical') {
                // Vertical photos: Use for side-by-side combination
                cropWidth = W;
                cropHeight = H;
              } else {
                // Horizontal photos (8:9): Perfect for side-by-side ‚Üí 16:9
                cropWidth = W;
                cropHeight = H;
              }
              break;
              
            case 'blog': // 3:2
              if (orientation === 'vertical') {
                // Vertical photos: Crop for 3:2 ratio
                cropWidth = W;
                cropHeight = W * 1.5; // 3:2 ratio
              } else {
                // Horizontal photos: Use for 3:2 combination
                cropWidth = W;
                cropHeight = H;
              }
              break;
              
            default: // 'default' - preserve original ratios
              cropWidth = W;
              cropHeight = H;
              break;
          }
          
          // Ensure crops don't exceed original dimensions
          cropWidth = Math.min(cropWidth, W);
          cropHeight = Math.min(cropHeight, H);
          
          return {
            cropWidth: Math.round(cropWidth),
            cropHeight: Math.round(cropHeight),
            cropX: Math.round((W - cropWidth) / 2),
            cropY: Math.round((H - cropHeight) / 2)
          };
        }

        // Calculate final template dimensions after combining photos
        calculateTemplateDimensions(beforePhoto, afterPhoto, templateType, splitType = null) {
          const beforeOrientation = this.detectPhotoOrientation(beforePhoto.width, beforePhoto.height);
          const afterOrientation = this.detectPhotoOrientation(afterPhoto.width, afterPhoto.height);
          
          // Smart split type selection based on optimized ratios
          if (!splitType) {
            if (templateType === 'landscape') {
              // 16:9 ‚Üí always use side-by-side for optimal ratio
              splitType = 'horizontal';
            } else if (templateType === 'blog') {
              // 3:2 ‚Üí use side-by-side for optimal ratio
              splitType = 'horizontal';
            } else if (templateType === 'portrait') {
              // 4:5 ‚Üí use stacked for optimal ratio
              splitType = 'vertical';
            } else if (templateType === 'square') {
              // 1:1 ‚Üí choose based on orientation for minimal crop
              splitType = beforeOrientation === 'vertical' ? 'vertical' : 'horizontal';
            } else {
              // Default ‚Üí preserve original behavior
              splitType = 'vertical';
            }
          }
          
          // Get individual photo crop dimensions
          const beforeCrop = this.calculatePhotoCropDimensions(
            beforePhoto.width, beforePhoto.height, templateType, beforeOrientation
          );
          const afterCrop = this.calculatePhotoCropDimensions(
            afterPhoto.width, afterPhoto.height, templateType, afterOrientation
          );
          
          let combinedWidth, combinedHeight;
          
          if (splitType === 'vertical') {
            // Stacked: before on top, after below
            combinedWidth = Math.max(beforeCrop.cropWidth, afterCrop.cropWidth);
            combinedHeight = beforeCrop.cropHeight + afterCrop.cropHeight;
          } else {
            // Side-by-side: before left, after right
            combinedWidth = beforeCrop.cropWidth + afterCrop.cropWidth;
            combinedHeight = Math.max(beforeCrop.cropHeight, afterCrop.cropHeight);
          }
          
          // Get target template dimensions
          const templateSizes = this.getTemplateSizes();
          const targetTemplate = templateSizes[templateType] || templateSizes.default;
          
          // For proper cropping, we want to fill the entire target canvas
          // The scale should be calculated to ensure we fill the canvas completely
          const scaleToFitWidth = targetTemplate.width / combinedWidth;
          const scaleToFitHeight = targetTemplate.height / combinedHeight;
          
          // Use the larger scale to ensure the combined image fills the entire canvas
          // This means some content might be cropped, but no empty space
          const scale = Math.max(scaleToFitWidth, scaleToFitHeight);
          
          return {
            combinedWidth,
            combinedHeight,
            targetWidth: targetTemplate.width,
            targetHeight: targetTemplate.height,
            splitType,
            beforeCrop,
            afterCrop,
            scale
          };
        }

        // Helper function to calculate canvas dimensions with correct aspect ratio (enhanced)
        calculateCanvasDimensions(videoWidth, videoHeight, maxSize = 800, templateType = 'default') {
          const orientation = this.detectPhotoOrientation(videoWidth, videoHeight);
          const cropDimensions = this.calculatePhotoCropDimensions(
            videoWidth, videoHeight, templateType, orientation
          );
          
          // Scale to fit within maxSize while maintaining aspect ratio
          const scale = Math.min(
            maxSize / cropDimensions.cropWidth,
            maxSize / cropDimensions.cropHeight
          );
          
          return {
            width: Math.round(cropDimensions.cropWidth * scale),
            height: Math.round(cropDimensions.cropHeight * scale),
            cropDimensions
          };
        }

        // Helper function to calculate square size for grids
        calculateSquareSize(columns) {
          if (this.isLandscape) {
            // In landscape mode, use the height (which equals portrait width) to calculate square size
            const landscapeHeight = window.innerHeight; // This is equivalent to portrait width
            const availableHeight = landscapeHeight - 200; // Account for headers, tabs, padding
            const squareSize = Math.floor(availableHeight / columns);
            
            return squareSize;
          } else {
            // In portrait mode, calculate actual size based on screen width
            const availableWidth = window.innerWidth - 20; // Account for padding
            return Math.floor(availableWidth / columns);
          }
        }

        capturePhoto(video, stream) {
          console.log('Capturing photo...');
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');

          // Calculate dimensions with correct aspect ratio
          const { width, height } = this.calculateCanvasDimensions(video.videoWidth, video.videoHeight, 800);

          canvas.width = width;
          canvas.height = height;

          // Calculate source rectangle to maintain aspect ratio
          const videoAspectRatio = video.videoWidth / video.videoHeight;
          const targetAspectRatio = width / height;
          
          let sourceX = 0, sourceY = 0, sourceWidth = video.videoWidth, sourceHeight = video.videoHeight;

          if (videoAspectRatio > targetAspectRatio) {
            // Video is wider, crop from sides
            sourceWidth = video.videoHeight * targetAspectRatio;
            sourceX = (video.videoWidth - sourceWidth) / 2;
          } else if (videoAspectRatio < targetAspectRatio) {
            // Video is taller, crop from top/bottom
            sourceHeight = video.videoWidth / targetAspectRatio;
            sourceY = (video.videoHeight - sourceHeight) / 2;
          }

          context.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, width, height);
          
          // First photos are always "before" photos
          const photoMode = 'before';
          
          // Create simple position-based name or use pending name from gallery
          const photoName = this.pendingPhotoName || this.generatePhotoName(this.currentRoom, photoMode);
          
          const photo = {
            id: Date.now(),
            dataUrl: canvas.toDataURL('image/jpeg', 0.6),
            room: this.currentRoom,
            mode: photoMode,
            name: photoName,
            timestamp: Date.now()
          };
          
          console.log('Photo created:', photo);
          this.photos.push(photo);
          console.log('Photos array length:', this.photos.length);
          this.savePhotos();
          
          // Update the before photo grid in the modal
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            // Store current scroll position and content height
            const previousScrollTop = beforePhotoGrid.scrollTop;
            const previousScrollHeight = beforePhotoGrid.scrollHeight;

            beforePhotoGrid.innerHTML = this.getBeforePhotosGridHTML();
            this.attachBeforePhotoListeners();

            // Smart scrolling to keep content visible above bottom panel
            setTimeout(() => {
              const currentScrollHeight = beforePhotoGrid.scrollHeight;
              const containerHeight = beforePhotoGrid.clientHeight;
              const bottomPanelHeight = 80; // Height of bottom panel

              // If content grew (new photos added), scroll up to accommodate
              if (currentScrollHeight > previousScrollHeight) {
                const heightDifference = currentScrollHeight - previousScrollHeight;

                // Calculate optimal scroll position to keep latest content visible
                // but not hidden behind bottom panel
                const maxVisibleScroll = currentScrollHeight - containerHeight + bottomPanelHeight;
                const newScrollTop = Math.min(previousScrollTop + heightDifference, maxVisibleScroll);

                beforePhotoGrid.scrollTop = Math.max(0, newScrollTop);
                console.log('üì∏ Auto-scrolled up after capturing new photo');
              }
            }, 100);
          }

          // Update main gallery as well
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }

          // Check if photo was taken from gallery dummy card (before photo)
          if (this.galleryReturnContext && this.galleryReturnContext.returnToGallery && this.galleryReturnContext.mode === 'before') {
            console.log('Before photo taken from gallery dummy card - closing camera and returning to gallery');
            
            // Close the before photo modal
            setTimeout(() => {
              // Stop camera stream
              const video = document.querySelector('video');
              if (video && video.srcObject) {
                const stream = video.srcObject;
                stream.getTracks().forEach(track => track.stop());
              }
              
              // Close modal overlays
              const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
              existingModals.forEach(modal => {
                try {
                  if (modal.parentNode &&
                      !modal.id.includes('bottom-panel') &&
                      !modal.id.includes('sticky-tabs-container') &&
                      modal.id !== 'bottom-panel' &&
                      modal.id !== 'sticky-tabs-container') {
                    if (modal.parentNode === document.body) {
                      document.body.removeChild(modal);
                    } else if (modal.parentNode) {
                      modal.parentNode.removeChild(modal);
                    }
                  }
                } catch (error) {
                  console.log('Modal already removed:', error);
                }
              });
              
              // Clear the gallery return context
              this.galleryReturnContext = null;
              
              // Hide action buttons and restore UI
              this.hideActionButtons();
              this.showMainRoomTabs();
              document.body.style.overflow = '';
              
              // Return to All Photos gallery
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 200);
              
            }, 500); // Small delay to let user see the photo was captured
          }

          console.log('Photo capture completed');
        }

        attachBeforePhotoListeners() {
          // Add click listeners to before photo items in the modal
          setTimeout(() => {
            // Delete button listeners
            document.querySelectorAll('.delete-before-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering the photo click
                const photoId = parseInt(e.currentTarget.dataset.photoId);
                const photoIndex = this.photos.findIndex(p => p.id === photoId);
                if (photoIndex !== -1) {
                  this.showDeleteConfirmation('before', this.currentRoom, photoIndex);
                }
              });
            });

            // Photo item click listeners (for enlarging photo)
            document.querySelectorAll('.before-photo-item').forEach(item => {
              item.addEventListener('click', (e) => {
                // Only trigger if clicking on the photo itself, not on buttons
                if (e.target === item || e.target.tagName === 'IMG') {
                  const photoId = parseInt(e.currentTarget.dataset.photoId);
                  const photo = this.photos.find(p => p.id === photoId);
                  if (photo) {
                    // Show enlarged photo
                    this.showPhotoEnlarged(photo);
                  }
                }
              });
            });

            // Room tab listeners in modal
            document.querySelectorAll('#modal-tabs-carousel .room-tab').forEach(btn => {
              btn.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                if (room && room !== this.currentRoom) {
                  this.currentRoom = room;
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }
              });
            });

            // Dummy square listeners in modal (for taking new before photos)
            document.querySelectorAll('.dummy-before-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                // Dummy squares don't do anything special - camera button is already available
                // They just provide visual feedback that more photos can be taken
                console.log('Dummy square clicked - camera button should be used for taking photos');
              });
            });
          }, 100);
        }


        savePhotos() {
          try {
            // Check storage size before saving
            const photosData = JSON.stringify(this.photos);
            const sizeInMB = (photosData.length * 2) / (1024 * 1024); // Rough estimate of size in MB

            localStorage.setItem('cleaning-photos', photosData);
          } catch (e) {
            if (e.name === 'QuotaExceededError') {
              this.manageStorage();
            } else {
              console.error('Error saving photos:', e);
            }
          }
        }

        manageStorage() {
          // Remove oldest photos if storage is full
          const maxPhotos = 50; // Limit to 50 photos total

          if (this.photos.length > maxPhotos) {
            // Sort by timestamp and keep only the newest photos
            this.photos.sort((a, b) => b.timestamp - a.timestamp);
            const removedCount = this.photos.length - maxPhotos;
            this.photos = this.photos.slice(0, maxPhotos);

            console.log(`üßπ Removed ${removedCount} oldest photos to free up storage`);

            // Try saving again
            try {
              localStorage.setItem('cleaning-photos', JSON.stringify(this.photos));

              // Update the UI to reflect the changes
              const photosContainer = document.getElementById('photos-container');
              if (photosContainer) {
                photosContainer.innerHTML = this.getPhotosHTML();
                this.attachPhotoListeners();
              }
            } catch (e) {
              alert('Storage is full. Please delete some photos manually.');
            }
          } else {
            // If we don't have too many photos, try compressing them
            this.compressPhotosAndSave();
          }
        }

        compressPhotosAndSave() {
          console.log('üóúÔ∏è Attempting to compress photos...');

          // Compress images by reducing quality
          const compressedPhotos = this.photos.map(photo => {
            if (photo.dataUrl && photo.dataUrl.startsWith('data:image/')) {
              // Create a canvas to re-compress the image
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();

              return new Promise(resolve => {
                img.onload = () => {
                  // Reduce size if image is too large
                  const maxWidth = 800;
                  const maxHeight = 600;
                  let { width, height } = img;

                  if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                  }

                  canvas.width = width;
                  canvas.height = height;

                  ctx.drawImage(img, 0, 0, width, height);

                  // Compress with lower quality
                  const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.5);
                  resolve({ ...photo, dataUrl: compressedDataUrl });
                };
                img.src = photo.dataUrl;
              });
            }
            return Promise.resolve(photo);
          });

          Promise.all(compressedPhotos).then(compressed => {
            this.photos = compressed;
            try {
              localStorage.setItem('cleaning-photos', JSON.stringify(this.photos));
            } catch (e) {
              // Fall back to removing old photos
              this.manageStorage();
            }
          });
        }
        
        loadPhotos() {
          const saved = localStorage.getItem('cleaning-photos');
          if (saved) {
            this.photos = JSON.parse(saved);
          }
        }
      }
      
      // Initialize app
      const app = new CleaningPhotoApp();

      // Make app available globally for debugging
      window.app = app;
      window.testRoomTabs = () => app.testRoomTabs();

    </script>
    
    <!-- Fallback for browsers that don't support ES6 modules -->
    <script nomodule>
      document.getElementById('debug-info').innerHTML += '<div style="color: orange;">‚ö†Ô∏è ES6 modules not supported</div>';
      
      // Show a simple message instead of React app
      setTimeout(() => {
        document.getElementById('root').innerHTML = `
          <div style="padding: 20px; text-align: center; font-family: Arial, sans-serif;">
            <h1>üö´ Browser Compatibility Issue</h1>
            <p>Your browser doesn't support ES6 modules, which are required for this app.</p>
            <p>Please update your browser or try a different browser.</p>
            <p style="color: #666; font-size: 14px;">iOS Safari 10.3+ is required for ES6 module support.</p>
          </div>
        `;
      }, 2000);
    </script>
    
  </body>
</html>