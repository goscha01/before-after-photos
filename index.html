<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#F2C31B" />
    <meta name="description" content="Mobile-first cleaning photo documentation app" />

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

    <!-- Prevent zoom on input fields -->
    <meta name="format-detection" content="telephone=no" />

    <!-- Status bar styling for iOS -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Cleaning App" />
    
    <!-- Additional iOS compatibility -->
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="apple-mobile-web-app-orientations" content="portrait" />

    <title>Cleaning Photo App</title>

    <!-- Google Fonts - Quicksand -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
      /* Prevent flash of unstyled content */
      body {
        margin: 0;
        padding: 0;
        font-family: 'Quicksand', sans-serif;
        background-color: #f8fafc;
        color: #1e293b;
        overscroll-behavior-y: auto;
        overscroll-behavior-x: none;
        overflow-x: hidden;
        width: 100vw;
        max-width: 100vw;
        height: 100vh;
      }
      
      * {
        box-sizing: border-box;
      }
      
      /* Hide scrollbars for swipeable elements */
      #room-tabs-container::-webkit-scrollbar {
        display: none;
      }
      
      #room-tabs-container {
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      /* Loading spinner */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8fafc;
        z-index: 9999;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #e2e8f0;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Hide loading once React loads */
      #root:not(:empty) + .loading-container {
        display: none;
      }

      /* Debug info */
      .debug-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 10000;
        max-width: 300px;
      }
    </style>
    <script src="config.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <div class="loading-container">
      <div class="loading-spinner"></div>
    </div>
    
    <!-- Debug info (hidden by default) -->
    <div class="debug-info" id="debug-info" style="display: none;">
      <div>üì± User Agent: <span id="user-agent">Loading...</span></div>
      <div>üåê Location: <span id="location">Loading...</span></div>
      <div>‚è∞ Time: <span id="time">Loading...</span></div>
    </div>
    
    <script>
      // Basic debug info
      
      // Update debug info
      document.getElementById('user-agent').textContent = navigator.userAgent.substring(0, 50) + '...';
      document.getElementById('location').textContent = window.location.href;
      document.getElementById('time').textContent = new Date().toLocaleTimeString();
      
      // Check if we're on iOS
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      
      if (isIOS) {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">üçé iOS Detected</div>';
      }
      
      // Check if React loads
      let reactLoadTimer = setTimeout(() => {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå React Failed to Load</div>';
      }, 10000);
      
      // Clear timer when React loads
      window.addEventListener('load', () => {
        clearTimeout(reactLoadTimer);
      });
      
      // Check for React errors
      window.addEventListener('error', (e) => {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå JS Error: ' + e.error.message + '</div>';
      });
      
      // Check for unhandled promise rejections
      window.addEventListener('unhandledrejection', (e) => {
        document.getElementById('debug-info').innerHTML += '<div style="color: #ff6b6b;">‚ùå Promise Error: ' + e.reason + '</div>';
      });
      
      // Monitor script loading
      const scripts = document.querySelectorAll('script[type="module"]');
      scripts.forEach((script, index) => {
        script.addEventListener('load', () => {
          document.getElementById('debug-info').innerHTML += '<div style="color: green;">‚úÖ Script ' + index + ' loaded</div>';
        });
        script.addEventListener('error', (e) => {
          document.getElementById('debug-info').innerHTML += '<div style="color: red;">‚ùå Script ' + index + ' failed: ' + e.message + '</div>';
        });
      });
      
      // Check if main.jsx loads
    </script>
    
    <!-- Simple JavaScript test -->
    <script>
      
      // Test if we can create DOM elements
      try {
        const testDiv = document.createElement('div');
        testDiv.innerHTML = '<div style="color: green;">‚úÖ Basic JavaScript Works!</div>';
        document.getElementById('debug-info').appendChild(testDiv);
      } catch (e) {
      }
      
    </script>
    
    <!-- Try a very simple inline test first -->
    <script>
      try {
        const root = document.getElementById('root');
        if (root) {
          root.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Inline Script Works!</h1><p>JavaScript is executing on iPhone!</p></div>';
        } else {
        }
      } catch (e) {
      }
    </script>
    
    <!-- Try regular script (not module) -->
    <script>
      
      try {
        const rootElement = document.getElementById('root');
        if (rootElement) {
          rootElement.innerHTML = '<div style="padding: 20px; color: green; font-family: Arial, sans-serif;"><h1>‚úÖ Regular Script Works!</h1><p>This proves regular JavaScript works on iOS Safari.</p><p>Now loading bundled React app...</p></div>';
        }
      } catch (error) {
      }
    </script>
    
    <!-- iOS Safari Compatible Cleaning Photo App -->
    <script>
      
      // Simple photo documentation app
      class CleaningPhotoApp {
        constructor() {
          this.photos = [];
          this.currentRoom = 'kitchen';
          this.currentTab = 'photo';
          this.isLandscape = false;
          this.currentTemplate = 'default'; // Default template for all photos
          this.currentBeforeZoom = 1; // Initialize default zoom level
          this.currentAspectRatio = '4:3'; // Initialize aspect ratio
          this.loadPhotos(); // Load photos first
          this.init();
        }
        
        init() {
          // Check if user is signed in (has URL parameters or stored data)
          const urlParams = new URLSearchParams(window.location.search);
          let cleaner = urlParams.get('cleaner');
          let location = urlParams.get('location');
          
          // If no URL params, check localStorage for stored user data
          if (!cleaner || !location) {
            const storedUserData = this.getStoredUserData();
            if (storedUserData.cleaner && storedUserData.location) {
              // Auto-login with stored data
              cleaner = storedUserData.cleaner;
              location = storedUserData.location;
              
              // Update URL with stored data (optional - for consistency)
              const newUrl = `${window.location.origin}${window.location.pathname}?cleaner=${encodeURIComponent(cleaner)}&location=${encodeURIComponent(location)}`;
              window.history.replaceState({ cleaner, location }, '', newUrl);
            }
          }
          
          if (!cleaner || !location) {
            // Show sign-in screen
            this.showSignInScreen();
          } else {
            // User is signed in, show main app
            this.showMainApp();
          }
        }

        showMainApp() {
          // Check orientation
          this.checkOrientation();

          // Reassign photo names to ensure proper sequential numbering
          this.reassignPhotoNames();

          const rootElement = document.getElementById('root');
          if (rootElement) {
            rootElement.innerHTML = this.getAppHTML();

            // Verify header was created
            setTimeout(() => {
              const headerUploadBtn = document.getElementById('header-upload-btn');
            }, 10);

            this.attachEventListeners();
            this.updateTabsCarousel(); // Update carousel layout

            // Ensure bottom panel is hidden in gallery mode
            this.hideActionButtons();

            // Ensure room tab listeners are attached with a small delay
            setTimeout(() => {
              this.attachRoomTabListeners();
            }, 50);

            // BACKUP: Also try a more direct approach after a longer delay
            setTimeout(() => {
              document.querySelectorAll('#tabs-carousel .room-tab').forEach((btn, i) => {
                btn.onclick = (e) => {
                  const room = btn.dataset.room;
                  if (room && room !== this.currentRoom) {
                    this.currentRoom = room;
                    this.currentTab = 'photo';
                    const photosContainer = document.getElementById('photos-container');
                    if (photosContainer) {
                      photosContainer.innerHTML = this.getPhotosHTML();
                      this.attachPhotoListeners();
                    }
                    setTimeout(() => {
                      this.updateTabsCarousel();
                    }, 100);
                  }
                };
              });
            }, 200);

            // Auto-scroll to bottom after app initialization
            setTimeout(() => {
              const mainScrollableContent = document.getElementById('main-scrollable-content');
              if (mainScrollableContent) {
                mainScrollableContent.scrollTop = mainScrollableContent.scrollHeight;
              }
            }, 300);
          }
          
          // Listen for orientation changes
          window.addEventListener('orientationchange', () => {
            setTimeout(() => {
              this.checkOrientation();
              this.init();
            }, 100);
          });
          
          window.addEventListener('resize', () => {
            // Update orientation detection
            const wasLandscape = this.isLandscape;
            this.checkOrientation();
            
            // If orientation changed, update grids
            if (wasLandscape !== this.isLandscape) {
              setTimeout(() => {
                this.updateGridsOnOrientationChange();
              }, 100); // Small delay to ensure layout is stable
            }
            
            this.init();
          });

          // Add scroll listener for auto tab switching
          this.addScrollListener();
        }

        showSignInScreen() {
          console.log('Showing sign-in screen...');
          
          const rootElement = document.getElementById('root');
          if (rootElement) {
            rootElement.innerHTML = this.getSignInHTML();
            this.attachSignInListeners();
            this.populateStoredUserData();
          }
        }

        populateStoredUserData() {
          const storedData = this.getStoredUserData();
          if (storedData.cleaner || storedData.location) {
            const nameInput = document.getElementById('signin-name');
            const cityInput = document.getElementById('signin-city');
            const clearDataContainer = document.getElementById('clear-data-container');
            
            if (nameInput && storedData.cleaner) {
              nameInput.value = storedData.cleaner;
            }
            
            if (cityInput && storedData.location) {
              cityInput.value = storedData.location;
            }
            
            // Show the clear data button if we populated any data
            if (clearDataContainer) {
              clearDataContainer.style.display = 'block';
            }
            
            // Add event listener for clear data button
            const clearDataBtn = document.getElementById('clear-data-btn');
            if (clearDataBtn) {
              clearDataBtn.addEventListener('click', () => {
                this.showClearDataWarning(nameInput, cityInput, clearDataContainer);
              });
            }
          }
        }

        getSignInHTML() {
          return `
            <div style="min-height: 100vh; background: #F2C31B; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; font-family: 'Quicksand', sans-serif;">
              
              <!-- Logo -->
              <div style="margin-bottom: 40px; text-align: center;">
                <img src="/icons/proofpixwhite.png" alt="ProofPix" style="width: 400px; height: auto;">
              </div>
              
              <!-- Sign In Form -->
              <form id="signin-form" style="width: 100%; max-width: 300px; display: flex; flex-direction: column; gap: 20px;">
                
                <!-- Name Input -->
                <input type="text" id="signin-name" required style="width: 100%; padding: 16px; border: none; border-radius: 8px; font-size: 16px; background: #ffffff; color: #333333; box-sizing: border-box; font-family: 'Quicksand', sans-serif;" placeholder="Enter your name">

                <!-- City Selection -->
                <select id="signin-city" required style="width: 100%; padding: 16px; border: none; border-radius: 8px; font-size: 16px; background: #ffffff; color: #333333; box-sizing: border-box; font-family: 'Quicksand', sans-serif;">
                  <option value="">Choose your city...</option>
                  <option value="tampa">Tampa</option>
                  <option value="st-petersburg">St. Petersburg</option>
                  <option value="jacksonville">Jacksonville</option>
                  <option value="miami">Miami</option>
                </select>

                <!-- Start Button -->
                <button type="submit" id="signin-btn" style="width: 100%; background: #000000 !important; background-color: #000000 !important; color: #ffffff !important; border: none !important; padding: 16px; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.2s; font-family: 'Quicksand', sans-serif; margin-top: 20px; position: relative; z-index: 100; box-shadow: none !important; outline: none !important; opacity: 1 !important;" onmouseover="this.style.background='#333333' !important; this.style.backgroundColor='#333333' !important; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='#000000' !important; this.style.backgroundColor='#000000' !important; this.style.transform='translateY(0)'">
                  Start
                </button>
                
                <!-- Clear stored data link (if data exists) -->
                <div id="clear-data-container" style="margin-top: 16px; text-align: center; display: none;">
                  <button type="button" id="clear-data-btn" style="background: none; border: none; color: #ffffff; font-size: 14px; cursor: pointer; text-decoration: underline;">
                    üîÑ Use different name/location
                  </button>
                  </div>
                </form>
            </div>
          `;
        }

        attachSignInListeners() {
          const form = document.getElementById('signin-form');
          const nameInput = document.getElementById('signin-name');
          const cityInput = document.getElementById('signin-city');
          const signInBtn = document.getElementById('signin-btn');

          // Form submission
          form.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleSignIn();
          });

          // Real-time validation
          const validateForm = () => {
            const name = nameInput.value.trim();
            const city = cityInput.value.trim();
            
            if (name && city) {
              signInBtn.disabled = false;
              signInBtn.style.cursor = 'pointer';
            } else {
              signInBtn.disabled = true;
              signInBtn.style.cursor = 'not-allowed';
            }
          };

          nameInput.addEventListener('input', validateForm);
          cityInput.addEventListener('change', validateForm);

          // Initial validation
          validateForm();

          // Focus on name input
          setTimeout(() => {
            nameInput.focus();
          }, 100);
        }

        handleSignIn() {
          const name = document.getElementById('signin-name').value.trim();
          const city = document.getElementById('signin-city').value.trim();

          if (!name || !city) {
            alert('Please enter your name and city');
            return;
          }

          // Validate name (basic validation)
          if (name.length < 2) {
            alert('Please enter a valid name (at least 2 characters)');
            return;
          }

          // Save user data to localStorage for future use
          this.saveUserData(name, city);

          // Update URL with parameters and reload
          const newUrl = `${window.location.origin}${window.location.pathname}?cleaner=${encodeURIComponent(name)}&location=${encodeURIComponent(city)}`;
          window.location.href = newUrl;
        }
        
        checkOrientation() {
          this.isLandscape = window.innerWidth > window.innerHeight;
        }

        detectPhotoOrientation(width, height) {
          // Detect if a photo is landscape or portrait based on its dimensions
          if (width > height) {
            return 'Landscape';
          } else if (height > width) {
            return 'Portrait';
          } else {
            return 'Square';
          }
        }

        getTemplateSizes() {
          // Template sizes based on mode (stack vs side-by-side) and target formats
          return {
            // Stack Mode Templates (horizontal originals ‚Üí stacked vertically)
            'stack-portrait': {
              width: 1080,
              height: 1350,
              ratio: '4:5',
              combinedRatio: '2:3',
              splitType: 'horizontal-line',
              description: 'Instagram/LinkedIn Portrait (4:5)',
              cropInfo: 'Best fit for portrait feeds'
            },
            'stack-square': {
              width: 1080,
              height: 1080,
              ratio: '1:1',
              combinedRatio: '2:3',
              splitType: 'horizontal-line',
              description: 'Square (1:1)',
              cropInfo: '~15% top/bottom crop'
            },
            'stack-landscape': {
              width: 1920,
              height: 1080,
              ratio: '16:9',
              combinedRatio: '2:3',
              splitType: 'horizontal-line',
              description: 'Landscape Wide (16:9)',
              cropInfo: 'Significant crop - less ideal'
            },

            // Side-by-Side Mode Templates (vertical originals ‚Üí placed left-right)
            'sidebyside-landscape': {
              width: 1200,
              height: 630,
              ratio: '1.91:1',
              combinedRatio: '3:2',
              splitType: 'vertical-line',
              description: 'Instagram/Facebook Landscape (1.91:1)',
              cropInfo: 'Best fit for landscape feeds'
            },
            'sidebyside-wide': {
              width: 1920,
              height: 1080,
              ratio: '16:9',
              combinedRatio: '3:2',
              splitType: 'vertical-line',
              description: 'Wide Landscape (16:9)',
              cropInfo: 'Great for presentations/websites'
            },
            'sidebyside-square': {
              width: 1080,
              height: 1080,
              ratio: '1:1',
              combinedRatio: '3:2',
              splitType: 'vertical-line',
              description: 'Square (1:1)',
              cropInfo: '~15% left/right crop'
            },
            'sidebyside-portrait': {
              width: 1080,
              height: 1350,
              ratio: '4:5',
              combinedRatio: '3:2',
              splitType: 'vertical-line',
              description: 'Portrait (4:5)',
              cropInfo: 'Heavy crop - vertical split'
            }
          };
        }

        calculatePhotoCropDimensions(width, height, templateType, orientation) {
          // Simple fallback for crop dimensions
          return {
            cropX: 0,
            cropY: 0,
            cropWidth: width,
            cropHeight: height,
            targetWidth: width,
            targetHeight: height
          };
        }

        drawHorizontalSplit(ctx, beforeImg, afterImg, templateDimensions) {
          // Horizontal Split: Stack Mode - before image on top, after image on bottom (horizontal line between them)
          // Used for horizontal originals (4:3) stacked vertically
          // Combined photo fills the entire template canvas - no white bars

          const halfHeight = templateDimensions.targetHeight / 2;

          console.log(`üé® EXECUTING drawHorizontalSplit (Stack Mode):`);
          console.log(`  - Canvas size: ${templateDimensions.targetWidth}x${templateDimensions.targetHeight}`);
          console.log(`  - Half height: ${halfHeight}`);
          console.log(`  - Before image: ${beforeImg.width}x${beforeImg.height} ‚Üí placed at top (0,0,${templateDimensions.targetWidth},${halfHeight})`);
          console.log(`  - After image: ${afterImg.width}x${afterImg.height} ‚Üí placed at bottom (0,${halfHeight},${templateDimensions.targetWidth},${halfHeight})`);
          console.log(`  - Horizontal line drawn at y=${halfHeight}`);

          // Draw before image (top half) - crop from original image to fill exactly
          this.drawImageWithProperCrop(ctx, beforeImg, 0, 0, templateDimensions.targetWidth, halfHeight);

          // Draw after image (bottom half) - crop from original image to fill exactly
          this.drawImageWithProperCrop(ctx, afterImg, 0, halfHeight, templateDimensions.targetWidth, halfHeight);

          // Draw horizontal divider line (separating top and bottom)
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, halfHeight);
          ctx.lineTo(templateDimensions.targetWidth, halfHeight);
          ctx.stroke();
        }

        drawVerticalSplit(ctx, beforeImg, afterImg, templateDimensions) {
          // Vertical Split: Side-by-Side Mode - before image on left, after image on right (vertical line between them)
          // Used for vertical originals (2:3) placed side-by-side
          // Combined photo fills the entire template canvas - no white bars

          const halfWidth = templateDimensions.targetWidth / 2;

          console.log(`üé® EXECUTING drawVerticalSplit (Side-by-Side Mode):`);
          console.log(`  - Canvas size: ${templateDimensions.targetWidth}x${templateDimensions.targetHeight}`);
          console.log(`  - Half width: ${halfWidth}`);
          console.log(`  - Before image: ${beforeImg.width}x${beforeImg.height} ‚Üí placed at left (0,0,${halfWidth},${templateDimensions.targetHeight})`);
          console.log(`  - After image: ${afterImg.width}x${afterImg.height} ‚Üí placed at right (${halfWidth},0,${halfWidth},${templateDimensions.targetHeight})`);
          console.log(`  - Vertical line drawn at x=${halfWidth}`);

          // Draw before image (left half) - crop from original image to fill exactly
          this.drawImageWithProperCrop(ctx, beforeImg, 0, 0, halfWidth, templateDimensions.targetHeight);

          // Draw after image (right half) - crop from original image to fill exactly
          this.drawImageWithProperCrop(ctx, afterImg, halfWidth, 0, halfWidth, templateDimensions.targetHeight);

          // Draw vertical divider line (separating left and right)
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(halfWidth, 0);
          ctx.lineTo(halfWidth, templateDimensions.targetHeight);
          ctx.stroke();
        }

        drawImageWithProperCrop(ctx, img, canvasX, canvasY, canvasWidth, canvasHeight) {
          // Calculate the aspect ratios
          const imageAspectRatio = img.width / img.height;
          const targetAspectRatio = canvasWidth / canvasHeight;

          let sourceX, sourceY, sourceWidth, sourceHeight;

          if (imageAspectRatio > targetAspectRatio) {
            // Image is wider than target - crop horizontally (center crop)
            sourceHeight = img.height;
            sourceWidth = img.height * targetAspectRatio;
            sourceX = (img.width - sourceWidth) / 2; // Center horizontally
            sourceY = 0;
          } else {
            // Image is taller than target - crop vertically (center crop)
            sourceWidth = img.width;
            sourceHeight = img.width / targetAspectRatio;
            sourceX = 0;
            sourceY = (img.height - sourceHeight) / 2; // Center vertically
          }

          // Draw the cropped portion of the image to fill the target area exactly
          ctx.drawImage(
            img,
            sourceX, sourceY, sourceWidth, sourceHeight, // Source rectangle (what to crop from image)
            canvasX, canvasY, canvasWidth, canvasHeight   // Destination rectangle (where to draw on canvas)
          );

          console.log(`üñºÔ∏è Image crop: source(${sourceX},${sourceY},${sourceWidth.toFixed(1)},${sourceHeight.toFixed(1)}) from ${img.width}x${img.height} ‚Üí canvas(${canvasX},${canvasY},${canvasWidth},${canvasHeight})`);
        }

        getStackModeCropInfo(targetRatio) {
          // Stack Mode (2:3 combined) crop rules from formats.md
          switch(targetRatio) {
            case '1:1':
              return {
                heightCropPercent: 0.15, // ~15% total height
                widthCropPercent: 0.0,
                method: 'Crop top/bottom ~7.5% each'
              };
            case '4:5':
              return {
                heightCropPercent: 0.07, // ~7% total height
                widthCropPercent: 0.0,
                method: 'Crop top/bottom ~3.5% each'
              };
            case '16:9':
              return {
                heightCropPercent: 0.0,
                widthCropPercent: 0.50, // ~50% width
                method: 'Crop sides heavily ~25% each'
              };
            default:
              return {
                heightCropPercent: 0.07,
                widthCropPercent: 0.0,
                method: 'Default: minimal crop'
              };
          }
        }

        getSideBySideModeCropInfo(targetRatio) {
          // Side-by-Side Mode (3:2 combined) crop rules from formats.md
          switch(targetRatio) {
            case '1:1':
              return {
                widthCropPercent: 0.15, // ~15% total width
                heightCropPercent: 0.0,
                method: 'Crop left/right ~7.5% each'
              };
            case '4:5':
              return {
                widthCropPercent: 0.125, // ~10-15% width
                heightCropPercent: 0.03, // <5% height
                method: 'Crop both axes proportionally'
              };
            case '16:9':
              return {
                widthCropPercent: 0.0,
                heightCropPercent: 0.05, // ~5% height or less
                method: 'Minimal crop - mostly fits'
              };
            case '1.91:1':
              return {
                widthCropPercent: 0.0,
                heightCropPercent: 0.02, // ~2% height
                method: 'Perfect fit - minimal crop'
              };
            default:
              return {
                widthCropPercent: 0.0,
                heightCropPercent: 0.05,
                method: 'Default: minimal crop'
              };
          }
        }

        addPhotoLabels(ctx, canvasWidth, canvasHeight, splitType) {
          // Add "BEFORE" and "AFTER" labels
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          if (splitType === 'vertical') {
            // Horizontal Split (vertical splitType): Stack Mode - labels at top-center and bottom-center
            const quarterHeight = canvasHeight / 4;

            // BEFORE label (top quarter)
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(canvasWidth/2 - 60, quarterHeight - 15, 120, 30);
            ctx.fillStyle = 'white';
            ctx.fillText('BEFORE', canvasWidth/2, quarterHeight);

            // AFTER label (bottom quarter)
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(canvasWidth/2 - 60, (quarterHeight * 3) - 15, 120, 30);
            ctx.fillStyle = 'white';
            ctx.fillText('AFTER', canvasWidth/2, quarterHeight * 3);
          } else {
            // Vertical Split (horizontal splitType): Side-by-Side Mode - labels at left-center and right-center
            const quarterWidth = canvasWidth / 4;

            // BEFORE label (left quarter)
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(quarterWidth - 60, canvasHeight/2 - 15, 120, 30);
            ctx.fillStyle = 'white';
            ctx.fillText('BEFORE', quarterWidth, canvasHeight/2);

            // AFTER label (right quarter)
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect((quarterWidth * 3) - 60, canvasHeight/2 - 15, 120, 30);
            ctx.fillStyle = 'white';
            ctx.fillText('AFTER', quarterWidth * 3, canvasHeight/2);
          }
        }
        
        getCameraModalHTML() {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <!-- Landscape camera - left/right split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Active camera -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: contain;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div class="photo-frame-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                    <!-- Dynamic overlay will be inserted here -->
                  </div>
                  
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Reference or inactive -->
                <div style="position: relative; width: 50%; height: 100%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls on the left</div>
                  </div>
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top/bottom split
            return `
              <!-- Portrait camera - top/bottom split -->
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Active camera -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: contain;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div class="photo-frame-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                    <!-- Dynamic overlay will be inserted here -->
                  </div>
                  
                  
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - Reference or inactive -->
                <div style="position: relative; width: 100%; height: 50%; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center; color: #B3B3B3;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üì∑</div>
                    <div style="font-size: 16px; font-weight: bold;">Camera Active</div>
                    <div style="font-size: 14px; margin-top: 5px;">Take your photo using the controls above</div>
                  </div>
                </div>
                
                <!-- Close button -->
                <button id="close-camera-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getBeforePhotoModalHTML() {
          if (this.isLandscape) {
            // Landscape mode - left (camera) and right (existing photos)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top section - Camera and Photos -->
                <div style="position: relative; width: 100%; height: calc(100% - 80px); display: flex; flex-direction: row;">
                  <!-- Left half - Camera -->
                  <div id="camera-container" style="position: relative; width: 50%; height: 100%; background: black;">
                    <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: contain;"></video>
                    
                    <!-- Photo frame overlay for camera -->
                    <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
                      <div style="width: 90%; height: 90%; border: 3px solid rgba(255,255,255,0.8); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
                    </div>
                    
                    <!-- Before label -->
                    <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                      BEFORE
                    </div>
                    
                    <!-- Zoom controls -->
                    <div id="zoom-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: rgba(0,0,0,0.7); border-radius: 25px; padding: 8px; backdrop-filter: blur(10px);">
                      <button class="zoom-btn" data-zoom="0.5" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">0.5x</button>
                      <button class="zoom-btn active" data-zoom="1" style="background: #F2C31B; color: #303030; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">1x</button>
                      <button class="zoom-btn" data-zoom="2" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">2x</button>
                    </div>

                    
                    <!-- Close button - positioned within camera view -->
                    <button id="close-before-modal-btn" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 10; backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center;">
                      ‚úï
                    </button>
                  </div>
                  
                  <!-- Divider line -->
                  <div style="width: 4px; height: 100%; background: #000;"></div>
                  
                  <!-- Right half - Photo Grid Only -->
                  <div style="position: relative; width: calc(50% - 80px); height: 100%; background: #f8f9fa; overflow-y: auto; padding: 10px; padding-bottom: 15px;">
                    ${this.getBeforePhotosGridHTML()}
                  </div>
                </div>
                
                <!-- Bottom section - Room Tabs (spanning full width) -->
                <div style="position: relative; width: 100%; height: 80px; background: #f8fafc; padding: 10px; box-shadow: 0 -2px 8px rgba(0,0,0,0.1); display: flex; justify-content: center; align-items: center;">
                  <div id="modal-room-tabs-container" style="position: relative; width: 100%; height: 60px; overflow: hidden;">
                    <div id="modal-tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                      ${this.getRoomTabsCarousel()}
                    </div>
                  </div>
                </div>
              </div>
            `;
          } else {
            // Portrait mode - top (camera) and bottom (existing photos)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Upper half - Camera -->
                <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black; display: flex; align-items: center; justify-content: center;">
                  <video id="camera-video" autoplay muted playsinline style="width: 100%; height: 100%;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div class="photo-frame-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                    <!-- Dynamic overlay will be inserted here -->
                  </div>
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                  
                  <!-- Zoom controls for portrait mode - HIDDEN FOR TEST -->
                  <div id="zoom-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; gap: 8px; background: rgba(0,0,0,0.7); border-radius: 25px; padding: 8px; backdrop-filter: blur(10px);">
                    <button class="zoom-btn" data-zoom="0.5" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">0.5x</button>
                    <button class="zoom-btn active" data-zoom="1" style="background: #F2C31B; color: #303030; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">1x</button>
                    <button class="zoom-btn" data-zoom="2" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">2x</button>
                  </div>

                </div>
                
                <!-- Room Tabs Section - HIDDEN FOR TEST -->
                <div style="width: 100%; background: #f8fafc; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: none;">
                  <div id="modal-room-tabs-container" style="position: relative; width: 100%; height: 60px; overflow: hidden;">
                    <div id="modal-tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                      ${this.getRoomTabsCarousel()}
                    </div>
                  </div>
                </div>

                <!-- Bottom half - Photo Grid with black bars for symmetry -->
                <div style="width: 100%; height: 50%; background: black; display: flex; align-items: center; justify-content: center;">
                  <div id="before-photo-grid" style="width: 100%; height: 100%; background: #f8f9fa; overflow-y: auto; padding: 10px; padding-bottom: 15px;">
                    ${this.getBeforePhotosGridHTML()}
                  </div>
                </div>

                <!-- Close button -->
                <button id="close-before-modal-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }

        getBeforePhotosGridHTML() {
          // Device/platform debugging
          const userAgent = navigator.userAgent;
          const isIPhone = /iPhone|iPad|iPod/.test(userAgent);
          const isAndroid = /Android/.test(userAgent);
          const isMobile = isIPhone || isAndroid;

          console.log(`üì± Device Info: iPhone=${isIPhone}, Android=${isAndroid}, Mobile=${isMobile}`);
          console.log(`üì± User Agent: ${userAgent}`);

          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for current room
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp);

          // Create grid layout with all photos and dummy squares
          const gridItems = [];
          
          // Add all existing photos
          beforePhotos.forEach(photo => {
            // Determine object-fit based on photo's original aspect ratio
            // 4:3 aspect ratio (horizontal/landscape mode) - image is wider, center it with side gaps
            // 2:3 aspect ratio (vertical/portrait mode) - image is taller, center it with top/bottom gaps
            const objectFit = (photo.aspectRatio === '4:3') ? 'contain' : 'contain';

            console.log(`üñºÔ∏è Thumbnail for photo ${photo.id}: aspectRatio=${photo.aspectRatio}, objectFit=${objectFit}`);

            gridItems.push(`
              <div class="before-photo-item" data-photo-id="${photo.id}" style="aspect-ratio: 1; border-radius: 8px; overflow: hidden; position: relative; cursor: pointer; border: 2px solid #e1e5e9; transition: all 0.2s;" onmouseover="this.style.borderColor='#F2C31B'; this.style.transform='scale(1.02)'" onmouseout="this.style.borderColor='#e1e5e9'; this.style.transform='scale(1)'">
                <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: ${objectFit};" />

                <!-- Delete button -->
                <button class="delete-before-photo-btn" data-photo-id="${photo.id}" style="position: absolute; top: 5px; right: 5px; background: #F2C31B; color: #303030; border: none; padding: 6px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#e6b800'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='#F2C31B'; this.style.transform='scale(1)'">
                  √ó
                </button>
                
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 8px; color: white;">
                  <div style="font-size: 12px; font-weight: bold; font-family: 'Quicksand', sans-serif;">${photo.name}</div>
                  <div style="font-size: 10px; opacity: 0.9; font-family: 'Quicksand', sans-serif;">${new Date(photo.timestamp).toLocaleTimeString()}</div>
                </div>
              </div>
            `);
          });
          
          // Add one dummy square for taking more photos
          gridItems.push(`
            <div class="dummy-before-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; color: #999; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e8e8e8'; this.style.color='#666';" onmouseout="this.style.background='#f0f0f0'; this.style.color='#999';">
              ${roomIcons[this.currentRoom] || 'üì∑'}
            </div>
          `);

          return `
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; grid-auto-rows: minmax(100px, auto); align-content: start; width: 100%; height: auto;">
              ${gridItems.join('')}
            </div>
          `;
        }

        getComparisonModalHTML(photo) {
          if (this.isLandscape) {
            // Landscape mode - left (before photo) and right (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Before label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - Camera -->
                <div id="camera-container" style="position: relative; width: 50%; height: 100%; background: black;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: contain;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div class="photo-frame-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                    <!-- Dynamic overlay will be inserted here -->
                  </div>
                  
                  <!-- After label -->
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold;">
                    AFTER
                  </div>
                  
                  <!-- Zoom controls -->
                  <div id="zoom-controls-comparison" style="position: absolute; top: 60px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: rgba(0,0,0,0.7); border-radius: 25px; padding: 8px; backdrop-filter: blur(10px);">
                    <button class="zoom-btn-comparison" data-zoom="0.5" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">0.5x</button>
                    <button class="zoom-btn-comparison active" data-zoom="1" style="background: #F2C31B; color: #303030; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">1x</button>
                    <button class="zoom-btn-comparison" data-zoom="2" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">2x</button>
                  </div>

                  
                  <!-- Close button -->
                  <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 99999; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                    ‚úï
                  </button>
                </div>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (camera)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black;">
                  <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />

                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px; text-align: center; color: white;">
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - BEFORE
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                </div>

                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>

                <!-- Upper half - Camera -->
                <div id="camera-container" style="position: relative; width: 100%; height: 50%; background: black; display: flex; align-items: center; justify-content: center;">
                  <video id="comparison-camera" autoplay muted playsinline style="width: 100%; height: 100%; object-fit: contain;"></video>
                  
                  <!-- Photo frame overlay for camera -->
                  <div class="photo-frame-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                    <!-- Dynamic overlay will be inserted here -->
                  </div>
                  
                  <!-- Zoom controls for portrait mode comparison -->
                  <div id="zoom-controls-comparison" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: rgba(0,0,0,0.7); border-radius: 25px; padding: 8px; backdrop-filter: blur(10px);">
                    <button class="zoom-btn-comparison" data-zoom="0.5" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">0.5x</button>
                    <button class="zoom-btn-comparison active" data-zoom="1" style="background: #F2C31B; color: #303030; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">1x</button>
                    <button class="zoom-btn-comparison" data-zoom="2" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 12px; border-radius: 18px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.2s;">2x</button>
                  </div>


                </div>

                <!-- Close button -->
                <button id="close-comparison-btn" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 9999; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room) {
          if (this.isLandscape) {
            // Landscape mode - left (before) and right (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: row; background: white;">
                <!-- Left half - Before photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                  <div style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 4px; height: 100%; background: #000;"></div>
                
                <!-- Right half - After photo -->
                <div style="position: relative; width: 50%; height: 100%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                  <div style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          } else {
            // Portrait mode - top (before) and bottom (after)
            return `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; background: white;">
                <!-- Top half - Before photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    BEFORE
                  </div>
                </div>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 4px; background: #000;"></div>
                
                <!-- Bottom half - After photo -->
                <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                  <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                  <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                    AFTER
                  </div>
                </div>
                
                
                <!-- Close button -->
                <button id="close-split-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                  ‚úï
                </button>
              </div>
            `;
          }
        }
        
        getAppHTML() {
          // Get cleaner name from URL parameter
          const urlParams = new URLSearchParams(window.location.search);
          const currentCleaner = urlParams.get('cleaner') || 'Kate';
          
          return `
            <div style="min-height: 100vh; background: #f8fafc; font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif; display: flex; flex-direction: column; overflow-x: hidden;">
              <!-- Fixed Header -->
              <div style="position: fixed; top: 0; left: 0; right: 0; z-index: 200; background: #F2C31B; color: #303030; padding: 4px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; max-width: 100vw; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <!-- Left side - All Photos button -->
                <button id="all-photos-btn" style="background: white; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold;">
                  üì∑ All Photos
                </button>

                <!-- Center - Cleaner name with change user option -->
                <div style="display: flex; align-items: center; gap: 8px;">
                  <div style="font-size: 16px; font-weight: bold; font-family: 'Quicksand', sans-serif;">${currentCleaner}</div>
                  <button id="change-user-btn" style="background: none; border: none; color: #666; font-size: 12px; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s;" title="Change User" onmouseover="this.style.background='rgba(0,0,0,0.1)'; this.style.color='#303030'" onmouseout="this.style.background='none'; this.style.color='#666'">
                    üë§
                  </button>
                </div>

                <!-- Right side - Upload button -->
                <button id="header-upload-btn" style="background: #303030; color: #F2C31B; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold;">
                  üì§ Upload
                </button>
              </div>

              <!-- Fixed Room Tabs (at bottom) -->
              <div id="sticky-tabs-container" style="position: fixed; ${this.isLandscape ? 'bottom: 0; left: 0; right: 0; z-index: 100; background: #f8fafc; padding: 10px; width: 100vw; box-sizing: border-box; display: flex; justify-content: center; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);' : 'bottom: 0; left: 0; right: 0; z-index: 100; background: #f8fafc; padding: 10px; width: 100vw; box-sizing: border-box; display: flex; justify-content: center; box-shadow: 0 -2px 8px rgba(0,0,0,0.1);'}">
                <div id="room-tabs-container" style="position: relative; ${this.isLandscape ? 'width: 100vw; height: 60px;' : 'width: 100vw; height: 60px;'} overflow: hidden;">
                  <div id="tabs-carousel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease;">
                    ${this.getRoomTabsCarousel()}
                  </div>
                </div>
              </div>
              
              <!-- Scrollable Content -->
              <div id="main-scrollable-content" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 60px 10px 95px 10px; width: 100%; max-width: 100vw; box-sizing: border-box;">
                
                <!-- Photos grid with swipe -->
                <div id="photos-container" style="display: grid; grid-template-columns: ${this.isLandscape ? 'repeat(5, 1fr)' : 'repeat(2, 1fr)'}; gap: 5px; padding: 0 10px; max-width: 100%; box-sizing: border-box;">
                  ${this.getPhotosHTML()}
                </div>
                
              </div>
              
              <!-- Fixed Action Buttons Panel (only for camera modals) -->
              <div id="bottom-panel" style="position: fixed; ${this.isLandscape ? 'right: 0; top: 0; bottom: 0; width: 80px; display: none; flex-direction: column; justify-content: center; align-items: center; gap: 20px; padding-top: 40px; padding-bottom: 40px;' : 'bottom: 0; left: 0; right: 0; display: none; grid-template-columns: 1fr 1fr 1fr; height: 80px; align-items: center;'} z-index: 2001; background: white; box-shadow: ${this.isLandscape ? '0 0 8px rgba(0,0,0,0.1)' : '0 -2px 8px rgba(0,0,0,0.1)'};">
                <!-- Left Section - Aspect Ratio Button (always visible during camera) -->
                <div style="display: flex; justify-content: center;">
                  <button id="aspect-ratio-btn" style="background: #F2C31B; color: #303030; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">2:3</button>
                </div>

                <!-- Center Section - Camera Button (main action button) -->
                <div style="display: flex; justify-content: center;">
                  <button id="camera-btn" style="background: #F2C31B; border: none; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; box-shadow: 0 4px 12px rgba(48,48,48,0.3); display: none;"></button>
                  <!-- Retake Button (replaces camera button after capture) -->
                  <button id="btn-retake" style="background: #ef4444; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üîÑ Retake
                  </button>
                </div>

                <!-- Right Section - Save Button (shown after capture) -->
                <div style="display: flex; justify-content: center;">
                  <button id="btn-save" style="background: #10b981; color: white; border: none; width: 50px; height: 50px; border-radius: 8px; font-size: 12px; cursor: pointer; font-weight: bold; display: none; align-items: center; justify-content: center;">
                    üíæ Save
                  </button>
                </div>
              </div>
              
            </div>
          `;
        }
        
        
        
        getRoomTabsCarousel() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          const currentIndex = rooms.indexOf(this.currentRoom);

          // Create extended array for infinite loop effect (3x the original)
          const extendedRooms = [...rooms, ...rooms, ...rooms];
          const centerIndex = rooms.length + currentIndex; // Middle set + current position

          return extendedRooms.map((room, index) => {
            const relativePosition = index - centerIndex;
            const distance = Math.abs(relativePosition);

            // Only show tabs that are close to center (within 2 positions)
            if (distance > 2) {
              return '';
            }

            // Calculate positioning with smaller gaps
            const isActive = relativePosition === 0;
            const translateX = relativePosition * 80; // Reduced from 120px to 80px
            const opacity = distance === 0 ? 1 : Math.max(0.5, 1 - (distance * 0.25));
            const scale = distance === 0 ? 1.1 : Math.max(0.85, 1 - (distance * 0.08));

            return `
              <button class="room-tab" data-room="${room}" data-position="${relativePosition}"
                      style="position: absolute;
                             left: 50%;
                             top: 50%;
                             transform: translate(-50%, -50%) translateX(${translateX}px) scale(${scale});
                             padding: 10px 14px;
                             border: none;
                             border-radius: 12px;
                             font-size: ${isActive ? '15px' : '13px'};
                             cursor: pointer;
                             background: ${isActive ? '#F2C31B' : 'rgba(225,225,225,0.9)'};
                             color: ${isActive ? '#303030' : '#666'};
                             transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                             opacity: ${opacity};
                             white-space: nowrap;
                             z-index: ${10 - distance};
                             font-weight: ${isActive ? '600' : '400'};
                             box-shadow: ${isActive ? '0 4px 12px rgba(242,195,27,0.3)' : '0 2px 4px rgba(0,0,0,0.1)'};
                             letter-spacing: ${isActive ? '0.5px' : '0px'};">
                ${room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ')}
              </button>
            `;
          }).filter(tab => tab !== '').join('');
        }
        
        getAllPhotosHTML() {
          
          // Room icons for display
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Debug: Check all photos first

          // Get all stored photos (before, after, and combined/mix photos)
          const allPhotos = this.photos
            .filter(photo => {
              // Include before photos
              if (photo.mode === 'before') return true;
              
              // Include after photos
              if (photo.mode === 'after') return true;
              
              // Include archived photos
              if (photo.mode === 'archived') return true;
              
              // Include mix/combined photos
              if (photo.mode === 'mix') return true;
              
              return false;
            });


          // Group photos by room and organize them: before, after, combined
          // Handle multiple photos of the same type by grouping them by name/sequence
          const photosByRoomAndName = {};
          allPhotos.forEach(photo => {
            if (!photosByRoomAndName[photo.room]) {
              photosByRoomAndName[photo.room] = {};
            }
            
            // For combined photos with long names, try to match them to the correct before/after set
            let photoKey = photo.name;
            
            if (photo.mode === 'mix' && photo.name.includes('_Combined_')) {
              // Try to find matching before/after photos by timestamp proximity
              const beforePhotos = allPhotos.filter(p => p.mode === 'before' && p.room === photo.room);
              const afterPhotos = allPhotos.filter(p => p.mode === 'after' && p.room === photo.room);
              
              // Find the closest timestamp match
              let closestMatch = null;
              let minTimeDiff = Infinity;
              
              [...beforePhotos, ...afterPhotos].forEach(matchPhoto => {
                const timeDiff = Math.abs(photo.timestamp - matchPhoto.timestamp);
                if (timeDiff < minTimeDiff && timeDiff < 60000) { // Within 1 minute
                  minTimeDiff = timeDiff;
                  closestMatch = matchPhoto;
                }
              });
              
              if (closestMatch) {
                photoKey = closestMatch.name; // Use the matched photo's name
              }
            }
            
            if (!photosByRoomAndName[photo.room][photoKey]) {
              photosByRoomAndName[photo.room][photoKey] = {
                before: null,
                after: null,
                combined: null
              };
            }
            
            if (photo.mode === 'before' || photo.mode === 'archived') {
              photosByRoomAndName[photo.room][photoKey].before = photo;
            } else if (photo.mode === 'after') {
              photosByRoomAndName[photo.room][photoKey].after = photo;
            } else if (photo.mode === 'mix') {
              photosByRoomAndName[photo.room][photoKey].combined = photo;
            }
          });

          // Create ordered array: before, after, combined for each room and photo set
          // Sort photo sets by name to ensure consistent ordering (Kitchen 1, Kitchen 2, Kitchen 3)
          const orderedPhotos = [];
          Object.keys(photosByRoomAndName).forEach(room => {
            const roomPhotoSets = photosByRoomAndName[room];
            const sortedPhotoSetNames = Object.keys(roomPhotoSets).sort((a, b) => {
              // Extract numbers from names for proper sorting
              const aNum = parseInt(a.replace(/\D/g, '')) || 0;
              const bNum = parseInt(b.replace(/\D/g, '')) || 0;
              return aNum - bNum;
            });
            
            sortedPhotoSetNames.forEach(photoSetName => {
              const photoSet = roomPhotoSets[photoSetName];
              
              // Add before photo (or dummy if missing)
              if (photoSet.before) {
                orderedPhotos.push(photoSet.before);
              } else {
                orderedPhotos.push({ 
                  id: `dummy-before-${photoSetName}`, 
                  mode: 'dummy-before', 
                  room: room, 
                  name: photoSetName,
                  isDummy: true 
                });
              }
              
              // Add after photo (or dummy if missing)
              if (photoSet.after) {
                orderedPhotos.push(photoSet.after);
              } else {
                orderedPhotos.push({ 
                  id: `dummy-after-${photoSetName}`, 
                  mode: 'dummy-after', 
                  room: room, 
                  name: photoSetName,
                  isDummy: true 
                });
              }
              
              // Add combined photo (or dummy if missing)
              if (photoSet.combined) {
                orderedPhotos.push(photoSet.combined);
              } else {
                orderedPhotos.push({ 
                  id: `dummy-combined-${photoSetName}`, 
                  mode: 'dummy-combined', 
                  room: room, 
                  name: photoSetName,
                  isDummy: true 
                });
              }
            });
          });



          if (orderedPhotos.length === 0) {
            return `
              <div style="text-align: center; padding: 40px 20px; color: #666;">
                <div style="font-size: 48px; margin-bottom: 20px;">üì∑</div>
                <h3 style="margin: 0 0 10px 0; color: #303030;">No Photos Yet</h3>
                <p style="margin: 0; font-size: 14px;">Take some photos to see them here!</p>
              </div>
            `;
          }

          // Group photos by room for better organization
          const photosByRoom = {};
          orderedPhotos.forEach(photo => {
            if (!photosByRoom[photo.room]) {
              photosByRoom[photo.room] = [];
            }
            photosByRoom[photo.room].push(photo);
          });


          let html = '';
          
          // Display photos grouped by room
          Object.keys(photosByRoom).forEach(room => {
            const roomPhotos = photosByRoom[room];
            const actualPhotos = roomPhotos.filter(p => !p.isDummy); // Count only real photos
            const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
            const roomIcon = roomIcons[room] || 'üè†';
            
            
            html += `
              <div style="margin-bottom: 30px;">
                <h3 style="margin: 0 0 15px 0; padding: 0 10px; color: #303030; font-size: 18px; display: flex; align-items: center; justify-content: space-between;">
                  <span style="display: flex; align-items: center; gap: 8px;">${roomIcon} ${roomName} (${actualPhotos.length})</span>
                  <span style="font-size: 12px; color: #666; font-weight: normal;">
                    ${roomPhotos.length > 0 ? new Date(roomPhotos[0].timestamp).toLocaleDateString() : ''}
                  </span>
                </h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 0 10px;">
                  <div style="text-align: center; font-size: 12px; font-weight: bold; color: #F2C31B; padding: 5px;">BEFORE</div>
                  <div style="text-align: center; font-size: 12px; font-weight: bold; color: #3B82F6; padding: 5px;">AFTER</div>
                  <div style="text-align: center; font-size: 12px; font-weight: bold; color: #10B981; padding: 5px;">COMBINED</div>
            `;
            
            roomPhotos.forEach((photo, index) => {
              // For combined photos with long names, use the photo set name instead
              let displayName = photo.name || `${room} ${index + 1}`;
              
              if (photo.mode === 'mix' && photo.name.includes('_Combined_')) {
                // Extract the base name from the current photo set
                const currentPhotoSetName = roomPhotos.find(p => p.mode === 'before')?.name || 
                                          roomPhotos.find(p => p.mode === 'after')?.name;
                if (currentPhotoSetName) {
                  displayName = currentPhotoSetName;
                }
              }
              
              const photoIndex = photo.isDummy ? -1 : this.photos.indexOf(photo);
              
              // Handle dummy photos
              if (photo.isDummy) {
                let borderColor = '#E1E1E1';
                let photoLabel = '';
                let icon = 'üì∑';
                
                if (photo.mode === 'dummy-before') {
                  borderColor = '#F2C31B';
                  icon = 'üì∏';
                } else if (photo.mode === 'dummy-after') {
                  borderColor = '#3B82F6';
                  icon = 'üì∑';
                } else if (photo.mode === 'dummy-combined') {
                  borderColor = '#10B981';
                  icon = 'üîÑ';
                }
                
                html += `
                  <div class="dummy-card" data-room="${photo.room}" data-name="${photo.name}" data-mode="${photo.mode}" style="border: 2px dashed ${borderColor}; border-radius: 8px; overflow: hidden; position: relative; aspect-ratio: 1; background: #f8f9fa; display: flex; align-items: center; justify-content: center; opacity: 0.6; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.opacity='0.8'; this.style.background='#e9ecef';" onmouseout="this.style.opacity='0.6'; this.style.background='#f8f9fa';">
                    <div style="text-align: center; color: #666;">
                      <div style="font-size: 24px; margin-bottom: 8px;">${icon}</div>
                      <div style="font-size: 8px; color: #999;">Click to add</div>
                    </div>
                  </div>
                `;
                return;
              }
              
              if (photo.mode === 'after') {
                // After photo - show with blue border
                const borderColor = '#3B82F6';

                // Determine object-fit based on photo's original aspect ratio
                const objectFit = 'contain'; // Keep contain for proper display within square

                console.log(`üñºÔ∏è Main Gallery After Photo ${photo.id}: aspectRatio=${photo.aspectRatio}, objectFit=${objectFit}`);

                html += `
                  <div class="photo-item" data-photo-index="${photoIndex}" style="border: 2px solid ${borderColor}; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1; cursor: pointer;">
                    <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: ${objectFit};" />

                    <!-- Photo info -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 5px 8px; font-size: 10px;">
                      <div style="font-weight: bold; font-family: 'Quicksand', sans-serif;">${displayName}</div>
                    </div>
                  </div>
                `;
              } else {
                // Single photo (before, archived, or mix/combined)
                let borderColor = '#E1E1E1';
                let photoLabel = '';

                if (photo.mode === 'before') {
                  borderColor = '#F2C31B';
                } else if (photo.mode === 'mix') {
                  borderColor = '#10B981';
                } else if (photo.mode === 'archived') {
                  borderColor = '#6B7280';
                }

                // Determine object-fit based on photo's original aspect ratio
                const objectFit = 'contain'; // Keep contain for proper display within square

                console.log(`üñºÔ∏è Main Gallery Single Photo ${photo.id}: mode=${photo.mode}, aspectRatio=${photo.aspectRatio}, objectFit=${objectFit}`);

                html += `
                  <div class="photo-item" data-photo-index="${photoIndex}" style="border: 2px solid ${borderColor}; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1; cursor: pointer;">
                    <img src="${photo.dataUrl}" style="width: 100%; height: 100%; object-fit: ${objectFit};" />
                    
                    <!-- Photo info -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 5px 8px; font-size: 10px;">
                      <div style="font-weight: bold; font-family: 'Quicksand', sans-serif;">${displayName}</div>
                    </div>
                  </div>
                `;
              }
            });
            
            html += `
                </div>
              </div>
            `;
          });

          return html;
        }
        
        showAllPhotosModal() {
          // Clean up any existing modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2500"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2500;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
          `;

          modal.innerHTML = `
            <div style="
              width: 100%;
              max-width: 500px;
              height: 90vh;
              background: white;
              border-radius: 12px;
              display: flex;
              flex-direction: column;
              overflow: hidden;
              box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            ">
              <!-- Header -->
              <div style="
                padding: 20px;
                background: #F2C31B;
                color: #303030;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-shrink: 0;
              ">
                <h2 style="margin: 0; font-size: 20px; font-weight: bold;">üì∑ All Photos</h2>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                  <button id="delete-all-photos-btn" style="
                    background: #dc2626;
                    color: white;
                    border: none;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    font-weight: bold;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    transition: background 0.2s;
                  " onmouseover="this.style.background='#b91c1c'" onmouseout="this.style.background='#dc2626'">
                    üóëÔ∏è Delete All
                  </button>
                  
                  <button id="close-all-photos-modal" style="
                    background: transparent;
                    border: none;
                    color: #303030;
                    font-size: 24px;
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 50%;
                    width: 35px;
                    height: 35px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                  ">√ó</button>
                </div>
              </div>
              
              <!-- Scrollable content -->
              <div id="all-photos-content" style="
                flex: 1;
                overflow-y: auto;
                padding: 20px;
                background: #f8f9fa;
              ">
                ${this.getAllPhotosHTML()}
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Prevent background scrolling
          document.body.style.overflow = 'hidden';

          // Add event listeners
          document.getElementById('close-all-photos-modal').addEventListener('click', () => {
            this.closeAllPhotosModal(modal);
          });

          // Delete All button functionality
          document.getElementById('delete-all-photos-btn').addEventListener('click', () => {
            // Close the gallery modal first
            this.closeAllPhotosModal(modal);
            
            // Show the delete all confirmation (same as upload button)
            setTimeout(() => {
              this.showDeleteAllConfirmation();
            }, 100);
          });


          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              this.closeAllPhotosModal(modal);
            }
          });

          // Add photo click listeners for fullscreen view
          this.attachGalleryPhotoListeners(modal);
        }

        attachGalleryPhotoListeners(modal = null) {
          setTimeout(() => {
            // If no modal provided, try to find it
            if (!modal) {
              modal = document.querySelector('[style*="position: fixed"][style*="z-index: 2500"]');
            }
            
            if (!modal) return;
            
            const photoItems = modal.querySelectorAll('.photo-item');
            
            photoItems.forEach((item, index) => {
              // Remove any existing listeners by cloning the element
              const newItem = item.cloneNode(true);
              item.parentNode.replaceChild(newItem, item);
              
              newItem.addEventListener('click', (e) => {
                
                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                if (photoIndex >= 0 && photoIndex < this.photos.length) {
                  const photo = this.photos[photoIndex];
                  
                  // Close the all photos modal first
                  this.closeAllPhotosModal(modal);
                  
                  // Then show the photo with its specific functionality
                  setTimeout(() => {
                    this.showPhotoFullscreenFromModal(photo);
                  }, 100);
                } else {
                  console.error('getAllPhotosModal - Invalid photo index:', photoIndex);
                }
              });
            });
            
            // Add dummy card click handlers for camera functionality
            const dummyCards = modal.querySelectorAll('.dummy-card');
            dummyCards.forEach((card) => {
              // Remove any existing listeners by cloning the element
              const newCard = card.cloneNode(true);
              card.parentNode.replaceChild(newCard, card);
              
              newCard.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                const name = e.currentTarget.dataset.name;
                const mode = e.currentTarget.dataset.mode;
                
                console.log('Dummy card clicked:', { room, name, mode });
                
                // Close the all photos modal first
                this.closeAllPhotosModal(modal);
                
                // Open camera based on the dummy type
                setTimeout(() => {
                  if (mode === 'dummy-before') {
                    this.openCameraFromGallery(room, name, 'before');
                  } else if (mode === 'dummy-after') {
                    this.openCameraFromGallery(room, name, 'after');
                  }
                  // Note: dummy-combined cards don't need camera functionality
                  // as combined photos are auto-generated when both before/after exist
                }, 100);
              });
            });
          }, 100);
        }

        closeAllPhotosModal(modal) {
          if (modal && modal.parentNode) {
            document.body.removeChild(modal);
          }
          // Restore background scrolling
          document.body.style.overflow = '';
        }

        showUploadOptionsPopup() {
          // Close any existing modals
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 3000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Get current location from URL or default
          const urlParams = new URLSearchParams(window.location.search);
          const currentLocation = urlParams.get('location') || 'tampa';
          const currentCleaner = urlParams.get('cleaner') || 'Kate';

          // Generate default album name based on current date and location
          const today = new Date();
          const dateStr = today.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric', 
            year: 'numeric' 
          });
          const defaultAlbumName = `${currentCleaner} - ${dateStr}`;

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 20px; max-width: 450px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
              <!-- Header -->
              <div style="background: #F2C31B; margin: -20px -20px 20px -20px; padding: 14px 20px; border-radius: 16px 16px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <h2 style="margin: 0; color: #303030; font-size: 24px; font-weight: bold;">üì§ Upload</h2>
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <select id="upload-city-select" style="width: 120px; padding: 10px 12px; border: 2px solid #000; border-radius: 6px; font-size: 14px; background: #F2C31B; color: #000; font-weight: bold;">
                      <option value="tampa" ${currentLocation === 'tampa' ? 'selected' : ''}>Tampa</option>
                      <option value="st-petersburg" ${currentLocation === 'st-petersburg' ? 'selected' : ''}>St. Petersburg</option>
                      <option value="jacksonville" ${currentLocation === 'jacksonville' ? 'selected' : ''}>Jacksonville</option>
                      <option value="miami" ${currentLocation === 'miami' ? 'selected' : ''}>Miami</option>
                    </select>
                    <button id="close-upload-popup" style="background: none; border: none; font-size: 24px; color: #303030; cursor: pointer; padding: 4px; border-radius: 4px;" onmouseover="this.style.color='#000'" onmouseout="this.style.color='#303030'">‚úï</button>
                  </div>
                </div>
              </div>

              <!-- Upload Source and Album Name -->
              <div style="margin-bottom: 16px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                  <div>
                    <label style="display: block; font-weight: bold; color: #303030; margin-bottom: 6px; font-size: 15px;">
                      üì§ Source
                    </label>
                    <select id="upload-method-select" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 16px; background: white; box-sizing: border-box;">
                      <option value="phone">üì± Phone</option>
                      <option value="google-drive" selected>‚òÅÔ∏è Google Drive</option>
                      <option value="dropbox">üì¶ Dropbox</option>
                      <option value="storage">üíæ Storage</option>
                    </select>
                  </div>
                  <div>
                    <label style="display: block; font-weight: bold; color: #303030; margin-bottom: 6px; font-size: 15px;">
                      üìÅ Album Name
                    </label>
                    <input type="text" id="album-name-input" value="${defaultAlbumName}" style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 16px; background: white; color: #303030; box-sizing: border-box; font-family: 'Quicksand', sans-serif;" placeholder="Enter album name" readonly>
                  </div>
                </div>
              </div>

              <!-- Quality -->
              <div style="margin-bottom: 16px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                  <label style="font-weight: bold; color: #303030; font-size: 15px;">
                    üóúÔ∏è Quality
                  </label>
                  <button id="quality-info-btn" style="background: none; border: none; font-size: 16px; color: #666; cursor: pointer; padding: 2px; border-radius: 4px;" onmouseover="this.style.color='#F2C31B'" onmouseout="this.style.color='#666'" title="Quality Options Guide">‚ÑπÔ∏è</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 6px;">
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="radio" name="quality" value="messenger" style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #999;">Messenger (WhatsApp, SMS, Telegram)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #F2C31B; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #F2C31B;">
                    <input type="radio" name="quality" value="social" checked style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #000;">Social (Instagram, Facebook, LinkedIn)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="radio" name="quality" value="presentation" style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #999;">Presentation (Websites, Portfolios)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="radio" name="quality" value="print" style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #999;">Print (Flyers, Brochures, High-Detail)</span>
                  </label>
                </div>
              </div>

              <!-- Photo Types -->
              <div style="margin-bottom: 16px;">
                <label style="display: block; font-weight: bold; color: #303030; margin-bottom: 10px; font-size: 15px;">
                  üì∏ Photo Types
                </label>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;">
                  <label style="display: flex; align-items: center; padding: 6px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="checkbox" id="upload-before" style="margin-right: 6px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; color: #999; font-weight: bold;">Before</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 6px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="checkbox" id="upload-after" style="margin-right: 6px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; color: #999; font-weight: bold;">After</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 6px; border: 2px solid #F2C31B; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #F2C31B;">
                    <input type="checkbox" id="upload-combined" checked style="margin-right: 6px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; color: #000; font-weight: bold;">Combined</span>
                  </label>
                </div>
              </div>


              <!-- Formats -->
              <div style="margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                  <label style="font-weight: bold; color: #303030; font-size: 15px;">
                    üìê Formats
                  </label>
                  <button id="format-info-btn" style="background: none; border: none; font-size: 16px; color: #666; cursor: pointer; padding: 2px; border-radius: 4px;" onmouseover="this.style.color='#F2C31B'" onmouseout="this.style.color='#666'" title="Formats Guide">‚ÑπÔ∏è</button>
                </div>
                <div style="display: flex; flex-direction: column; gap: 6px;">
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #F2C31B; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #F2C31B;">
                    <input type="checkbox" id="format-instagram-facebook" checked style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #000;">Instagram / Facebook Feed (4:5)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #F2C31B; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #F2C31B;">
                    <input type="checkbox" id="format-linkedin-business" checked style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #000;">LinkedIn / Google My Business / Yelp (1:1)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="checkbox" id="format-websites-presentations" style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #999;">Websites / Presentations (16:9)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="checkbox" id="format-blog-marketing" style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #999;">Blog Posts / Marketing Materials (3:2)</span>
                  </label>
                  <label style="display: flex; align-items: center; padding: 8px 10px; border: 2px solid #999; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: #f5f5f5;">
                    <input type="checkbox" id="format-original" style="margin-right: 8px; transform: scale(1.2); accent-color: #000;">
                    <span style="font-size: 13px; font-weight: bold; color: #999;">Original Size / Ratio (4:3)</span>
                  </label>
                </div>
              </div>

              <!-- Action Buttons -->
              <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="cancel-upload" style="background: #f5f5f5; color: #666; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#e5e5e5'" onmouseout="this.style.background='#f5f5f5'">
                  Cancel
                </button>
                <button id="start-upload" style="background: #F2C31B; color: #303030; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#E6B800'" onmouseout="this.style.background='#F2C31B'">
                  üì§ Start Upload
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);
          document.body.style.overflow = 'hidden';

          // Add event listeners
          this.setupUploadPopupListeners(modal);
        }

        formatLocationName(location) {
          const locationNames = {
            'tampa': 'Tampa',
            'st-petersburg': 'St. Petersburg',
            'jacksonville': 'Jacksonville',
            'miami': 'Miami'
          };
          return locationNames[location] || location;
        }

        formatUploadMethod(method) {
          const methodNames = {
            'phone': 'Phone',
            'google-drive': 'Google Drive',
            'dropbox': 'Dropbox',
            'storage': 'Storage'
          };
          return methodNames[method] || method;
        }

        formatQuality(quality) {
          const qualityNames = {
            'messenger': 'Messenger (WhatsApp, SMS, Telegram)',
            'social': 'Social (Instagram, Facebook, LinkedIn)',
            'presentation': 'Presentation (Websites, Portfolios)',
            'print': 'Print (Flyers, Brochures, High-Detail)'
          };
          return qualityNames[quality] || quality;
        }

        formatSelectedFormats(formats) {
          const formatNames = {
            'instagram-facebook': 'Instagram / Facebook Feed (4:5)',
            'linkedin-business': 'LinkedIn / Google My Business / Yelp (1:1)',
            'websites-presentations': 'Websites / Presentations (16:9)',
            'blog-marketing': 'Blog Posts / Marketing Materials (3:2)',
            'original': 'Original Size / Ratio (4:3)'
          };
          
          const selectedFormats = Object.keys(formats).filter(key => formats[key]);
          if (selectedFormats.length === 0) return 'None selected';
          if (selectedFormats.length === 1) return formatNames[selectedFormats[0]];
          if (selectedFormats.length === 2) return formatNames[selectedFormats[0]] + ', ' + formatNames[selectedFormats[1]];
          return selectedFormats.length + ' formats selected';
        }

        showInfoPopup(type) {
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
          `;

          let content = '';
          let title = '';

          if (type === 'quality') {
            title = 'Quality Options Guide';
            content = `
              <div style="margin-bottom: 20px;">
                <h3 style="color: #303030; margin: 0 0 15px 0; font-size: 18px;">1Ô∏è‚É£ Quality Options</h3>
                <div style="overflow-x: auto;">
                  <table style="width: 100%; border-collapse: collapse; font-size: 13px; min-width: 600px;">
                    <thead>
                      <tr style="background: #f8f9fa;">
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Quality</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Platforms</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Resolution</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">JPEG</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Use Case</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Messenger</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">WhatsApp, SMS, Telegram</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">800√ó450 px</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">30%</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Quick send, small file size</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Social Media</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Instagram, Facebook, LinkedIn</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">1024√ó576 px</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">50%</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Best for feeds & stories</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Presentation</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Websites, Reports, Portfolios</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">1600√ó900 px</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">70%</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Sharp and professional</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Print</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Flyers, Brochures, High-Detail</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">1920√ó1080 px</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">85%</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Highest quality for print</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div style="margin-bottom: 20px;">
                <h4 style="color: #303030; margin: 0 0 10px 0;">Notes:</h4>
                <ul style="margin: 0; padding-left: 20px; color: #666;">
                  <li>Higher resolution and JPEG quality = larger file size.</li>
                  <li>Choose the setting based on where the photo will be used.</li>
                </ul>
              </div>
              <div>
                <h4 style="color: #303030; margin: 0 0 10px 0;">Tips for Choosing:</h4>
                <ul style="margin: 0; padding-left: 20px; color: #666;">
                  <li><strong>Messenger:</strong> Quick sharing with clients or team members via WhatsApp/SMS/Telegram.</li>
                  <li><strong>Social Media:</strong> Use for Instagram or Facebook posts; balanced quality keeps file size manageable.</li>
                  <li><strong>Presentation:</strong> Professional look for slideshows, websites, or client portfolios.</li>
                  <li><strong>Print:</strong> Use only when you need high-detail images for brochures, flyers, or archival purposes.</li>
                </ul>
              </div>
            `;
          } else if (type === 'format') {
            title = 'Photo Formats Guide';
            content = `
              <div style="margin-bottom: 20px;">
                <h3 style="color: #303030; margin: 0 0 15px 0; font-size: 18px;">2Ô∏è‚É£ Photo Formats (Aspect Ratios)</h3>
                <div style="overflow-x: auto;">
                  <table style="width: 100%; border-collapse: collapse; font-size: 13px; min-width: 500px;">
                    <thead>
                      <tr style="background: #f8f9fa;">
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Format</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Platforms</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Ratio</th>
                        <th style="padding: 8px 6px; text-align: left; border: 1px solid #ddd; font-size: 12px;">Use Case</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Instagram / Facebook Feed</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Instagram, Facebook</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">4:5</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Best for vertical feed posts</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">LinkedIn / Google My Business / Yelp</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">LinkedIn, GMB, Yelp</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">1:1</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Square format for business listings</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Websites / Presentations</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Websites, client reports</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">16:9</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Standard landscape for slides</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Blog Posts / Marketing Materials</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Blog posts, brochures</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">3:2</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Wide format for articles</td>
                      </tr>
                      <tr>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-weight: bold; font-size: 12px;">Original Size / Ratio</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Any</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">4:3 (or original)</td>
                        <td style="padding: 8px 6px; border: 1px solid #ddd; font-size: 11px;">Keep original dimensions</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div style="margin-bottom: 20px;">
                <h4 style="color: #303030; margin: 0 0 10px 0;">Notes:</h4>
                <ul style="margin: 0; padding-left: 20px; color: #666;">
                  <li>Formats automatically adjust resolution proportionally to preserve quality.</li>
                  <li>Users can pick a format independent of quality ‚Äî e.g., Social Media quality with Square or Portrait format.</li>
                </ul>
              </div>
            `;
          }

          modal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 20px; max-width: 95vw; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); margin: 0 10px;">
              <!-- Header -->
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 2px solid #f0f0f0; position: relative;">
                <h2 style="margin: 0; color: #303030; font-size: 20px; font-weight: bold; line-height: 1.3;">üìñ QuickBeforeAfter ‚Äì Photo Export Guide</h2>
                <button id="close-info-popup" style="background: #f5f5f5; border: 2px solid #ddd; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; color: #666; cursor: pointer; position: absolute; top: -8px; right: -8px;" onmouseover="this.style.background='#e5e5e5'; this.style.borderColor='#ccc'" onmouseout="this.style.background='#f5f5f5'; this.style.borderColor='#ddd'">‚úï</button>
              </div>

              <div style="margin-bottom: 20px; color: #666; font-size: 14px; line-height: 1.5;">
                This guide explains all export options in QuickBeforeAfter: Quality Levels, Resolutions, and Formats. Use it to pick the best settings for social media, client reports, presentations, or printing.
              </div>

              ${content}
            </div>
          `;

          document.body.appendChild(modal);
          document.body.style.overflow = 'hidden';

          // Add event listeners
          document.getElementById('close-info-popup').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        setupUploadPopupListeners(modal) {
          // Close button
          document.getElementById('close-upload-popup').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
          });

          // Cancel button
          document.getElementById('cancel-upload').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);

          // Start upload button
          document.getElementById('start-upload').addEventListener('click', () => {
            this.handleUploadStart(modal);
          });

          // Update album name and URL when city changes
          document.getElementById('upload-city-select').addEventListener('change', (e) => {
            const albumNameInput = document.getElementById('album-name-input');
            const currentCleaner = new URLSearchParams(window.location.search).get('cleaner') || 'Kate';
            const selectedLocation = e.target.value;
            const today = new Date();
            const dateStr = today.toLocaleDateString('en-US', { 
              month: 'short', 
              day: 'numeric', 
              year: 'numeric' 
            });
            const newAlbumName = `${currentCleaner} - ${this.formatLocationName(selectedLocation)} - ${dateStr}`;
            albumNameInput.value = newAlbumName;
            
            // Update URL parameters to reflect new city selection
            if (selectedLocation) {
              const newUrl = `${window.location.origin}${window.location.pathname}?cleaner=${encodeURIComponent(currentCleaner)}&location=${encodeURIComponent(selectedLocation)}`;
              
              // Update URL without page reload using pushState
              window.history.pushState({ cleaner: currentCleaner, location: selectedLocation }, '', newUrl);
              
              // Update the header to reflect the new city (if needed)
              // Since the header shows cleaner name, no change needed there
              console.log('Updated URL to:', newUrl);
            }
          });

          // Add checkbox change handlers for dynamic styling
          const checkboxIds = ['upload-before', 'upload-after', 'upload-combined'];
          
          checkboxIds.forEach(id => {
            const checkbox = document.getElementById(id);
            const label = checkbox.closest('label');
            
            checkbox.addEventListener('change', () => {
              if (checkbox.checked) {
                // Active state: yellow background, black text, yellow border
                label.style.background = '#F2C31B';
                label.style.borderColor = '#F2C31B';
                
                // Update text colors to black
                const spans = label.querySelectorAll('span');
                spans.forEach(span => {
                  span.style.color = '#000';
                });
                
                // Update visual indicators to black
                const divs = label.querySelectorAll('div[style*="background:"]');
                divs.forEach(div => {
                  if (div.style.background.includes('999') || div.style.background.includes('#999')) {
                    div.style.background = '#000';
                  }
                });
              } else {
                // Inactive state: gray background, gray text, gray border
                label.style.background = '#f5f5f5';
                label.style.borderColor = '#999';
                
                // Update text colors to gray
                const spans = label.querySelectorAll('span');
                spans.forEach(span => {
                  span.style.color = '#999';
                });
                
                // Update visual indicators to gray
                const divs = label.querySelectorAll('div[style*="background:"]');
                divs.forEach(div => {
                  if (div.style.background.includes('000') || div.style.background.includes('#000')) {
                    div.style.background = '#999';
                  }
                });
              }
            });
          });

          // Add radio button change handlers for quality selection
          const qualityRadios = document.querySelectorAll('input[name="quality"]');
          
          qualityRadios.forEach(radio => {
            radio.addEventListener('change', () => {
              // Reset all quality labels to inactive state
              qualityRadios.forEach(r => {
                const label = r.closest('label');
                label.style.background = '#f5f5f5';
                label.style.borderColor = '#999';
                
                const spans = label.querySelectorAll('span');
                spans.forEach(span => {
                  span.style.color = '#999';
                });
              });
              
              // Set selected radio to active state
              const selectedLabel = radio.closest('label');
              selectedLabel.style.background = '#F2C31B';
              selectedLabel.style.borderColor = '#F2C31B';
              
              const selectedSpans = selectedLabel.querySelectorAll('span');
              selectedSpans.forEach(span => {
                span.style.color = '#000';
              });
            });
          });

          // Add checkbox change handlers for format selection
          const formatCheckboxIds = ['format-instagram-facebook', 'format-linkedin-business', 'format-websites-presentations', 'format-blog-marketing', 'format-original'];
          
          formatCheckboxIds.forEach(id => {
            const checkbox = document.getElementById(id);
            const label = checkbox.closest('label');
            
            checkbox.addEventListener('change', () => {
              if (checkbox.checked) {
                // Active state: yellow background, black text, yellow border
                label.style.background = '#F2C31B';
                label.style.borderColor = '#F2C31B';
                
                // Update text colors to black
                const spans = label.querySelectorAll('span');
                spans.forEach(span => {
                  span.style.color = '#000';
                });
              } else {
                // Inactive state: gray background, gray text, gray border
                label.style.background = '#f5f5f5';
                label.style.borderColor = '#999';
                
                // Update text colors to gray
                const spans = label.querySelectorAll('span');
                spans.forEach(span => {
                  span.style.color = '#999';
                });
              }
            });
          });

          // Add info button event listeners
          document.getElementById('quality-info-btn').addEventListener('click', () => {
            this.showInfoPopup('quality');
          });

          document.getElementById('format-info-btn').addEventListener('click', () => {
            this.showInfoPopup('format');
          });

        }

        handleUploadStart(modal) {
          // Get selected options
          const albumName = document.getElementById('album-name-input').value.trim();
          const selectedCity = document.getElementById('upload-city-select').value;
          const uploadMethod = document.getElementById('upload-method-select').value;
          const selectedQuality = document.querySelector('input[name="quality"]:checked').value;
          
          const photoTypes = {
            before: document.getElementById('upload-before').checked,
            after: document.getElementById('upload-after').checked,
            combined: document.getElementById('upload-combined').checked
          };

          const selectedFormats = {
            'instagram-facebook': document.getElementById('format-instagram-facebook').checked,
            'linkedin-business': document.getElementById('format-linkedin-business').checked,
            'websites-presentations': document.getElementById('format-websites-presentations').checked,
            'blog-marketing': document.getElementById('format-blog-marketing').checked,
            'original': document.getElementById('format-original').checked
          };

          // Validation
          if (!albumName) {
            alert('Please enter an album name');
            return;
          }

          const hasSelectedTypes = Object.values(photoTypes).some(selected => selected);
          if (!hasSelectedTypes) {
            alert('Please select at least one photo type to upload');
            return;
          }

          const hasSelectedFormats = Object.values(selectedFormats).some(selected => selected);
          if (!hasSelectedFormats) {
            alert('Please select at least one format');
            return;
          }

          // Close the popup
          document.body.removeChild(modal);
          document.body.style.overflow = '';

          // Start the upload process
          this.processUpload({
            albumName,
            city: selectedCity,
            uploadMethod,
            quality: selectedQuality,
            formats: selectedFormats,
            photoTypes
          });
        }

        processUpload(options) {
          console.log('Starting upload with options:', options);
          console.log('Total photos in app:', this.photos.length);
          console.log('All photos:', this.photos.map(p => ({ name: p.name, mode: p.mode, room: p.room })));
          
          // Filter photos based on selected types
          let photosToUpload = this.photos.filter(photo => {
            const shouldInclude = (
              (photo.mode === 'before' && options.photoTypes.before) ||
              (photo.mode === 'after' && options.photoTypes.after) ||
              (photo.mode === 'mix' && options.photoTypes.combined)
            );
            console.log(`Photo ${photo.name} (${photo.mode}): ${shouldInclude ? 'INCLUDED' : 'EXCLUDED'}`);
            return shouldInclude;
          });

          console.log('Photos to upload:', photosToUpload.length);
          console.log('Filtered photos:', photosToUpload.map(p => ({ name: p.name, mode: p.mode, room: p.room })));

          if (photosToUpload.length === 0) {
            alert('No photos found matching the selected criteria');
            return;
          }

          // Show upload progress
          this.showUploadProgress(photosToUpload, options);
        }

        showUploadProgress(photos, options) {
          // Create progress modal
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
              <h2 style="margin: 0 0 20px 0; color: #303030; font-size: 24px; font-weight: bold;">üì§ Uploading Photos</h2>
              
              <div style="margin-bottom: 16px;">
                <div style="font-size: 16px; color: #666; margin-bottom: 8px;">Album: <strong>${options.albumName}</strong></div>
                <div style="font-size: 16px; color: #666; margin-bottom: 8px;">City: <strong>${this.formatLocationName(options.city)}</strong></div>
                <div style="font-size: 14px; color: #666; margin-bottom: 4px;">
                  Upload Method: <strong>${this.formatUploadMethod(options.uploadMethod)}</strong>
                </div>
                <div style="font-size: 14px; color: #666; margin-bottom: 4px;">
                  Quality: <strong>${this.formatQuality(options.quality)}</strong>
                </div>
                <div style="font-size: 14px; color: #666; margin-bottom: 4px;">
                  Formats: <strong>${this.formatSelectedFormats(options.formats)}</strong>
                </div>
              </div>

              <div style="margin-bottom: 20px;">
                <div style="font-size: 18px; font-weight: bold; color: #303030; margin-bottom: 8px;">
                  <span id="upload-current">0</span> / <span id="upload-total">${photos.length * Object.keys(options.formats).filter(key => options.formats[key]).length}</span> uploads
                </div>
                <div style="width: 100%; height: 8px; background: #f0f0f0; border-radius: 4px; overflow: hidden;">
                  <div id="upload-progress-bar" style="height: 100%; background: #F2C31B; width: 0%; transition: width 0.3s ease;"></div>
                </div>
              </div>

              <div id="upload-status" style="font-size: 14px; color: #666; margin-bottom: 16px;">
                Preparing upload...
              </div>

              <button id="cancel-upload-process" style="background: #f5f5f5; color: #666; border: none; padding: 10px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;" onmouseover="this.style.background='#e5e5e5'" onmouseout="this.style.background='#f5f5f5'">
                Cancel Upload
              </button>
            </div>
          `;

          document.body.appendChild(modal);

          // Start real upload process with parallel uploads
          this.parallelUpload(photos, options, modal);
        }

        async realUpload(photos, options, modal) {
          const progressBar = document.getElementById('upload-progress-bar');
          const currentSpan = document.getElementById('upload-current');
          const statusDiv = document.getElementById('upload-status');
          
          let currentIndex = 0;
          let cancelled = false;
          let uploadedFiles = [];
          let errors = [];

          // Get environment variables based on location
          const locationKey = this.getLocationKey(options.city);
          const SCRIPT_URL = window[`VITE_${locationKey}_SCRIPT_URL`] || window.GOOGLE_SCRIPT_URL;
          const FOLDER_ID = window[`VITE_${locationKey}_FOLDER_ID`] || window.GOOGLE_FOLDER_ID;
          
          console.log('Upload configuration:', {
            city: options.city,
            locationKey: locationKey,
            scriptUrl: SCRIPT_URL,
            folderId: FOLDER_ID ? FOLDER_ID.substring(0, 10) + '...' : 'undefined'
          });

          if (!SCRIPT_URL || !FOLDER_ID) {
            statusDiv.textContent = 'Configuration error: Missing script URL or folder ID';
            setTimeout(() => {
              alert('Upload configuration is missing. Please contact administrator.');
              document.body.removeChild(modal);
              document.body.style.overflow = '';
            }, 2000);
            return;
          }

          // Cancel button with confirmation
          document.getElementById('cancel-upload-process').addEventListener('click', () => {
            this.showCancelUploadConfirmation(modal, () => {
              cancelled = true;
              statusDiv.textContent = 'Upload cancelled by user';
              
              // Update button text and disable it
              const cancelBtn = document.getElementById('cancel-upload-process');
              if (cancelBtn) {
                cancelBtn.textContent = 'Cancelling...';
                cancelBtn.disabled = true;
                cancelBtn.style.opacity = '0.6';
                cancelBtn.style.cursor = 'not-allowed';
              }
              
              // Close modal after a brief delay to show cancellation status
              setTimeout(() => {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
              }, 1000);
            });
          });

          const uploadPhoto = async (photo, format = 'default') => {
            console.log(`Starting upload for ${photo.name} (${photo.mode}) in ${format} format`);
            
            try {
              let photoData = photo.dataUrl;
              let filename = `${photo.name}_${photo.mode}`;
              
              // Generate different formats if needed
              if (format !== 'default') {
                console.log(`Generating ${format} format for ${photo.name} (${photo.mode})`);
                // Generate the specific format on-the-fly
                photoData = await this.generatePhotoFormat(photo, format);
                filename = `${photo.name}_${photo.mode}_${format}`;
              }
              
              // Apply compression based on quality setting
              const compressionSettings = this.getCompressionSettings(options.quality);
              console.log(`Compressing ${filename} with ${options.quality} quality`);
              
              const originalSize = photoData.length;
              const compressionStart = performance.now();
              
              photoData = await this.compressPhoto(
                photoData, 
                compressionSettings.quality, 
                compressionSettings.maxWidth, 
                compressionSettings.maxHeight
              );
              
              const compressionTime = performance.now() - compressionStart;
              const compressedSize = photoData.length;
              const reduction = ((originalSize - compressedSize) / originalSize * 100).toFixed(1);
              
              console.log(`üóúÔ∏è ${filename} compressed: ${reduction}% reduction (${Math.round(originalSize/1024)}KB ‚Üí ${Math.round(compressedSize/1024)}KB) in ${Math.round(compressionTime)}ms`);
              
              // Add file extension
              filename += '.jpg';
              console.log(`Uploading compressed file: ${filename}`);
              
              // Prepare form data
              const formData = new FormData();
              formData.append('folderId', FOLDER_ID);
              formData.append('filename', filename);
              formData.append('albumName', options.albumName);
              formData.append('room', photo.room || 'general');
              formData.append('type', photo.mode);
              formData.append('format', format);
              formData.append('timestamp', photo.timestamp || Date.now());
              formData.append('location', options.city);
              formData.append('cleanerName', new URLSearchParams(window.location.search).get('cleaner') || 'Kate');
              formData.append('image', photoData);

              console.log(`üì§ Making fetch request to: ${SCRIPT_URL}`);
              const uploadStart = performance.now();
              
              const response = await fetch(SCRIPT_URL, {
                method: 'POST',
                body: formData
              });

              const uploadTime = performance.now() - uploadStart;
              console.log(`üì• Response received for ${filename}: ${response.status} ${response.statusText} in ${Math.round(uploadTime)}ms`);
              
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }

              const result = await response.json();
              console.log(`Upload result for ${filename}:`, result);
              
              if (result.success) {
                console.log(`‚úÖ Successfully uploaded ${filename}`);
                uploadedFiles.push({
                  ...result,
                  originalPhoto: photo,
                  format: format
                });
                return result;
              } else {
                throw new Error(result.message || 'Upload failed');
              }
            } catch (error) {
              console.error(`‚ùå Upload error for ${photo.name}:`, error);
              errors.push({
                photo: photo,
                format: format,
                error: error.message
              });
              throw error;
            }
          };

          const uploadNext = async () => {
            console.log(`uploadNext called - currentIndex: ${currentIndex}, photos.length: ${photos.length}, cancelled: ${cancelled}`);
            
            if (cancelled) {
              console.log('Upload cancelled, stopping');
              return;
            }

            if (currentIndex >= photos.length) {
              console.log('All photos processed, showing results');
              // All photos processed, show results
              const successCount = uploadedFiles.length;
              const errorCount = errors.length;
              
              if (errorCount === 0) {
                statusDiv.textContent = 'Upload completed successfully!';
                setTimeout(() => {
                  document.body.removeChild(modal);
                  document.body.style.overflow = '';
                  this.showUploadSuccessNotification(successCount, options.albumName);
                }, 2000);
              } else {
                statusDiv.textContent = `Upload completed with ${errorCount} errors`;
                setTimeout(() => {
                  document.body.removeChild(modal);
                  document.body.style.overflow = '';
                  // Show custom notification for partial success
                  this.showSuccessNotification(
                    'Upload Partially Complete', 
                    `${successCount} photos uploaded successfully, ${errorCount} failed. Check console for details.`,
                    '‚ö†Ô∏è'
                  );
                  console.log('Upload errors:', errors);
                }, 2000);
              }
              return;
            }

            const photo = photos[currentIndex];
            console.log(`Processing photo ${currentIndex + 1}/${photos.length}:`, {
              name: photo.name,
              mode: photo.mode,
              room: photo.room,
              id: photo.id
            });
            
            try {
              // Get all selected formats
              const selectedFormats = Object.keys(options.formats).filter(key => options.formats[key]);
              console.log(`Formats to upload for ${photo.name}:`, selectedFormats);
              
              for (let formatIndex = 0; formatIndex < selectedFormats.length; formatIndex++) {
                if (cancelled) {
                  console.log('Upload cancelled during format processing');
                  return;
                }
                
                const format = selectedFormats[formatIndex];
                const formatLabel = format === 'default' ? '' : ` (${format})`;
                
                statusDiv.textContent = `Uploading ${photo.mode} photo: ${photo.name}${formatLabel}`;
                
                try {
                  await uploadPhoto(photo, format);
                } catch (error) {
                  if (cancelled) {
                    console.log('Upload cancelled during photo upload');
                    return;
                  }
                  // Error already handled in uploadPhoto function
                }
                
                // Check cancellation again after upload
                if (cancelled) {
                  console.log('Upload cancelled after photo upload');
                  return;
                }
                
                // Update progress for each format
                const totalUploads = photos.length * selectedFormats.length; // Each photo gets multiple formats
                
                const currentUpload = uploadedFiles.length + errors.length;
                currentSpan.textContent = currentUpload;
                progressBar.style.width = `${(currentUpload / totalUploads) * 100}%`;
                
                // Small delay between formats (with cancellation check)
                await new Promise(resolve => {
                  setTimeout(() => {
                    if (cancelled) {
                      console.log('Upload cancelled during delay');
                    }
                    resolve();
                  }, 500);
                });
                
                if (cancelled) return;
              }
              
            } catch (error) {
              console.error(`Failed to upload ${photo.mode} photo ${photo.name}:`, error);
            }

            console.log(`Finished processing photo ${photo.name}, moving to next. currentIndex: ${currentIndex} -> ${currentIndex + 1}`);
            currentIndex++;
            
            // Add small delay before processing next photo
            setTimeout(() => {
              uploadNext();
            }, 100);
          };

          // Start upload process
          uploadNext();
        }

        async parallelUpload(photos, options, modal) {
          const progressBar = document.getElementById('upload-progress-bar');
          const currentSpan = document.getElementById('upload-current');
          const statusDiv = document.getElementById('upload-status');
          
          let cancelled = false;
          let completedUploads = 0;
          let uploadedFiles = [];
          let errors = [];

          // Get environment variables based on location
          const locationKey = this.getLocationKey(options.city);
          const SCRIPT_URL = window[`VITE_${locationKey}_SCRIPT_URL`] || window.GOOGLE_SCRIPT_URL;
          const FOLDER_ID = window[`VITE_${locationKey}_FOLDER_ID`] || window.GOOGLE_FOLDER_ID;
          
          console.log('Upload configuration:', {
            city: options.city,
            locationKey: locationKey,
            scriptUrl: SCRIPT_URL,
            folderId: FOLDER_ID ? FOLDER_ID.substring(0, 10) + '...' : 'undefined'
          });

          if (!SCRIPT_URL || !FOLDER_ID) {
            statusDiv.textContent = 'Configuration error: Missing script URL or folder ID';
            setTimeout(() => {
              alert('Upload configuration is missing. Please contact administrator.');
              document.body.removeChild(modal);
              document.body.style.overflow = '';
            }, 2000);
            return;
          }

          // Cancel button with confirmation
          document.getElementById('cancel-upload-process').addEventListener('click', () => {
            this.showCancelUploadConfirmation(modal, () => {
              cancelled = true;
              statusDiv.textContent = 'Upload cancelled by user';
              
              const cancelBtn = document.getElementById('cancel-upload-process');
              if (cancelBtn) {
                cancelBtn.textContent = 'Cancelling...';
                cancelBtn.disabled = true;
                cancelBtn.style.opacity = '0.6';
                cancelBtn.style.cursor = 'not-allowed';
              }
              
              setTimeout(() => {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
              }, 1000);
            });
          });

          // Create upload tasks for all photos and formats
          const uploadTasks = [];
          
          photos.forEach(photo => {
            // Get all selected formats
            const selectedFormats = Object.keys(options.formats).filter(key => options.formats[key]);
            console.log(`üìã Selected formats for ${photo.name}:`, selectedFormats);
            
            selectedFormats.forEach(format => {
              uploadTasks.push({ photo, format });
              console.log(`‚ûï Added upload task: ${photo.name} - ${format}`);
            });
          });

          const totalTasks = uploadTasks.length;
          console.log(`üöÄ Starting parallel upload of ${totalTasks} tasks (${photos.length} photos)`);

          const uploadPhoto = async (photo, format = 'default') => {
            if (cancelled) return null;
            
            console.log(`Starting upload for ${photo.name} (${photo.mode}) in ${format} format`);
            
            try {
              let photoData = photo.dataUrl;
              let filename = `${photo.name}_${photo.mode}`;
              
              // Generate different formats if needed
              if (format !== 'default') {
                console.log(`Generating ${format} format for ${photo.name} (${photo.mode})`);
                photoData = await this.generatePhotoFormat(photo, format);
                filename = `${photo.name}_${photo.mode}_${format}`;
              }
              
              // Apply compression based on quality setting
              const compressionSettings = this.getCompressionSettings(options.quality);
              
              const originalSize = photoData.length;
              const compressionStart = performance.now();
              
              photoData = await this.compressPhoto(
                photoData, 
                compressionSettings.quality, 
                compressionSettings.maxWidth, 
                compressionSettings.maxHeight
              );
              
              const compressionTime = performance.now() - compressionStart;
              const compressedSize = photoData.length;
              const reduction = ((originalSize - compressedSize) / originalSize * 100).toFixed(1);
              
              console.log(`üóúÔ∏è ${filename} compressed: ${reduction}% reduction (${Math.round(originalSize/1024)}KB ‚Üí ${Math.round(compressedSize/1024)}KB) in ${Math.round(compressionTime)}ms`);
              
              filename += '.jpg';
              
              // Prepare form data
              const formData = new FormData();
              formData.append('folderId', FOLDER_ID);
              formData.append('filename', filename);
              formData.append('albumName', options.albumName);
              formData.append('room', photo.room || 'general');
              formData.append('type', photo.mode);
              formData.append('format', format);
              formData.append('timestamp', photo.timestamp || Date.now());
              formData.append('location', options.city);
              formData.append('cleanerName', new URLSearchParams(window.location.search).get('cleaner') || 'Kate');
              formData.append('image', photoData);

              console.log(`üì§ Making fetch request to: ${SCRIPT_URL}`);
              const uploadStart = performance.now();
              
              const response = await fetch(SCRIPT_URL, {
                method: 'POST',
                body: formData
              });

              const uploadTime = performance.now() - uploadStart;
              console.log(`üì• Response received for ${filename}: ${response.status} ${response.statusText} in ${Math.round(uploadTime)}ms`);
              
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }

              const result = await response.json();
              
              if (result.success) {
                console.log(`‚úÖ Successfully uploaded ${filename} in ${Math.round(uploadTime)}ms`);
                return {
                  ...result,
                  originalPhoto: photo,
                  format: format
                };
              } else {
                throw new Error(result.message || 'Upload failed');
              }
            } catch (error) {
              console.error(`‚ùå Upload error for ${photo.name}:`, error);
              throw { photo, format, error: error.message };
            }
          };

          // Process uploads in parallel batches (increased for better speed)
          const BATCH_SIZE = 5; // Upload 5 photos at a time for better parallelization
          const batches = [];
          
          for (let i = 0; i < uploadTasks.length; i += BATCH_SIZE) {
            batches.push(uploadTasks.slice(i, i + BATCH_SIZE));
          }

          console.log(`üì¶ Processing ${batches.length} batches of up to ${BATCH_SIZE} concurrent uploads`);

          for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
            if (cancelled) break;
            
            const batch = batches[batchIndex];
            statusDiv.textContent = `Processing batch ${batchIndex + 1}/${batches.length}...`;
            
            console.log(`üîÑ Processing batch ${batchIndex + 1}/${batches.length} with ${batch.length} uploads`);
            
            // Process all uploads in this batch simultaneously
            const batchPromises = batch.map(task => uploadPhoto(task.photo, task.format));
            
            try {
              const results = await Promise.allSettled(batchPromises);
              
              results.forEach((result, index) => {
                completedUploads++;
                
                if (result.status === 'fulfilled' && result.value) {
                  uploadedFiles.push(result.value);
                } else if (result.status === 'rejected') {
                  errors.push(result.reason);
                }
                
                // Update progress
                currentSpan.textContent = completedUploads;
                progressBar.style.width = `${(completedUploads / totalTasks) * 100}%`;
              });
              
            } catch (error) {
              console.error('Batch processing error:', error);
            }
            
            // Small delay between batches to avoid overwhelming the server
            if (batchIndex < batches.length - 1 && !cancelled) {
              await new Promise(resolve => setTimeout(resolve, 500));
            }
          }

          // Show final results
          const successCount = uploadedFiles.length;
          const errorCount = errors.length;
          
          if (cancelled) {
            statusDiv.textContent = 'Upload cancelled';
          } else if (errorCount === 0) {
            statusDiv.textContent = 'Upload completed successfully!';
            setTimeout(() => {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
              this.showUploadSuccessNotification(successCount, options.albumName);
            }, 2000);
          } else {
            statusDiv.textContent = `Upload completed with ${errorCount} errors`;
            setTimeout(() => {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
              // Show custom notification for partial success
              this.showSuccessNotification(
                'Upload Partially Complete', 
                `${successCount} photos uploaded successfully, ${errorCount} failed. Check console for details.`,
                '‚ö†Ô∏è'
              );
              console.log('Upload errors:', errors);
            }, 2000);
          }
        }

        getLocationKey(city) {
          // Map cities to location keys from .env file
          const locationMap = {
            'tampa': 'LOCATION_A',
            'st-petersburg': 'LOCATION_B', 
            'jacksonville': 'LOCATION_C',
            'miami': 'LOCATION_D'
          };
          return locationMap[city] || 'LOCATION_A'; // Default to Tampa
        }

        getCompressionSettings(quality) {
          const settings = {
            'messenger': {
              quality: 0.3,       // 30% JPEG quality
              maxWidth: 800,      // Max 800px width
              maxHeight: 450,     // Max 450px height
              description: 'Messenger (Quick send, small size)'
            },
            'social': {
              quality: 0.5,       // 50% JPEG quality
              maxWidth: 1024,     // Max 1024px width
              maxHeight: 576,     // Max 576px height
              description: 'Social Media (Best for feeds & stories)'
            },
            'presentation': {
              quality: 0.7,       // 70% JPEG quality
              maxWidth: 1600,     // Max 1600px width
              maxHeight: 900,     // Max 900px height
              description: 'Presentation (Sharp & professional)'
            },
            'print': {
              quality: 0.85,      // 85% JPEG quality
              maxWidth: 1920,     // Max 1920px width
              maxHeight: 1080,    // Max 1080px height
              description: 'Print (Highest quality)'
            }
          };
          return settings[quality] || settings['messenger'];
        }

        showCancelUploadConfirmation(parentModal, onConfirm) {
          // Create confirmation modal
          const confirmModal = document.createElement('div');
          confirmModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
          `;

          confirmModal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 24px; max-width: 350px; width: 100%; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
              <!-- Warning Icon -->
              <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
              
              <!-- Title -->
              <h3 style="margin: 0 0 12px 0; color: #303030; font-size: 20px; font-weight: bold;">Cancel Upload?</h3>
              
              <!-- Message -->
              <p style="margin: 0 0 24px 0; color: #666; font-size: 16px; line-height: 1.4;">
                Are you sure you want to cancel the upload? Any photos already uploaded will remain in your Google Drive.
              </p>
              
              <!-- Upload Progress Info -->
              <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 24px; text-align: left;">
                <div style="font-size: 14px; color: #666; margin-bottom: 4px;">Upload Status:</div>
                <div style="font-size: 14px; font-weight: bold; color: #303030;" id="cancel-progress-info">
                  Checking current progress...
                </div>
              </div>
              
              <!-- Action Buttons -->
              <div style="display: flex; gap: 12px; justify-content: center;">
                <button id="cancel-upload-no" style="background: #f5f5f5; color: #666; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#e5e5e5'" onmouseout="this.style.background='#f5f5f5'">
                  Continue Upload
                </button>
                <button id="cancel-upload-yes" style="background: #dc3545; color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: bold; transition: all 0.2s;" onmouseover="this.style.background='#c82333'" onmouseout="this.style.background='#dc3545'">
                  Yes, Cancel Upload
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(confirmModal);

          // Update progress info
          setTimeout(() => {
            const progressInfo = document.getElementById('cancel-progress-info');
            const currentSpan = parentModal.querySelector('#upload-current');
            const totalSpan = parentModal.querySelector('#upload-total');
            
            if (progressInfo && currentSpan && totalSpan) {
              const current = currentSpan.textContent || '0';
              const total = totalSpan.textContent || '0';
              progressInfo.textContent = `${current} of ${total} files uploaded`;
            }
          }, 100);

          // Event listeners
          document.getElementById('cancel-upload-no').addEventListener('click', () => {
            document.body.removeChild(confirmModal);
          });

          document.getElementById('cancel-upload-yes').addEventListener('click', () => {
            document.body.removeChild(confirmModal);
            onConfirm();
          });

          // Close on background click
          confirmModal.addEventListener('click', (e) => {
            if (e.target === confirmModal) {
              document.body.removeChild(confirmModal);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(confirmModal);
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        async compressPhoto(dataUrl, quality = 0.7, maxWidth = 1920, maxHeight = 1080) {
          return new Promise((resolve) => {
            const originalSize = dataUrl.length;
            
            // Skip compression for already small photos (less than 200KB)
            if (originalSize < 200000) {
              console.log(`Skipping compression for small photo (${Math.round(originalSize/1024)}KB)`);
              resolve(dataUrl);
              return;
            }
            
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              
              // Calculate new dimensions while maintaining aspect ratio
              let { width, height } = img;
              
              // Only resize if image is larger than max dimensions
              if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width = Math.round(width * ratio);
                height = Math.round(height * ratio);
              }
              
              canvas.width = width;
              canvas.height = height;
              
              // Enable image smoothing for better quality
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              
              // Draw and compress
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert to compressed JPEG
              const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
              
              // Only use compressed version if it's actually smaller
              const compressedSize = compressedDataUrl.length;
              if (compressedSize < originalSize) {
                const compressionRatio = ((originalSize - compressedSize) / originalSize * 100).toFixed(1);
                console.log(`Photo compressed: ${compressionRatio}% reduction (${originalSize} ‚Üí ${compressedSize} bytes)`);
                resolve(compressedDataUrl);
              } else {
                console.log(`Compression would increase size, using original (${Math.round(originalSize/1024)}KB)`);
                resolve(dataUrl);
              }
            };
            img.src = dataUrl;
          });
        }

        async generatePhotoFormat(photo, format) {
          console.log(`üîÑ generatePhotoFormat called with format: ${format}`);
          return new Promise((resolve, reject) => {
            try {
              const img = new Image();
              img.onload = () => {
                console.log(`üìê Converting ${photo.name} to ${format} format`);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Define format dimensions
                let targetWidth, targetHeight;
                
                switch (format) {
                  case 'instagram-facebook':
                    // 4:5 aspect ratio (portrait)
                    targetWidth = 1080;
                    targetHeight = 1350;
                    break;
                  case 'linkedin-business':
                    // 1:1 aspect ratio (square)
                    targetWidth = 1080;
                    targetHeight = 1080;
                    break;
                  case 'websites-presentations':
                    // 16:9 aspect ratio (landscape)
                    targetWidth = 1920;
                    targetHeight = 1080;
                    break;
                  case 'blog-marketing':
                    // 3:2 aspect ratio
                    targetWidth = 1200;
                    targetHeight = 800;
                    break;
                  case 'original':
                    // Keep original dimensions
                    targetWidth = img.naturalWidth;
                    targetHeight = img.naturalHeight;
                    break;
                  default:
                    targetWidth = img.naturalWidth;
                    targetHeight = img.naturalHeight;
                }
                
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                
                console.log(`üéØ Target dimensions for ${format}: ${targetWidth}x${targetHeight}`);
                console.log(`üìè Original image: ${img.naturalWidth}x${img.naturalHeight}`);
                
                // Calculate scaling to fit the image within the target dimensions while maintaining aspect ratio
                const scaleX = targetWidth / img.naturalWidth;
                const scaleY = targetHeight / img.naturalHeight;
                const scale = Math.min(scaleX, scaleY);
                
                const scaledWidth = img.naturalWidth * scale;
                const scaledHeight = img.naturalHeight * scale;
                
                // Center the image
                const offsetX = (targetWidth - scaledWidth) / 2;
                const offsetY = (targetHeight - scaledHeight) / 2;
                
                // Fill background with white
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, targetWidth, targetHeight);
                
                // Draw the scaled image
                ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                
                // Convert to data URL
                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
                console.log(`‚úÖ Format conversion complete for ${photo.name}: ${format} (${targetWidth}x${targetHeight})`);
                resolve(dataUrl);
              };
              
              img.onerror = () => {
                reject(new Error('Failed to load image for format conversion'));
              };
              
              img.src = photo.dataUrl;
            } catch (error) {
              reject(error);
            }
          });
        }

        openCameraFromGallery(room, name, mode) {
          console.log('Opening camera from gallery:', { room, name, mode });
          
          // Set up context for gallery return
          this.galleryReturnContext = {
            returnToGallery: true,
            room: room,
            name: name,
            mode: mode
          };
          
          // Set the current room and mode
          this.currentRoom = room;
          
          if (mode === 'before') {
            // Set specific photo name for before photo
            this.pendingPhotoName = name;
            this.openCamera('before');
          } else if (mode === 'after') {
            // Find the corresponding before photo to open comparison camera
            const beforePhoto = this.photos.find(p => 
              p.room === room && 
              p.name === name && 
              p.mode === 'before'
            );
            
            if (beforePhoto) {
              // Set the before photo reference for the comparison camera
              this.currentBeforePhoto = beforePhoto;
              this.pendingPhotoName = name;
              
              // Open the comparison camera view (after mode) with the before photo
              this.showPhotoFullscreen(beforePhoto);
            } else {
              console.error('Cannot take after photo without corresponding before photo');
              // Return to gallery if error
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 100);
            }
          }
        }

        async showPhotoFullscreenFromModal(photo) {
          // For gallery view, always show enlarged photo without camera functionality
          this.showPhotoEnlarged(photo);
        }

        async showPhotoEnlarged(photo) {
          // Always show enlarged view regardless of photo mode - no camera functionality
          // Clean up any existing photo fullscreen modals first
          const existingPhotoModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingPhotoModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;

          if (photo.mode === 'mix') {
            // Combined photos get templates
            const templateType = photo.templateType || 'default';
            modal.innerHTML = this.getEnlargedPhotoHTML(photo, templateType);
            this.setupEnlargedPhotoListeners(modal, photo);
          } else {
            // Individual photos (before/after) show raw photo only, no templates
            const orientation = this.detectPhotoOrientation(photo.naturalWidth || 800, photo.naturalHeight || 600);
            modal.innerHTML = `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; overflow: auto; background: rgba(0,0,0,0.95); padding: 80px 20px; box-sizing: border-box;">
                <img src="${photo.dataUrl}" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);" />

                <!-- Photo info overlay -->
                <div style="position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; backdrop-filter: blur(10px); z-index: 10;">
                  <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                    ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                  </div>
                  <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                    ${new Date(photo.timestamp).toLocaleString()}
                  </div>
                  <div style="font-size: 12px; opacity: 0.7;">
                    Orientation: ${orientation} | Raw photo as captured
                  </div>
                </div>

                <!-- Close button -->
                <button id="close-photo-btn" style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; backdrop-filter: blur(10px); z-index: 10;">
                  ‚úï
                </button>
              </div>
            `;

            // Close button functionality
            const closeBtn = modal.querySelector('#close-photo-btn');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
              });
            }
          }

          document.body.appendChild(modal);
          document.body.style.overflow = 'hidden';
        }

        getTemplateDisplayName(templateType) {
          // Convert internal template keys to user-friendly display names
          console.log(`üîç DEBUG Template Display Name: "${templateType}"`);

          let displayName;
          switch(templateType) {
            case 'default':
            case 'portrait':
              displayName = 'Portrait (4:5)';
              break;
            case 'square':
            case 'square_stack':
              displayName = 'Square (Stack)';
              break;
            case 'square_side':
              displayName = 'Square (Side-by-Side)';
              break;
            case 'landscape':
              displayName = 'Landscape (16:9)';
              break;
            case 'blog':
              displayName = 'Landscape (1.91:1)';
              break;
            default:
              displayName = templateType.charAt(0).toUpperCase() + templateType.slice(1);
              break;
          }

          console.log(`  ‚û°Ô∏è Display name: "${displayName}"`);
          return displayName;
        }

        getEnlargedPhotoHTML(photo, templateType) {
          return `
            <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; overflow: auto; background: rgba(0,0,0,0.95); padding-top: 80px; padding-bottom: 120px; box-sizing: border-box;">
              <!-- Scrollable container for actual size viewing -->
              <div id="photo-container" style="position: relative; display: flex; align-items: center; justify-content: center; max-width: 95vw; max-height: calc(100vh - 200px); overflow: auto;">
                <img id="fullscreen-photo" src="${photo.dataUrl}" style="display: block; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);" />
              </div>
              
              <!-- Photo info overlay -->
              <div style="position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; backdrop-filter: blur(10px); z-index: 10;">
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  ${new Date(photo.timestamp).toLocaleString()}
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Orientation: ${orientation} | Template: ${this.getTemplateDisplayName(templateType)}
                </div>
              </div>
              
              ${this.getTemplateSelector(photo, templateType)}
              
              <!-- Close button -->
              <button id="close-photo-btn" style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; backdrop-filter: blur(10px); z-index: 10;">
                ‚úï
              </button>
            </div>
          `;
        }

        getTemplateSelector(photo, templateType) {
          // Determine the base mode for template selection
          // For combined photos, detect original mode from aspect ratio or stored metadata
          let baseMode = 'stack'; // Default
          let isHorizontalPhoto = false;

          if (photo.mode === 'mix') {
            // For combined photos, determine the original mode based on the templateType
            // If it's a stack-specific template (square_stack), it came from horizontal originals
            // If it's a side-specific template (square_side), it came from vertical originals

            if (templateType === 'square_stack' || templateType === 'landscape') {
              isHorizontalPhoto = true; // Stack mode templates
            } else if (templateType === 'square_side' || templateType === 'blog') {
              isHorizontalPhoto = false; // Side-by-side mode templates
            } else {
              // For default/portrait, try to determine from stored photo aspect ratio
              // Create a temporary image to get dimensions synchronously
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();

              img.src = photo.dataUrl;
              // For data URLs, the image loads immediately when accessed synchronously
              const photoAspectRatio = img.naturalWidth && img.naturalHeight ?
                (img.naturalWidth / img.naturalHeight) : 1;

              isHorizontalPhoto = photoAspectRatio > 1.2;
            }

            console.log(`üîç DEBUG Template Selector:`);
            console.log(`  - Photo mode: ${photo.mode}`);
            console.log(`  - Template type: ${templateType}`);
            console.log(`  - Is horizontal photo (determined): ${isHorizontalPhoto}`);
          }

          // Define template info based on the rules:
          // - Horizontal originals (4:3): Stack Mode (horizontal split line, stacked vertically)
          // - Vertical originals (2:3): Side-by-Side Mode (vertical split line, placed left-right)
          // - 1:1 format: Available to both with their respective split types

          if (isHorizontalPhoto) {
            // Horizontal originals ‚Üí Side-by-Side Mode (placed left-right with vertical split line)
            console.log(`  ‚û°Ô∏è Using SIDE-BY-SIDE MODE templates (horizontal originals ‚Üí placed left-right)`);
            const sideTemplates = {
              blog: { ratio: '1.91:1', description: 'Instagram/Facebook Landscape ‚≠ê', cropInfo: 'Best fit for landscape feeds', splitType: 'vertical' },
              landscape: { ratio: '16:9', description: 'Wide Landscape', cropInfo: 'Great for presentations/websites', splitType: 'vertical' },
              square_side: { ratio: '1:1', description: 'Square (Side-by-Side)', cropInfo: 'Vertical split - before/after side-by-side', splitType: 'vertical' }
            };

            return this.getSideBySideModeTemplateSelector(sideTemplates, templateType);
          } else {
            // Vertical originals ‚Üí Stack Mode (stacked vertically with horizontal split line)
            console.log(`  ‚û°Ô∏è Using STACK MODE templates (vertical originals ‚Üí stacked vertically)`);
            const stackTemplates = {
              portrait: { ratio: '4:5', description: 'Instagram/LinkedIn Portrait ‚≠ê', cropInfo: 'Best fit for portrait feeds', splitType: 'horizontal' },
              square_stack: { ratio: '1:1', description: 'Square (Stack)', cropInfo: 'Horizontal split - before/after stacked', splitType: 'horizontal' },
              landscape: { ratio: '16:9', description: 'Landscape Wide', cropInfo: 'Good for presentations', splitType: 'horizontal' }
            };

            return this.getStackModeTemplateSelector(stackTemplates, templateType);
          }
        }

        getStackModeTemplateSelector(stackTemplates, templateType) {
          // Stack Mode Templates (for horizontal original photos)
          return `
            <!-- Template selector for Stack Mode (horizontal original photos) -->
            <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); z-index: 10; box-shadow: 0 4px 16px rgba(0,0,0,0.4);">
              <div style="color: white; font-size: 14px; font-weight: bold; margin-bottom: 10px; text-align: center;">Stack Mode Templates</div>
              <div style="color: #ccc; font-size: 12px; margin-bottom: 15px; text-align: center;">Horizontal split - Before/After stacked vertically</div>

              <!-- Portrait (Best for stack) -->
              <label style="display: flex; align-items: center; color: white; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'default' || templateType === 'portrait' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'default' || templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}; margin-bottom: 6px;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'default' || templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                <input type="radio" name="template-selector" value="portrait" style="display: none;" ${templateType === 'default' || templateType === 'portrait' ? 'checked' : ''}>
                <div style="width: 24px; height: 30px; background: #F2C31B; border-radius: 2px; margin-right: 12px; display: flex; align-items: center; justify-content: center;">
                  <div style="font-size: 6px; color: #303030; font-weight: bold;">4:5</div>
                </div>
                <div>
                  <div style="font-weight: bold; margin-bottom: 2px;">${stackTemplates.portrait.description}</div>
                  <div style="font-size: 12px; opacity: 0.8;">${stackTemplates.portrait.cropInfo}</div>
                </div>
              </label>

              <!-- Square Stack -->
              <label style="display: flex; align-items: center; color: white; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'square' || templateType === 'square_stack' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'square' || templateType === 'square_stack' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}; margin-bottom: 6px;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'square' || templateType === 'square_stack' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                <input type="radio" name="template-selector" value="square_stack" style="display: none;" ${templateType === 'square' || templateType === 'square_stack' ? 'checked' : ''}>
                <div style="width: 24px; height: 24px; background: #F2C31B; border-radius: 2px; margin-right: 12px; display: flex; align-items: center; justify-content: center; position: relative;">
                  <div style="font-size: 6px; color: #303030; font-weight: bold;">1:1</div>
                  <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 18px; height: 1px; background: #303030;"></div>
                </div>
                <div>
                  <div style="font-weight: bold; margin-bottom: 2px;">${stackTemplates.square_stack.description}</div>
                  <div style="font-size: 12px; opacity: 0.8;">${stackTemplates.square_stack.cropInfo}</div>
                </div>
              </label>

              <!-- Landscape -->
              <label style="display: flex; align-items: center; color: white; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'landscape' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                <input type="radio" name="template-selector" value="landscape" style="display: none;" ${templateType === 'landscape' ? 'checked' : ''}>
                <div style="width: 32px; height: 18px; background: #F2C31B; border-radius: 2px; margin-right: 12px; display: flex; align-items: center; justify-content: center;">
                  <div style="font-size: 6px; color: #303030; font-weight: bold;">16:9</div>
                </div>
                <div>
                  <div style="font-weight: bold; margin-bottom: 2px;">${stackTemplates.landscape.description}</div>
                  <div style="font-size: 12px; opacity: 0.8;">${stackTemplates.landscape.cropInfo}</div>
                </div>
              </label>
            </div>
          `;
        }

        getSideBySideModeTemplateSelector(sideTemplates, templateType) {
          // Side-by-Side Mode Templates (for vertical original photos)
          return `
            <!-- Template selector for Side-by-Side Mode (vertical original photos) -->
            <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); z-index: 10; box-shadow: 0 4px 16px rgba(0,0,0,0.4);">
              <div style="color: white; font-size: 14px; font-weight: bold; margin-bottom: 10px; text-align: center;">Side-by-Side Mode Templates</div>
              <div style="color: #ccc; font-size: 12px; margin-bottom: 15px; text-align: center;">Vertical split - Before/After side-by-side</div>

              <!-- Landscape (Best for side-by-side) -->
              <label style="display: flex; align-items: center; color: white; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'default' || templateType === 'blog' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'default' || templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}; margin-bottom: 6px;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'default' || templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                <input type="radio" name="template-selector" value="blog" style="display: none;" ${templateType === 'default' || templateType === 'blog' ? 'checked' : ''}>
                <div style="width: 32px; height: 21px; background: #F2C31B; border-radius: 2px; margin-right: 12px; display: flex; align-items: center; justify-content: center;">
                  <div style="font-size: 6px; color: #303030; font-weight: bold;">1.91:1</div>
                </div>
                <div>
                  <div style="font-weight: bold; margin-bottom: 2px;">${sideTemplates.blog.description}</div>
                  <div style="font-size: 12px; opacity: 0.8;">${sideTemplates.blog.cropInfo}</div>
                </div>
              </label>

              <!-- Wide Landscape -->
              <label style="display: flex; align-items: center; color: white; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'landscape' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}; margin-bottom: 6px;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                <input type="radio" name="template-selector" value="landscape" style="display: none;" ${templateType === 'landscape' ? 'checked' : ''}>
                <div style="width: 32px; height: 18px; background: #F2C31B; border-radius: 2px; margin-right: 12px; display: flex; align-items: center; justify-content: center;">
                  <div style="font-size: 6px; color: #303030; font-weight: bold;">16:9</div>
                </div>
                <div>
                  <div style="font-weight: bold; margin-bottom: 2px;">${sideTemplates.landscape.description}</div>
                  <div style="font-size: 12px; opacity: 0.8;">${sideTemplates.landscape.cropInfo}</div>
                </div>
              </label>

              <!-- Square Side-by-Side -->
              <label style="display: flex; align-items: center; color: white; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'square' || templateType === 'square_side' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'square' || templateType === 'square_side' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}; margin-bottom: 6px;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'square' || templateType === 'square_side' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                <input type="radio" name="template-selector" value="square_side" style="display: none;" ${templateType === 'square' || templateType === 'square_side' ? 'checked' : ''}>
                <div style="width: 24px; height: 24px; background: #F2C31B; border-radius: 2px; margin-right: 12px; display: flex; align-items: center; justify-content: center; position: relative;">
                  <div style="font-size: 6px; color: #303030; font-weight: bold;">1:1</div>
                  <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1px; height: 18px; background: #303030;"></div>
                </div>
                <div>
                  <div style="font-weight: bold; margin-bottom: 2px;">${sideTemplates.square_side.description}</div>
                  <div style="font-size: 12px; opacity: 0.8;">${sideTemplates.square_side.cropInfo}</div>
                </div>
              </label>

            </div>
          `;
        }

        setupEnlargedPhotoListeners(modal, photo) {
          // Set default to fit screen mode
          const imgElement = modal.querySelector('#fullscreen-photo');
          const imgContainer = modal.querySelector('#photo-container');
          
          // Configure for fit-to-screen display
          imgElement.style.maxWidth = '100%';
          imgElement.style.maxHeight = '100%';
          imgElement.style.width = 'auto';
          imgElement.style.height = 'auto';
          imgContainer.style.maxWidth = '95vw';
          imgContainer.style.maxHeight = '95vh';
          imgContainer.style.overflow = 'hidden';

          // Template selector functionality (generate on-demand)
          const templateRadios = modal.querySelectorAll('input[name="template-selector"]');
          templateRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
              if (e.target.checked) {
                const newTemplate = e.target.value;
                console.log('Generating template on-demand:', newTemplate);
                
                // Update visual selection state
                this.updateTemplateVisualSelection(modal, newTemplate);
                
                // Show loading state
                const imgElement = modal.querySelector('#fullscreen-photo');
                if (imgElement) {
                  imgElement.style.opacity = '0.5';
                }
                
                // Handle template change based on photo type
                if (photo.mode === 'mix') {
                  // For combined photos, regenerate with new template
                  this.generateCombinedPhotoOnDemand(photo, newTemplate, modal);
                } else {
                  // For individual photos, crop the single photo to the selected template
                  this.cropIndividualPhotoOnDemand(photo, newTemplate, modal);
                }
              }
            });
          });

          const closeBtn = modal.querySelector('#close-photo-btn');
          if (closeBtn) {
            closeBtn.addEventListener('click', () => {
              document.body.removeChild(modal);
              document.body.style.overflow = '';

              // Reopen the All Photos modal
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 100);
            });
          }

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
              
              // Reopen the All Photos modal
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 100);
            }
          });
        }

        regenerateFromIndividualPhoto(photo, newTemplate, modal) {
          console.log('Regenerating from individual photo:', photo.mode, 'with template:', newTemplate);
          
          if (photo.mode === 'before') {
            // Find the corresponding after photo
            const afterPhoto = this.photos.find(p => 
              p.mode === 'after' && p.beforePhotoId === photo.id
            );
            
            if (afterPhoto) {
              // Find and remove existing combined photo
              const existingCombined = this.photos.find(p => 
                p.mode === 'mix' && p.room === photo.room && p.name === photo.name
              );
              if (existingCombined) {
                const combinedIndex = this.photos.findIndex(p => p.id === existingCombined.id);
                if (combinedIndex !== -1) {
                  this.photos.splice(combinedIndex, 1);
                }
              }
              
              // Create new combined photo with selected template
              this.createCombinedPhotoWithCallback(
                photo.dataUrl,
                afterPhoto.dataUrl,
                photo.room,
                photo.name,
                newTemplate,
                (createdPhoto) => {
                  // Show the newly created combined photo
                  this.updateModalWithNewPhoto(modal, createdPhoto);
                }
              );
            } else {
              // No after photo, just reset loading state
              const imgElement = modal.querySelector('#fullscreen-photo');
              if (imgElement) {
                imgElement.style.opacity = '1';
              }
            }
          } else if (photo.mode === 'after') {
            // Find the corresponding before photo
            const beforePhoto = this.photos.find(p => 
              p.mode === 'before' && p.id === photo.beforePhotoId
            );
            
            if (beforePhoto) {
              // Find and remove existing combined photo
              const existingCombined = this.photos.find(p => 
                p.mode === 'mix' && p.room === photo.room && p.name === photo.name
              );
              if (existingCombined) {
                const combinedIndex = this.photos.findIndex(p => p.id === existingCombined.id);
                if (combinedIndex !== -1) {
                  this.photos.splice(combinedIndex, 1);
                }
              }
              
              // Create new combined photo with selected template
              this.createCombinedPhotoWithCallback(
                beforePhoto.dataUrl,
                photo.dataUrl,
                photo.room,
                photo.name,
                newTemplate,
                (createdPhoto) => {
                  // Show the newly created combined photo
                  this.updateModalWithNewPhoto(modal, createdPhoto);
                }
              );
            } else {
              // No before photo, just reset loading state
              const imgElement = modal.querySelector('#fullscreen-photo');
              if (imgElement) {
                imgElement.style.opacity = '1';
              }
            }
          }
        }

        updateModalWithNewPhoto(modal, newPhoto) {
          // Update the modal to show the newly created combined photo
          const imgElement = modal.querySelector('#fullscreen-photo');
          if (imgElement) {
            imgElement.src = newPhoto.dataUrl;
            imgElement.style.opacity = '1';
          }
          
          // Update photo info
          const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
          if (infoDiv) {
            const orientation = this.detectPhotoOrientation(newPhoto.naturalWidth || 800, newPhoto.naturalHeight || 600);
            infoDiv.innerHTML = `
              <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                ${newPhoto.room.charAt(0).toUpperCase() + newPhoto.room.slice(1).replace('-', ' ')} - ${newPhoto.mode.charAt(0).toUpperCase() + newPhoto.mode.slice(1)}
              </div>
              <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                ${new Date(newPhoto.timestamp).toLocaleString()}
              </div>
              <div style="font-size: 12px; opacity: 0.7;">
                Orientation: ${orientation} | Template: ${this.getTemplateDisplayName(newPhoto.templateType)}
              </div>
            `;
          }
          
          // Update main photos container
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }
          
          // Update gallery modal if it's open
          const allPhotosContent = document.getElementById('all-photos-content');
          if (allPhotosContent) {
            allPhotosContent.innerHTML = this.getAllPhotosHTML();
            this.attachGalleryPhotoListeners();
          }
          
          // Save updated photos
          this.savePhotos();
          
          console.log('Modal updated with new photo:', newPhoto.templateType);
        }

        generateCombinedPhotoOnDemand(photo, templateType, modal) {
          console.log('Generating combined photo on-demand:', templateType);
          
          // Find the before and after photos
          let beforePhoto, afterPhoto;
          
          if (photo.mode === 'before') {
            beforePhoto = photo;
            afterPhoto = this.photos.find(p => p.mode === 'after' && p.beforePhotoId === photo.id);
          } else if (photo.mode === 'after') {
            afterPhoto = photo;
            beforePhoto = this.photos.find(p => p.mode === 'before' && p.id === photo.beforePhotoId);
          } else if (photo.mode === 'mix') {
            // For temporary combined photos, use the embedded references
            if (photo.beforePhoto && photo.afterPhoto) {
              beforePhoto = photo.beforePhoto;
              afterPhoto = photo.afterPhoto;
            } else {
              // Fallback: find the original pair
              beforePhoto = this.photos.find(p => p.mode === 'before' && p.room === photo.room && p.name === photo.name);
              afterPhoto = this.photos.find(p => p.mode === 'after' && p.room === photo.room && p.name === photo.name);
            }
          }
          
          if (!beforePhoto || !afterPhoto) {
            console.error('Cannot find before/after pair for on-demand generation');
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.style.opacity = '1';
            }
            return;
          }
          
          // Generate combined photo without storing it
          this.createCombinedPhotoInMemory(beforePhoto.dataUrl, afterPhoto.dataUrl, templateType, (combinedDataUrl) => {
            // Update modal with generated photo
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.src = combinedDataUrl;
              imgElement.style.opacity = '1';
            }
            
            // Update photo info to show it's a generated combined photo
            const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
            if (infoDiv) {
              const orientation = this.detectPhotoOrientation(beforePhoto.width || 800, beforePhoto.height || 600);
              infoDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${beforePhoto.room.charAt(0).toUpperCase() + beforePhoto.room.slice(1).replace('-', ' ')} - Combined (${templateType})
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  Generated on-demand
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Template: ${this.getTemplateDisplayName(templateType)} | Not stored locally
                </div>
              `;
            }
            
            // Update the current photo object's template type for future reference
            photo.templateType = templateType;
          });
        }

        createCombinedPhotoInMemory(beforeDataUrl, afterDataUrl, templateType, callback) {
          console.log('Creating combined photo in memory for template:', templateType);
          
          // Create image objects to get dimensions
          const beforeImg = new Image();
          const afterImg = new Image();
          
          let imagesLoaded = 0;
          const totalImages = 2;
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // Determine the combined mode based on original photos' aspect ratio
              const beforeAspectRatio = beforeImg.width / beforeImg.height;
              const afterAspectRatio = afterImg.width / afterImg.height;
              const avgAspectRatio = (beforeAspectRatio + afterAspectRatio) / 2;

              // Detect if original photos are portrait (2:3) or landscape (4:3)
              const isOriginallyVertical = avgAspectRatio <= 1.0; // Portrait photos (2:3 ‚âà 0.67)
              const baseMode = isOriginallyVertical ? 'sidebyside' : 'stack';

              console.log(`üîç DEBUG Combined Photo Creation:`);
              console.log(`  - Before image: ${beforeImg.width}x${beforeImg.height} (aspect: ${(beforeImg.width/beforeImg.height).toFixed(2)})`);
              console.log(`  - After image: ${afterImg.width}x${afterImg.height} (aspect: ${(afterImg.width/afterImg.height).toFixed(2)})`);
              console.log(`  - Average aspect ratio: ${avgAspectRatio.toFixed(2)}`);
              console.log(`  - Is originally vertical: ${isOriginallyVertical}`);
              console.log(`  - Base mode determined: ${baseMode}`);
              console.log(`  - Template type requested: ${templateType}`);

              // Get template definition
              const templates = this.getTemplateSizes();
              let templateKey = templateType || 'default';

              // Map legacy template names to new format
              console.log(`üîç DEBUG Template Mapping:`);
              console.log(`  - Input templateType: ${templateType}`);
              console.log(`  - Base mode: ${baseMode}`);

              if (templateType === 'default') {
                templateKey = baseMode === 'stack' ? 'stack-portrait' : 'sidebyside-landscape';
              } else if (templateType === 'portrait') {
                templateKey = 'stack-portrait'; // Portrait only available in Stack Mode
              } else if (templateType === 'square') {
                templateKey = baseMode === 'stack' ? 'stack-square' : 'sidebyside-square';
              } else if (templateType === 'square_stack') {
                templateKey = 'stack-square';
              } else if (templateType === 'square_side') {
                templateKey = 'sidebyside-square';
              } else if (templateType === 'landscape') {
                templateKey = baseMode === 'stack' ? 'stack-landscape' : 'sidebyside-wide';
              } else if (templateType === 'blog') {
                templateKey = baseMode === 'stack' ? 'stack-landscape' : 'sidebyside-landscape';
              }

              console.log(`  - Final templateKey: ${templateKey}`);

              const template = templates[templateKey] || templates['stack-portrait'];

              const templateDimensions = {
                targetWidth: template.width,
                targetHeight: template.height,
                splitType: template.splitType,
                ratio: template.ratio,
                baseMode: baseMode
              };

              console.log(`üì∏ Using template: ${templateKey}`, templateDimensions);
              console.log(`üîç DEBUG Template Execution:`);
              console.log(`  - Template splitType: "${template.splitType}"`);
              console.log(`  - Will call: ${template.splitType === 'horizontal-line' ? 'drawHorizontalSplit (Stack Mode)' : 'drawVerticalSplit (Side-by-Side Mode)'}`);
              console.log(`  - Expected result: ${template.splitType === 'horizontal-line' ? 'Horizontal line between top/bottom' : 'Vertical line between left/right'}`);

              // Create canvas
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');

              canvas.width = templateDimensions.targetWidth;
              canvas.height = templateDimensions.targetHeight;

              // No white background - images will fill the entire canvas
              
              // Apply cropping and positioning
              ctx.save();
              ctx.beginPath();
              ctx.rect(0, 0, canvas.width, canvas.height);
              ctx.clip();
              
              if (templateDimensions.splitType === 'horizontal-line') {
                // Horizontal line split = Stack Mode (horizontal line between top/bottom)
                this.drawHorizontalSplit(ctx, beforeImg, afterImg, templateDimensions);
              } else {
                // Vertical line split = Side-by-Side Mode (vertical line between left/right)
                this.drawVerticalSplit(ctx, beforeImg, afterImg, templateDimensions);
              }
              
              ctx.restore();
              
              // Add labels
              this.addPhotoLabels(ctx, canvas.width, canvas.height, templateDimensions.splitType);
              
              // Convert to data URL and return via callback
              const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
              callback(combinedDataUrl);
            }
          };
          
          // Load images
          beforeImg.onload = onImageLoad;
          afterImg.onload = onImageLoad;
          beforeImg.src = beforeDataUrl;
          afterImg.src = afterDataUrl;
        }

        updateTemplateVisualSelection(modal, selectedTemplate) {
          // Update the visual state of all template labels
          const templateLabels = modal.querySelectorAll('label');
          templateLabels.forEach(label => {
            const radio = label.querySelector('input[name="template-selector"]');
            if (radio) {
              const templateValue = radio.value;
              
              if (templateValue === selectedTemplate) {
                // Selected state - golden border and background
                label.style.border = '2px solid #F2C31B';
                label.style.background = 'rgba(242, 195, 27, 0.2)';
              } else {
                // Unselected state - transparent border and background
                label.style.border = '2px solid transparent';
                label.style.background = 'transparent';
              }
            }
          });
        }

        cropIndividualPhotoOnDemand(photo, templateType, modal) {
          console.log('Cropping individual photo on-demand:', photo.mode, 'to template:', templateType);
          
          // Create image object to get dimensions and crop
          const img = new Image();
          
          img.onload = () => {
            // Get template dimensions
            const templateSizes = this.getTemplateSizes();
            const targetTemplate = templateSizes[templateType] || templateSizes.default;
            
            // Detect photo orientation
            const orientation = this.detectPhotoOrientation(img.width, img.height);
            
            // Calculate crop dimensions for this individual photo
            const cropDimensions = this.calculatePhotoCropDimensions(
              img.width, img.height, templateType, orientation
            );
            
            // Create canvas with target template size
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = targetTemplate.width;
            canvas.height = targetTemplate.height;
            
            // Fill white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate how to fit the cropped photo into the template canvas
            const cropAspectRatio = cropDimensions.cropWidth / cropDimensions.cropHeight;
            const templateAspectRatio = targetTemplate.width / targetTemplate.height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (cropAspectRatio > templateAspectRatio) {
              // Crop is wider, fit to height
              drawHeight = targetTemplate.height;
              drawWidth = drawHeight * cropAspectRatio;
              drawX = (targetTemplate.width - drawWidth) / 2;
              drawY = 0;
            } else {
              // Crop is taller, fit to width
              drawWidth = targetTemplate.width;
              drawHeight = drawWidth / cropAspectRatio;
              drawX = 0;
              drawY = (targetTemplate.height - drawHeight) / 2;
            }
            
            // Draw the cropped photo
            ctx.drawImage(
              img,
              cropDimensions.cropX, cropDimensions.cropY, 
              cropDimensions.cropWidth, cropDimensions.cropHeight,
              drawX, drawY, drawWidth, drawHeight
            );
            
            // Add photo type label
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            
            const labelWidth = 120;
            const labelHeight = 30;
            const labelX = (canvas.width - labelWidth) / 2;
            const labelY = 20;
            
            ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(photo.mode.toUpperCase(), canvas.width / 2, labelY + 20);
            
            // Convert to data URL and update modal
            const croppedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
            
            // Update modal with cropped photo
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.src = croppedDataUrl;
              imgElement.style.opacity = '1';
            }
            
            // Update photo info
            const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
            if (infoDiv) {
              infoDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  Cropped to ${templateType} format
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Template: ${this.getTemplateDisplayName(templateType)} | Generated on-demand | Orientation: ${orientation}
                </div>
              `;
            }
            
            console.log('Individual photo cropped to template:', templateType);
          };
          
          img.src = photo.dataUrl;
        }
        
        getPhotosHTML() {

          // Room icon for placeholders
          const roomIcons = {
            'kitchen': 'üç≥',
            'bathroom': 'üõÅ',
            'bedroom': 'üõèÔ∏è',
            'living-room': 'üõãÔ∏è',
            'dining-room': 'üçΩÔ∏è',
            'office': 'üíº'
          };

          // Get all before photos for this room, sorted by timestamp (oldest first)
          const beforePhotos = this.photos
            .filter(photo => photo.room === this.currentRoom && photo.mode === 'before')
            .sort((a, b) => a.timestamp - b.timestamp); // Oldest first


          // Create grid layout with all photos and dummy squares
          const gridItems = [];
          

          // Add all existing photos
          beforePhotos.forEach((beforePhoto, i) => {
            // Check if there's a corresponding after photo linked to this before photo
            const afterPhoto = this.photos.find(p =>
              p.room === this.currentRoom &&
              p.mode === 'after' &&
              p.beforePhotoId === beforePhoto.id
            );

            if (afterPhoto) {
              // Check if there's a stored combined photo
              const combinedPhoto = this.photos.find(p =>
                p.mode === 'mix' && p.room === beforePhoto.room && p.name === beforePhoto.name
              );

              console.log(`üîç Looking for combined photo: room=${beforePhoto.room}, name=${beforePhoto.name}`);
              console.log(`üîç Found combined photo:`, combinedPhoto ? 'YES' : 'NO');

              if (combinedPhoto) {
                // Show stored combined photo
                const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

                // Determine object-fit based on photo's original aspect ratio
                const objectFit = 'contain'; // Keep contain for proper display within square

                console.log(`üñºÔ∏è Main Gallery Combined Photo ${combinedPhoto.id}: aspectRatio=${combinedPhoto.aspectRatio}, objectFit=${objectFit}`);

                gridItems.push(`
                  <div class="photo-item" data-photo-index="${this.photos.indexOf(combinedPhoto)}" style="border: 1px solid #E1E1E1; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1;">
                    <img src="${combinedPhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: ${objectFit}; filter: blur(3px);" />

                    <!-- Retake button in center -->
                    <button class="retake-combined-btn" data-before-photo-id="${beforePhoto.id}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #F2C31B; color: #303030; border: none; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 10;">
                      üîÑ Retake
                    </button>

                    <!-- Transparent title overlay -->
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; background: linear-gradient(transparent, rgba(0,0,0,0.7));">
                      <div style="color: white; font-weight: bold; font-size: 11px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); font-family: 'Quicksand', sans-serif;">${displayName}</div>
                      <div style="color: rgba(255,255,255,0.9); font-size: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); font-family: 'Quicksand', sans-serif;">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                    </div>

                    <!-- Delete button -->
                    <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(combinedPhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                      üóëÔ∏è
                    </button>
                  </div>
                `);
              }
            } else {
              // Show only before photo
              const displayName = beforePhoto.name || `${beforePhoto.room} 1`;

              // Determine object-fit based on photo's original aspect ratio
              const objectFit = 'contain'; // Keep contain for proper display

              console.log(`üñºÔ∏è Main Gallery Before Photo ${beforePhoto.id}: aspectRatio=${beforePhoto.aspectRatio}, objectFit=${objectFit}`);

              gridItems.push(`
                <div class="photo-item" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="border: 3px solid #F2C31B; border-radius: 8px; overflow: hidden; position: relative; transition: transform 0.2s; aspect-ratio: 1;">
                  <img src="${beforePhoto.dataUrl}" style="width: 100%; height: 100%; object-fit: ${objectFit}; cursor: pointer;" />
                  <div style="padding: 8px; font-size: 11px; color: #B3B3B3;">
                    <div style="font-weight: bold; margin-bottom: 2px; color: #303030; font-family: 'Quicksand', sans-serif;">${displayName}</div>
                    <div style="font-size: 10px; opacity: 0.8; font-family: 'Quicksand', sans-serif;">${new Date(beforePhoto.timestamp).toLocaleString()}</div>
                  </div>
                  <!-- Delete button -->
                  <button class="delete-photo-btn" data-photo-index="${this.photos.indexOf(beforePhoto)}" style="position: absolute; top: 5px; right: 5px; background: rgba(48,48,48,0.9); color: white; border: none; padding: 5px; border-radius: 50%; font-size: 12px; cursor: pointer; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center;">
                    üóëÔ∏è
                  </button>
                </div>
              `);
            }
          });
          
          // Add one dummy square for taking more photos
          gridItems.push(`
            <div class="dummy-photo" data-room="${this.currentRoom}" style="aspect-ratio: 1; border-radius: 8px; background: #f0f0f0; border: 2px dashed #ccc; display: flex; align-items: center; justify-content: center; color: #999; font-size: 24px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e8e8e8'; this.style.color='#666';" onmouseout="this.style.background='#f0f0f0'; this.style.color='#999';">
              ${roomIcons[this.currentRoom] || 'üì∑'}
            </div>
          `);

          return gridItems.join('');
        }
        
        getRoomPhotosByType(type) {
          const roomPhotos = this.photos.filter(photo => photo.room === this.currentRoom);
          console.log('getRoomPhotosByType - Type:', type, 'Current room:', this.currentRoom);
          console.log('getRoomPhotosByType - Room photos:', roomPhotos);
          
          if (type === 'photo') {
            const result = roomPhotos.filter(photo => photo.mode === 'before' || photo.mode === 'after');
            console.log('getRoomPhotosByType - Photo result:', result);
            return result;
          } else if (type === 'combined') {
            const result = roomPhotos.filter(photo => photo.mode === 'mix');
            console.log('getRoomPhotosByType - Combined result:', result);
            return result;
          } else if (type === 'all') {
            const result = roomPhotos.filter(photo => photo.mode === 'archived' || photo.mode === 'mix');
            console.log('getRoomPhotosByType - All result:', result);
            return result;
          }
          return roomPhotos;
        }
        
        getRoomFilteredPhotos() {
          // Always show photos by default, unless specifically viewing combined or all
          return this.getRoomPhotosByType(this.currentTab || 'photo');
        }
        
        addSwipeListeners() {
          // Only add listeners once
          if (this.swipeListenersAdded) return;
          this.swipeListenersAdded = true;
          
          // Ensure room order matches the visual tab order exactly
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          let startX = 0;
          let startY = 0;
          
          // Add touch events for swiping
          document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          });
          
          document.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const diffX = startX - endX;
            const diffY = startY - endY;
            
            // Only trigger swipe if horizontal movement is greater than vertical
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
              const currentIndex = rooms.indexOf(this.currentRoom);
              console.log('Swipe - Current room:', this.currentRoom, 'Index:', currentIndex);
              
              if (diffX > 0) {
                // Swipe left - next room (following tab order)
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
                console.log('Swipe left - Next room:', this.currentRoom, 'Index:', nextIndex);
              } else {
                // Swipe right - previous room (following tab order)
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
                console.log('Swipe right - Previous room:', this.currentRoom, 'Index:', prevIndex);
              }
              
              this.currentTab = 'photo';
              
              // Check if we're in a camera modal - if so, don't call init() to avoid regenerating the entire app
              const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
              
              if (isInCameraModal) {
                // Just update modal elements without regenerating the entire app
                setTimeout(() => {
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }, 100);
              } else {
                // Normal app update
                this.init();
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              }
            }
          });
          
          // Add keyboard support for cycling
          document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
              e.preventDefault();
              const currentIndex = rooms.indexOf(this.currentRoom);
              
              if (e.key === 'ArrowLeft') {
                const prevIndex = (currentIndex - 1 + rooms.length) % rooms.length;
                this.currentRoom = rooms[prevIndex];
              } else {
                const nextIndex = (currentIndex + 1) % rooms.length;
                this.currentRoom = rooms[nextIndex];
              }
              
              this.currentTab = 'photo';
              
              // Check if we're in a camera modal - if so, don't call init() to avoid regenerating the entire app
              const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                      document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
              
              if (isInCameraModal) {
                // Just update modal elements without regenerating the entire app
                setTimeout(() => {
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }, 100);
              } else {
                // Normal app update
                this.init();
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 200);
              }
            }
          });
        }
        
        updateTabsCarousel() {
          // Just re-render the tabs - the carousel positioning is handled in getRoomTabsCarousel()
          const tabsCarousel = document.getElementById('tabs-carousel');
          if (tabsCarousel) {
            tabsCarousel.innerHTML = this.getRoomTabsCarousel();

            // Reattach event listeners after updating the DOM
            this.attachRoomTabListeners();
          }
        }

        attachRoomTabListeners() {

          // Room tabs click listeners - specifically for main gallery (not modal)
          const mainCarousel = document.getElementById('tabs-carousel');

          if (!mainCarousel) {
            const allElements = document.querySelectorAll('*[id*="tab"]');
            return;
          }

          const roomTabs = mainCarousel.querySelectorAll('.room-tab');

          roomTabs.forEach((btn, index) => {

            // Remove any existing listeners first
            btn.removeEventListener('click', this.roomTabClickHandler);

            // Add new listener
            btn.addEventListener('click', (e) => {
              console.log('üî• ROOM TAB CLICKED!', e.currentTarget.dataset.room);
              e.preventDefault();
              e.stopPropagation();

              // Get room from current target (the button) instead of target (might be inner element)
              const room = e.currentTarget.dataset.room;
              console.log('Room clicked:', room, 'Current room:', this.currentRoom);

              if (room && room !== this.currentRoom) {
                console.log('Switching from', this.currentRoom, 'to', room);
                this.currentRoom = room;
                this.currentTab = 'photo'; // Reset to photo tab when switching rooms

                // Update only the content area instead of full re-init
                const photosContainer = document.getElementById('photos-container');
                if (photosContainer) {
                  photosContainer.innerHTML = this.getPhotosHTML();
                  this.attachPhotoListeners();
                }

                // Update carousel and scroll
                setTimeout(() => {
                  this.updateTabsCarousel();
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }, 100);
              } else {
                console.log('Same room clicked or invalid room');
              }
            });

            // Make sure buttons are interactive
            btn.style.pointerEvents = 'auto';
            btn.style.cursor = 'pointer';
            btn.style.backgroundColor = btn.style.backgroundColor || '#f0f0f0';

            // Add hover effect for testing
            btn.addEventListener('mouseenter', () => {
              console.log('üñ±Ô∏è Mouse entered room tab:', btn.dataset.room);
              btn.style.opacity = '0.8';
            });

            btn.addEventListener('mouseleave', () => {
              btn.style.opacity = '1';
            });

            // Add mousedown and mouseup for more testing
            btn.addEventListener('mousedown', () => {
              console.log('üñ±Ô∏è Mouse DOWN on room tab:', btn.dataset.room);
            });

            btn.addEventListener('mouseup', () => {
              console.log('üñ±Ô∏è Mouse UP on room tab:', btn.dataset.room);
            });

            // Check if element is being blocked
            btn.addEventListener('pointerdown', () => {
              console.log('üëÜ Pointer DOWN on room tab:', btn.dataset.room);
            });

          });

        }

        // Test function to manually check room tab functionality
        testRoomTabs() {
          const carousel = document.getElementById('tabs-carousel');
          console.log('Carousel found:', !!carousel);

          if (carousel) {
            const tabs = carousel.querySelectorAll('.room-tab');
            console.log('Tabs found:', tabs.length);

            tabs.forEach((tab, i) => {
              const rect = tab.getBoundingClientRect();
              const style = window.getComputedStyle(tab);
              console.log(`Tab ${i}:`, tab.dataset.room);
              console.log(`  Position:`, rect.x, rect.y, rect.width, rect.height);
              console.log(`  Z-index:`, style.zIndex);
              console.log(`  Pointer events:`, style.pointerEvents);

              // Check what element is actually at the center of the button
              const centerX = rect.x + rect.width / 2;
              const centerY = rect.y + rect.height / 2;
              const elementAtPoint = document.elementFromPoint(centerX, centerY);
              console.log(`  Element at center:`, elementAtPoint);
              console.log(`  Is the tab itself?`, elementAtPoint === tab);
            });

            // Try to click the first tab
            if (tabs.length > 0) {
              console.log('Simulating click on first tab...');
              tabs[0].click();
            }
          }
        }

        updateModalRoomTabs() {
          // Update room tabs in the modal
          const modalTabsCarousel = document.getElementById('modal-tabs-carousel');
          if (modalTabsCarousel) {
            modalTabsCarousel.innerHTML = this.getRoomTabsCarousel();
            console.log('Modal carousel updated for room:', this.currentRoom);

            // Reattach modal room tab listeners
            this.attachModalRoomTabListeners();
          }
        }

        attachModalRoomTabListeners() {
          // Room tab listeners specifically for the modal
          const modalCarousel = document.getElementById('modal-tabs-carousel');
          if (!modalCarousel) return;

          modalCarousel.querySelectorAll('.room-tab').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const room = e.currentTarget.dataset.room;
              if (room && room !== this.currentRoom) {
                this.currentRoom = room;
                this.updateModalRoomTabs();
                this.updateModalPhotoGrid();
              }
            });
          });
        }

        updateModalPhotoGrid() {
          // Update photo grid in the modal
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            // Store current scroll position and content height
            const previousScrollTop = beforePhotoGrid.scrollTop;
            const previousScrollHeight = beforePhotoGrid.scrollHeight;

            beforePhotoGrid.innerHTML = this.getBeforePhotosGridHTML();
            this.attachBeforePhotoListeners();

            // Smart scrolling to keep content visible above bottom panel
            setTimeout(() => {
              const currentScrollHeight = beforePhotoGrid.scrollHeight;
              const containerHeight = beforePhotoGrid.clientHeight;
              const bottomPanelHeight = 80; // Height of bottom panel

              // If content grew (new photos added), scroll up to accommodate
              if (currentScrollHeight > previousScrollHeight) {
                const heightDifference = currentScrollHeight - previousScrollHeight;

                // Calculate optimal scroll position to keep latest content visible
                // but not hidden behind bottom panel
                const maxVisibleScroll = currentScrollHeight - containerHeight + bottomPanelHeight;
                const newScrollTop = Math.min(previousScrollTop + heightDifference, maxVisibleScroll);

                beforePhotoGrid.scrollTop = Math.max(0, newScrollTop);
                console.log('üì∏ Auto-scrolled up to accommodate new photos');
              }
            }, 100);
          }
        }

        showActionButtons() {
          // Show retake and save buttons, hide camera button
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Show the bottom panel with appropriate layout
          if (bottomPanel) {
            bottomPanel.style.display = this.isLandscape ? 'flex' : 'grid';
          }

          if (retakeBtn) retakeBtn.style.display = 'flex';
          if (saveBtn) saveBtn.style.display = 'flex';
          if (cameraBtn) cameraBtn.style.display = 'none';
          
          // Adjust main content padding in landscape mode
          if (this.isLandscape) {
            this.adjustMainContentForRightPanel(true);
          }
          
          // Check if we're in after mode (comparison camera modal) and make bottom panel transparent
          if (bottomPanel) {
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');
            
            if (cameraModal && cameraModal.innerHTML.includes('comparison-camera')) {
              // After mode (comparison camera) - transparent panel
              bottomPanel.style.background = 'transparent';
              bottomPanel.style.boxShadow = 'none';
            } else {
              // Before mode - white panel to cover gallery
              bottomPanel.style.background = 'white';
              bottomPanel.style.boxShadow = 'none';
            }
          }
        }

        hideActionButtons() {
          // Hide retake and save buttons, keep camera button hidden for gallery
          const retakeBtn = document.getElementById('btn-retake');
          const saveBtn = document.getElementById('btn-save');
          const cameraBtn = document.getElementById('camera-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Hide the entire bottom panel in gallery mode
          if (bottomPanel) bottomPanel.style.display = 'none';

          if (retakeBtn) retakeBtn.style.display = 'none';
          if (saveBtn) saveBtn.style.display = 'none';
          
          // Reset bottom panel styling to original
          if (bottomPanel) {
            bottomPanel.style.background = 'white';
            bottomPanel.style.boxShadow = '0 -2px 8px rgba(0,0,0,0.1)';
          }
          
          // Check if we're in a camera modal - if so, keep camera button visible
          const isInCameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') !== null ||
                                  document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') !== null ||
                                  document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]') !== null;
          if (cameraBtn) {
            if (isInCameraModal) {
              cameraBtn.style.display = 'block'; // Keep visible during camera modal
            } else {
              cameraBtn.style.display = 'none'; // Hide for gallery
            }
          }
        }

        showCameraButton() {
          // Show camera button during photo capture screens
          const cameraBtn = document.getElementById('camera-btn');
          const aspectRatioBtn = document.getElementById('aspect-ratio-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Show the bottom panel with appropriate layout
          if (bottomPanel) {
            bottomPanel.style.display = this.isLandscape ? 'flex' : 'grid';
          }

          if (cameraBtn) cameraBtn.style.display = 'block';
          if (aspectRatioBtn) aspectRatioBtn.style.display = 'flex';
          
          // Adjust main content padding in landscape mode
          if (this.isLandscape) {
            this.adjustMainContentForRightPanel(true);
          }
          
          // Check if we're in a camera modal and apply appropriate styling
          if (bottomPanel && cameraBtn) {
            const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                               document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');
            
            if (cameraModal) {
              // Conditional styling based on camera mode
              if (cameraModal.innerHTML.includes('comparison-camera')) {
                // After mode (comparison camera) - transparent panel
                bottomPanel.style.background = 'transparent';
                bottomPanel.style.boxShadow = 'none';
              } else {
                // Before mode - white panel to cover gallery
                bottomPanel.style.background = 'white';
                bottomPanel.style.boxShadow = 'none';
              }

              // Make individual sections transparent
              const sections = bottomPanel.querySelectorAll('div');
              sections.forEach(section => {
                section.style.background = 'transparent';
              });
              
              cameraBtn.style.background = '#F2C31B';
              cameraBtn.style.border = '2px solid rgba(255,255,255,0.8)';
              cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
            } else {
              // Not in camera modal - keep panel transparent (room tabs are at bottom)
              bottomPanel.style.background = 'transparent';
              bottomPanel.style.boxShadow = 'none';
              cameraBtn.style.background = '#F2C31B';
              cameraBtn.style.border = 'none';
              cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
            }
          }
        }

        hideCameraButton() {
          // Hide camera button and reset styling
          const cameraBtn = document.getElementById('camera-btn');
          const aspectRatioBtn = document.getElementById('aspect-ratio-btn');
          const bottomPanel = document.getElementById('bottom-panel');

          // Hide the entire bottom panel
          if (bottomPanel) bottomPanel.style.display = 'none';
          
          // Restore main content padding in landscape mode
          if (this.isLandscape) {
            this.adjustMainContentForRightPanel(false);
          }
          
          if (cameraBtn) {
            cameraBtn.style.display = 'none';
            // Reset camera button styling to original
            cameraBtn.style.background = '#F2C31B';
            cameraBtn.style.border = 'none';
            cameraBtn.style.boxShadow = '0 4px 12px rgba(48,48,48,0.3)';
          }

          if (aspectRatioBtn) {
            aspectRatioBtn.style.display = 'none';
          }
          
          // Keep bottom panel white when hidden (to cover any gallery content)
          if (bottomPanel) {
            bottomPanel.style.background = 'white';
            bottomPanel.style.boxShadow = 'none';

            // Reset individual sections to transparent (they sit on white background)
            const sections = bottomPanel.querySelectorAll('div');
            sections.forEach(section => {
              section.style.background = 'transparent';
            });
          }
        }

        adjustMainContentForRightPanel(show) {
          // Adjust main content padding when right panel is shown/hidden in landscape mode
          const mainContent = document.getElementById('main-scrollable-content');
          if (mainContent && this.isLandscape) {
            if (show) {
              mainContent.style.paddingRight = '90px'; // Account for 80px panel + 10px margin
            } else {
              mainContent.style.paddingRight = '10px'; // Restore original padding
            }
          }
        }

        updateGridsOnOrientationChange() {
          // Update main gallery grid
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            if (this.isLandscape) {
              photosContainer.style.gridTemplateColumns = 'repeat(5, 1fr)';
            } else {
              photosContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
            }
          }

          // Update before photo grid if it exists
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            const gridContainer = beforePhotoGrid.querySelector('div');
            if (gridContainer) {
              const squareSize = this.calculateSquareSize(3);
              // Always use 3 columns in both orientations
              gridContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
              gridContainer.style.gridAutoRows = `minmax(${squareSize}px, 1fr)`;
            }
          }
        }
        
        hideMainRoomTabs() {
          // Hide main room tabs when in camera mode
          const stickyTabsContainer = document.getElementById('sticky-tabs-container');
          if (stickyTabsContainer) {
            stickyTabsContainer.style.display = 'none';
          }
        }
        
        showMainRoomTabs() {
          // Show main room tabs when returning to gallery
          const stickyTabsContainer = document.getElementById('sticky-tabs-container');
          if (stickyTabsContainer) {
            stickyTabsContainer.style.display = 'flex';
          }

          // Also ensure header is visible
          this.showHeader();
        }

        showHeader() {
          // Ensure header is visible - find the header element
          const headerUploadBtn = document.getElementById('header-upload-btn');
          if (headerUploadBtn) {
            // Header exists, make sure its parent is visible
            const header = headerUploadBtn.closest('div');
            if (header) {
              header.style.display = 'flex';
              header.style.visibility = 'visible';
              header.style.opacity = '1';
            }
          } else {
            // If header is missing, something went wrong - reinitialize
            setTimeout(() => {
              this.init();
            }, 100);
          }
        }

        // Helper function to restore scrolling if no camera modals are open
        restoreScrollingIfNoCameraModals() {
          // Check if there are any camera-related modals still open
          const cameraModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 1000"], [style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          if (cameraModals.length === 0) {
            // No camera modals are open, restore scrolling
            document.body.style.overflow = '';
          }
        }

        addScrollListener() {
          // Throttle scroll events for performance
          let scrollTimeout;

          window.addEventListener('scroll', () => {
            if (scrollTimeout) {
              clearTimeout(scrollTimeout);
            }

            scrollTimeout = setTimeout(() => {
              this.checkVisibleRoom();
            }, 100); // Check every 100ms during scroll
          });
        }

        checkVisibleRoom() {
          // Room sections removed - scroll-based room switching disabled
          // Users can only switch rooms through tabs
        }
        
        attachPhotoListeners() {
          // Only attach listeners for photo elements (called after photo grid updates)
          // Clear any existing listeners first to prevent duplicates
          setTimeout(() => {
            document.querySelectorAll('.photo-item').forEach(item => {
              // Remove any existing listeners by cloning the element
              const newItem = item.cloneNode(true);
              item.parentNode.replaceChild(newItem, item);
              
              // Photo click to view fullscreen
              newItem.addEventListener('click', (e) => {
                // Don't trigger if clicking delete button or retake button
                if (e.target.classList.contains('delete-photo-btn') || 
                    e.target.classList.contains('retake-combined-btn')) {
                  return;
                }

                const photoIndex = parseInt(e.currentTarget.dataset.photoIndex);
                if (photoIndex >= 0 && photoIndex < this.photos.length) {
                  this.showPhotoFullscreen(this.photos[photoIndex]);
                }
              });

              // Add hover effect
              newItem.addEventListener('mouseenter', (e) => {
                e.currentTarget.style.transform = 'scale(1.02)';
              });

              newItem.addEventListener('mouseleave', (e) => {
                e.currentTarget.style.transform = 'scale(1)';
              });
            });

            // Delete button functionality for photos
            document.querySelectorAll('.delete-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const photoIndex = parseInt(e.target.dataset.photoIndex);
                this.deletePhoto(photoIndex);
              });
            });

            // Retake button functionality for combined photos
            document.querySelectorAll('.retake-combined-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const beforePhotoId = parseInt(e.target.dataset.beforePhotoId);
                const beforePhoto = this.photos.find(p => p.id === beforePhotoId);
                if (beforePhoto) {
                  // Open the comparison camera for retaking the after photo
                  this.showPhotoFullscreen(beforePhoto);
                }
              });
            });


            // Dummy photos click handlers
            document.querySelectorAll('.dummy-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                this.openCameraForRoom(room);
              });
            });
            
            // Auto-scroll to bottom to show latest photos (main gallery only)
            setTimeout(() => {
              const mainScrollableContent = document.getElementById('main-scrollable-content');
              if (mainScrollableContent) {
                
                if (mainScrollableContent.scrollHeight > mainScrollableContent.clientHeight) {
                  mainScrollableContent.scrollTop = mainScrollableContent.scrollHeight;
                } else {
                }
              } else {
              }
            }, 200);
          }, 100);
        }

        attachEventListeners() {
          // Room tabs with swipe support - attach with delay to ensure DOM is ready
          setTimeout(() => {
            this.attachRoomTabListeners();
          }, 100);
          
          // Add swipe functionality to room tabs
          this.addSwipeListeners();

          // Camera button - only visible during photo capture screens
          const cameraBtn = document.getElementById('camera-btn');
          if (cameraBtn) {
            cameraBtn.addEventListener('click', () => {
              // Check if we're in a camera modal (before or after mode)
              const cameraModal = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]') ||
                                 document.querySelector('[style*="position: fixed"][style*="z-index: 2000"]') ||
                                 document.querySelector('[style*="position: fixed"][style*="z-index: 2002"]');

              if (cameraModal) {
                // We're in a camera modal, capture photo
                if (cameraModal.innerHTML.includes('camera-video')) {
                  // Before mode - regular camera
                  console.log('Capturing from regular camera modal');
                  this.captureFromCameraModal();
                } else if (cameraModal.innerHTML.includes('comparison-camera')) {
                  // After mode - comparison camera
                  console.log('Capturing from comparison camera modal');
                  this.captureFromComparisonModal();
                }
              }
            });
          }
          
          // Header upload button - show upload options popup
          const headerUploadBtn = document.getElementById('header-upload-btn');
          if (headerUploadBtn) {
            headerUploadBtn.addEventListener('click', () => {
              this.showUploadOptionsPopup();
            });
          }
          
          // All Photos button - show all photos modal
          const allPhotosBtn = document.getElementById('all-photos-btn');
          if (allPhotosBtn) {
            allPhotosBtn.addEventListener('click', () => {
              this.showAllPhotosModal();
            });
          }
          
          // Change User button - clear stored data and reload to sign-in
          const changeUserBtn = document.getElementById('change-user-btn');
          if (changeUserBtn) {
            changeUserBtn.addEventListener('click', () => {
              this.showChangeUserWarning();
            });
          }
          
          // Location select
          const locationSelect = document.getElementById('location-select');
          if (locationSelect) {
            locationSelect.addEventListener('change', (e) => {
              console.log('Location changed to:', e.target.value);
              // You can add location-specific functionality here
            });
          }
          
          // Retake and Save button handlers
          const retakeBtn = document.getElementById('btn-retake');
          if (retakeBtn) {
            retakeBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Store the room before closing split screen
                const room = this.currentSplitScreen.room;

                // Close current split screen
                this.closeSplitScreenPreview();

                // Clean up any remaining modals (exclude permanent UI elements)
                const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
                existingModals.forEach(modal => {
                  try {
                    if (modal.parentNode &&
                        !modal.id.includes('bottom-panel') &&
                        !modal.id.includes('sticky-tabs-container') &&
                        modal.id !== 'bottom-panel' &&
                        modal.id !== 'sticky-tabs-container') {
                      if (modal.parentNode === document.body) {
                        document.body.removeChild(modal);
                      } else {
                        modal.parentNode.removeChild(modal);
                      }
                    }
                  } catch (error) {
                    console.log('Modal already removed:', error);
                  }
                });

                // Restore scrolling if no camera modals remain
                this.restoreScrollingIfNoCameraModals();

                // Small delay to ensure cleanup completes
                setTimeout(() => {
                  // Find the before photo and reopen comparison camera
                  const beforePhoto = this.photos.find(p =>
                    p.room === room && p.mode === 'before'
                  );

                  if (beforePhoto) {
                    this.showPhotoFullscreen(beforePhoto);
                  }
                }, 100);
              }
            });
          }

          const saveBtn = document.getElementById('btn-save');
          if (saveBtn) {
            saveBtn.addEventListener('click', () => {
              if (this.currentSplitScreen) {
                // Save the combined photo
                this.captureSplitScreenPhoto(
                  this.currentSplitScreen.beforeDataUrl,
                  this.currentSplitScreen.afterDataUrl,
                  this.currentSplitScreen.room
                );

                // Close split screen and return to gallery
                this.closeSplitScreenPreview();
              }
            });
          }
          
          // Photo event listeners moved to attachPhotoListeners() to prevent duplicates
          this.attachPhotoListeners();
        }
        
        
        updateTabs() {
          document.querySelectorAll('.photo-tab').forEach(tab => {
            const tabType = tab.dataset.tab;
            if (tabType === this.currentTab) {
              tab.style.background = '#F2C31B';
              tab.style.color = '#303030';
            } else {
              tab.style.background = 'transparent';
              tab.style.color = '#B3B3B3';
            }
          });
        }
        
        deletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            const photo = this.photos[photoIndex];
            const photoType = photo.mode === 'mix' ? 'combined before/after' : photo.mode;

            this.showDeleteConfirmation(photoType, photo.room, photoIndex);
          }
        }

        showDeleteConfirmation(photoType, room, photoIndex) {
          // Clean up any existing confirmation modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 3000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 3000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
              <!-- Title -->
              <h3 style="text-align: center; font-size: 20px; font-weight: bold; color: #1f2937; margin-bottom: 24px;">
                Are you sure?
              </h3>
              
              <!-- Buttons -->
              <div style="display: flex; gap: 12px;">
                <button id="cancel-delete-btn" style="flex: 1; padding: 12px 20px; border: 2px solid #d1d5db; background: white; color: #374151; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  Cancel
                </button>
                <button id="confirm-delete-btn" style="flex: 1; padding: 12px 20px; border: none; background: #F2C31B; color: #303030; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                  Delete
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Add hover effects
          const cancelBtn = document.getElementById('cancel-delete-btn');
          const confirmBtn = document.getElementById('confirm-delete-btn');

          cancelBtn.addEventListener('mouseenter', () => {
            cancelBtn.style.background = '#f9fafb';
            cancelBtn.style.borderColor = '#9ca3af';
          });
          cancelBtn.addEventListener('mouseleave', () => {
            cancelBtn.style.background = 'white';
            cancelBtn.style.borderColor = '#d1d5db';
          });

          confirmBtn.addEventListener('mouseenter', () => {
            confirmBtn.style.background = '#e6b800';
          });
          confirmBtn.addEventListener('mouseleave', () => {
            confirmBtn.style.background = '#F2C31B';
          });

          // Event listeners
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          confirmBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
            this.confirmDeletePhoto(photoIndex);
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        confirmDeletePhoto(photoIndex) {
          if (photoIndex >= 0 && photoIndex < this.photos.length) {
            this.photos.splice(photoIndex, 1);
            
            // Save changes to localStorage
            this.savePhotos();
            
            
            // Reassign names to maintain proper sequential numbering
            this.reassignPhotoNames();

            // Update photo grid without full DOM regeneration
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners(); // Re-attach event listeners for updated photo elements
            }

            // Update before photo grid in modal if it exists
            this.updateModalPhotoGrid();
          }
        }

        showDeleteAllConfirmation() {
          // Clean up any existing confirmation modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 3000"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 3000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
          `;

          modal.innerHTML = `
            <div style="background: white; border-radius: 12px; padding: 30px; max-width: 400px; width: 90%; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
              <div style="font-size: 48px; margin-bottom: 20px;">‚ö†Ô∏è</div>
              <h2 style="margin: 0 0 15px 0; color: #303030; font-size: 20px;">Delete All Photos?</h2>
              <p style="margin: 0 0 25px 0; color: #666; line-height: 1.4;">
                This will permanently delete all ${this.photos.length} photos from all rooms. This action cannot be undone.
              </p>
              <div style="display: flex; gap: 15px;">
                <button id="cancel-delete-all" style="flex: 1; background: #f3f4f6; color: #374151; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 500;">
                  Cancel
                </button>
                <button id="confirm-delete-all" style="flex: 1; background: #dc2626; color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: 500;">
                  Delete All
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          const cancelBtn = document.getElementById('cancel-delete-all');
          const confirmBtn = document.getElementById('confirm-delete-all');

          // Event listeners
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          confirmBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
            this.deleteAllPhotos();
          });

          // Close on background click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });

          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(modal);
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        deleteAllPhotos() {
          console.log(`üóëÔ∏è Deleting all ${this.photos.length} photos...`);

          // Clear the photos array
          this.photos = [];

          // Clear localStorage
          localStorage.removeItem('cleaning-photos');

          // Update the UI to show empty state
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }

          // Update before photo grid in modal if it exists
          this.updateModalPhotoGrid();


        }

        async showPhotoFullscreen(photo) {

          // Clean up any existing photo fullscreen modals first
          const existingPhotoModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingPhotoModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;
          
          if (photo.mode === 'before') {
            // Store the specific before photo that was clicked for later reference
            this.currentBeforePhoto = photo;

            // Restore the aspect ratio from the before photo
            if (photo.aspectRatio) {
              this.currentAspectRatio = photo.aspectRatio;
              // Update the aspect ratio overlay immediately to match before photo
              setTimeout(() => {
                this.updateAspectRatioOverlay();
              }, 100);
            }

            // Split screen: before photo and camera
            modal.innerHTML = this.getComparisonModalHTML(photo);

            document.body.appendChild(modal);

            // Prevent background scrolling when modal is open
            document.body.style.overflow = 'hidden';

            // Hide main room tabs and show camera button for photo capture
            this.hideMainRoomTabs();
            this.showCameraButton();
            
            // Initialize camera for comparison
            try {
              let stream;
              try {
                const constraints = this.getIOSCameraConstraints();
                stream = await navigator.mediaDevices.getUserMedia(constraints);
              } catch (backCameraError) {
                console.log('iPhone optimized camera not available, trying fallback:', backCameraError);
                const aspectRatio = this.getAspectRatio();
                const targetAspectRatio = aspectRatio.width / aspectRatio.height;

                stream = await navigator.mediaDevices.getUserMedia({
                  video: {
                    facingMode: 'environment'
                    // Removed aspectRatio constraint to get full native sensor area
                  }
                });
              }
              
              const video = document.getElementById('comparison-camera');
              video.srcObject = stream;
              
              let currentFacingMode = 'environment';
              let currentZoom = this.currentBeforePhoto?.zoomLevel || 1; // Use before photo's zoom level
              
              // Initialize zoom controls for comparison camera
              this.initializeZoomControls(stream, 'comparison-camera', currentZoom, 'comparison');

              // Initialize aspect ratio button
              this.initializeAspectRatioButton();

              // Initialize aspect ratio overlay
              setTimeout(() => {
                this.updateAspectRatioOverlay();
              }, 100);

              // Close button
              document.getElementById('close-comparison-btn').addEventListener('click', () => {
                stream.getTracks().forEach(track => track.stop());
                document.body.removeChild(modal);
                this.hideCameraButton();
                this.showMainRoomTabs(); // Show room tabs when returning to gallery
                this.currentBeforePhoto = null; // Clear the reference

                // Restore background scrolling when modal is closed
                document.body.style.overflow = '';
              });
              
            } catch (error) {
              alert('Camera access denied or failed: ' + error.message);
              document.body.removeChild(modal);
              this.hideCameraButton();
              this.showMainRoomTabs(); // Show room tabs when returning to gallery
              this.currentBeforePhoto = null; // Clear the reference

              // Restore background scrolling when modal is closed
              document.body.style.overflow = '';
            }
            
          } else if (photo.mode === 'after') {
            // For after photos, find the linked before photo and open comparison camera for retaking
            const linkedBeforePhoto = this.photos.find(p => 
              p.id === photo.beforePhotoId && p.mode === 'before'
            );
            
            if (linkedBeforePhoto) {
              // Store the specific before photo that was clicked for later reference
              this.currentBeforePhoto = linkedBeforePhoto;
              
              // Split screen: before photo and camera
              modal.innerHTML = this.getComparisonModalHTML(linkedBeforePhoto);

              document.body.appendChild(modal);

              // Prevent background scrolling when modal is open
              document.body.style.overflow = 'hidden';

              // Hide main room tabs and show camera button for photo capture
              this.hideMainRoomTabs();
              this.showCameraButton();
              
              // Initialize camera for comparison
              try {
                let stream;
                try {
                  const constraints = this.getIOSCameraConstraints();
                  stream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (backCameraError) {
                  console.log('iPhone optimized camera not available, trying fallback:', backCameraError);
                  const aspectRatio = this.getAspectRatio();
                  const targetAspectRatio = aspectRatio.width / aspectRatio.height;

                  stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                      facingMode: 'environment',
                      aspectRatio: targetAspectRatio
                    }
                  });
                }
                
                const video = document.getElementById('comparison-camera');
                video.srcObject = stream;
                
                let currentFacingMode = 'environment';
                let currentZoom = linkedBeforePhoto?.zoomLevel || 1; // Use before photo's zoom level
                
                // Initialize zoom controls for comparison camera
                this.initializeZoomControls(stream, 'comparison-camera', currentZoom, 'comparison');

                // Initialize aspect ratio button
                this.initializeAspectRatioButton();

                // Initialize aspect ratio overlay
                setTimeout(() => {
                  this.updateAspectRatioOverlay();
                }, 100);

                // Close button
                document.getElementById('close-comparison-btn').addEventListener('click', () => {
                  stream.getTracks().forEach(track => track.stop());
                  document.body.removeChild(modal);
                  this.hideCameraButton();
                  this.showMainRoomTabs(); // Show room tabs when returning to gallery
                  this.currentBeforePhoto = null; // Clear the reference

                  // Restore background scrolling when modal is closed
                  document.body.style.overflow = '';
                });
                
              } catch (error) {
                alert('Camera access denied or failed: ' + error.message);
                document.body.removeChild(modal);
                this.hideCameraButton();
                this.showMainRoomTabs(); // Show room tabs when returning to gallery
                this.currentBeforePhoto = null; // Clear the reference

                // Restore background scrolling when modal is closed
                document.body.style.overflow = '';
              }
            } else {
              // Fallback: Regular fullscreen if no linked before photo found
              modal.innerHTML = `
                <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center;">
                  <img src="${photo.dataUrl}" style="width: 100vw; height: 100vh; object-fit: contain;" />
                  
                  <!-- Photo info overlay -->
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 40px 20px 20px; text-align: center; color: white;">
                    <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                      ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                    </div>
                    <div style="font-size: 16px; opacity: 0.9;">
                      ${new Date(photo.timestamp).toLocaleString()}
                    </div>
                  </div>
                  
                  <!-- Close button -->
                  <button id="close-photo-btn" style="position: absolute; top: 20px; right: 20px; background: transparent; color: #F2C31B; border: none; padding: 8px; border-radius: 50%; font-size: 18px; cursor: pointer;">
                    ‚úï
                  </button>
                </div>
              `;
              
              document.body.appendChild(modal);

              // Prevent background scrolling when modal is open
              document.body.style.overflow = 'hidden';

              document.getElementById('close-photo-btn').addEventListener('click', () => {
                document.body.removeChild(modal);

                // Restore UI elements when closing regular photo fullscreen
                this.showMainRoomTabs();
                document.body.style.overflow = '';
              });

              // Close on background click
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  document.body.removeChild(modal);

                  // Restore UI elements when closing regular photo fullscreen
                  this.showMainRoomTabs();
                  document.body.style.overflow = '';
                }
              });
            }
          } else {
            // Regular fullscreen for individual photos - show raw photo as taken, no templates
            const orientation = this.detectPhotoOrientation(photo.naturalWidth || 800, photo.naturalHeight || 600);

            modal.innerHTML = `
              <div style="position: relative; width: 100vw; height: 100vh; display: flex; align-items: flex-start; justify-content: center; overflow: auto; background: rgba(0,0,0,0.95); padding-top: 80px; padding-bottom: 80px; box-sizing: border-box;">
                <!-- Scrollable container for actual size viewing -->
                <div id="photo-container" style="position: relative; display: flex; align-items: center; justify-content: center; max-width: 95vw; max-height: calc(100vh - 160px); overflow: auto; margin-top: 20px;">
                  <img id="fullscreen-photo" src="${photo.dataUrl}" style="display: block; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);" />
                </div>

                <!-- Photo info overlay -->
                <div style="position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; backdrop-filter: blur(10px); z-index: 10;">
                  <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                    ${photo.room.charAt(0).toUpperCase() + photo.room.slice(1).replace('-', ' ')} - ${photo.mode.charAt(0).toUpperCase() + photo.mode.slice(1)}
                  </div>
                  <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                    ${new Date(photo.timestamp).toLocaleString()}
                  </div>
                  <div style="font-size: 12px; opacity: 0.7;">
                    Orientation: ${orientation} | Raw photo as captured
                  </div>
                </div>
                
                <!-- Template selector for combined photos (larger icons, 2 rows) -->
                ${photo.mode === 'mix' ? `
                <div style="position: fixed; bottom: 20px; left: 20px; right: 20px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); z-index: 10; box-shadow: 0 4px 16px rgba(0,0,0,0.4);">
                  <!-- First row: Default and Landscape -->
                  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px;">
                    <!-- Default 4:3 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 12px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'default' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'default' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'default' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="default" style="display: none;" ${templateType === 'default' ? 'checked' : ''}>
                      <div style="width: 32px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 8px; color: #303030; font-weight: bold;">4:3</div>
                      </div>
                      <div style="font-size: 11px; font-weight: bold; text-align: center;">Default</div>
                      <div style="font-size: 9px; opacity: 0.8; text-align: center;">Standard</div>
                    </label>

                    <!-- Landscape 16:9 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 12px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'landscape' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'landscape' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="landscape" style="display: none;" ${templateType === 'landscape' ? 'checked' : ''}>
                      <div style="width: 40px; height: 22px; background: #F2C31B; border-radius: 2px; margin-bottom: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 8px; color: #303030; font-weight: bold;">16:9</div>
                      </div>
                      <div style="font-size: 11px; font-weight: bold; text-align: center;">Landscape</div>
                      <div style="font-size: 9px; opacity: 0.8; text-align: center;">YouTube</div>
                    </label>
                  </div>

                  <!-- Second row: Square, Portrait, Blog -->
                  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                    <!-- Square 1:1 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'square' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'square' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'square' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="square" style="display: none;" ${templateType === 'square' ? 'checked' : ''}>
                      <div style="width: 24px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 7px; color: #303030; font-weight: bold;">1:1</div>
                      </div>
                      <div style="font-size: 10px; font-weight: bold; text-align: center;">Square</div>
                      <div style="font-size: 8px; opacity: 0.8; text-align: center;">Instagram</div>
                    </label>

                    <!-- Portrait 4:5 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'portrait' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'portrait' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="portrait" style="display: none;" ${templateType === 'portrait' ? 'checked' : ''}>
                      <div style="width: 19px; height: 24px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 7px; color: #303030; font-weight: bold;">4:5</div>
                      </div>
                      <div style="font-size: 10px; font-weight: bold; text-align: center;">Portrait</div>
                      <div style="font-size: 8px; opacity: 0.8; text-align: center;">LinkedIn</div>
                    </label>

                    <!-- Blog 3:2 -->
                    <label style="display: flex; flex-direction: column; align-items: center; color: white; cursor: pointer; padding: 10px; border-radius: 6px; transition: all 0.2s; border: 2px solid ${templateType === 'blog' ? '#F2C31B' : 'transparent'}; background: ${templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'};" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='${templateType === 'blog' ? 'rgba(242, 195, 27, 0.2)' : 'transparent'}'">
                      <input type="radio" name="template-selector" value="blog" style="display: none;" ${templateType === 'blog' ? 'checked' : ''}>
                      <div style="width: 28px; height: 19px; background: #F2C31B; border-radius: 2px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                        <div style="font-size: 7px; color: #303030; font-weight: bold;">3:2</div>
                      </div>
                      <div style="font-size: 10px; font-weight: bold; text-align: center;">Blog</div>
                      <div style="font-size: 8px; opacity: 0.8; text-align: center;">Articles</div>
                    </label>
                  </div>

                </div>
                ` : ''}

                
                <!-- Close button -->
                <button id="close-photo-btn" style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: #F2C31B; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; backdrop-filter: blur(10px); z-index: 10;">
                  ‚úï
                </button>
              </div>
            `;
            
            document.body.appendChild(modal);

            // Prevent background scrolling when modal is open
            document.body.style.overflow = 'hidden';

            // Set default to fit screen mode
            const imgElement = modal.querySelector('#fullscreen-photo');
            const imgContainer = modal.querySelector('#photo-container');
            
            // Configure for fit-to-screen display
            imgElement.style.maxWidth = '100%';
            imgElement.style.maxHeight = '100%';
            imgElement.style.width = 'auto';
            imgElement.style.height = 'auto';
            imgContainer.style.maxWidth = '95vw';
            imgContainer.style.maxHeight = '95vh';
            imgContainer.style.overflow = 'hidden';

            // Template selector functionality (only for combined photos)
            if (photo.mode === 'mix') {
              const templateRadios = modal.querySelectorAll('input[name="template-selector"]');
              templateRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                  if (e.target.checked) {
                    const newTemplate = e.target.value;
                    console.log('Changing template for this photo to:', newTemplate);
                    
                    // Show loading state
                    const imgElement = modal.querySelector('#fullscreen-photo');
                    if (imgElement) {
                      imgElement.style.opacity = '0.5';
                    }
                    
                    // Regenerate this specific photo with new template
                    this.regenerateSpecificPhoto(photo, newTemplate, modal);
                  }
                });
              });
            }

            document.getElementById('close-photo-btn').addEventListener('click', () => {
              document.body.removeChild(modal);

              // Restore UI elements when closing regular photo fullscreen
              this.showMainRoomTabs();
              document.body.style.overflow = '';
            });

            // Close on background click
            modal.addEventListener('click', (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);

                // Restore UI elements when closing regular photo fullscreen
                this.showMainRoomTabs();
                document.body.style.overflow = '';
              }
            });
          }
        }
        
        captureComparisonPhoto(video, stream, beforePhoto) {
          console.log('üì∏ Capturing comparison photo with aspect ratio:', this.currentAspectRatio || beforePhoto.aspectRatio);
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Get the target aspect ratio for cropping
          const targetAspectRatio = beforePhoto.aspectRatio || this.currentAspectRatio || '4:3';
          console.log('üì∏ Target aspect ratio for capture:', targetAspectRatio);

          // Calculate crop dimensions based on aspect ratio
          let cropWidth, cropHeight, cropX, cropY;
          const videoWidth = video.videoWidth;
          const videoHeight = video.videoHeight;
          const videoAspectRatio = videoWidth / videoHeight;

          if (targetAspectRatio === '4:3') {
            // Horizontal mode: 4:3 aspect ratio
            canvas.width = 800;
            canvas.height = 600; // 4:3 ratio

            // Crop to fit 4:3 from center of video
            if (videoAspectRatio > (4/3)) {
              // Video is wider, crop sides
              cropHeight = videoHeight;
              cropWidth = videoHeight * (4/3);
              cropX = (videoWidth - cropWidth) / 2;
              cropY = 0;
            } else {
              // Video is taller, crop top/bottom
              cropWidth = videoWidth;
              cropHeight = videoWidth * (3/4);
              cropX = 0;
              cropY = (videoHeight - cropHeight) / 2;
            }
          } else {
            // Vertical mode: 2:3 aspect ratio
            canvas.width = 600;
            canvas.height = 900; // 2:3 ratio

            // Crop to fit 2:3 from center of video
            if (videoAspectRatio > (2/3)) {
              // Video is wider, crop sides significantly
              cropHeight = videoHeight;
              cropWidth = videoHeight * (2/3);
              cropX = (videoWidth - cropWidth) / 2;
              cropY = 0;
            } else {
              // Video is taller, crop top/bottom
              cropWidth = videoWidth;
              cropHeight = videoWidth * (3/2);
              cropX = 0;
              cropY = (videoHeight - cropHeight) / 2;
            }
          }

          console.log(`üì∏ Video: ${videoWidth}x${videoHeight}, Crop: ${cropWidth}x${cropHeight} at (${cropX},${cropY}), Canvas: ${canvas.width}x${canvas.height}`);

          // Draw the cropped video frame
          ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, canvas.width, canvas.height);

          const dataUrl = canvas.toDataURL('image/jpeg', 0.6);

          // Automatically save the "after" photo
          this.saveAfterPhotoToAll(dataUrl, beforePhoto);

          // Stop camera stream
          stream.getTracks().forEach(track => track.stop());

          // Close modal overlays only (exclude permanent UI elements)
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
          existingModals.forEach(modal => {
            try {
              if (modal.parentNode &&
                  !modal.id.includes('bottom-panel') &&
                  !modal.id.includes('sticky-tabs-container') &&
                  modal.id !== 'bottom-panel' &&
                  modal.id !== 'sticky-tabs-container') {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else if (modal.parentNode) {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Restore scrolling if no camera modals remain
          this.restoreScrollingIfNoCameraModals();

          // Small delay to ensure cleanup completes before updating gallery
          setTimeout(() => {
            // Check if photo was taken from gallery dummy card
            if (this.galleryReturnContext && this.galleryReturnContext.returnToGallery) {
              console.log('Returning to gallery after photo from dummy card');
              
              // Clear the gallery return context
              this.galleryReturnContext = null;
              
              // Clear the before photo reference
              this.currentBeforePhoto = null;
              
              // Hide action buttons and restore UI
              this.hideActionButtons();
              this.showMainRoomTabs();
              document.body.style.overflow = '';
              
              // Return to All Photos gallery
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 200);
              
            } else {
              // Normal flow - update main gallery
              const photosContainer = document.getElementById('photos-container');
              if (photosContainer) {
                photosContainer.innerHTML = this.getPhotosHTML();
                this.attachPhotoListeners(); // Re-attach event listeners for new photo elements
              }

              // Hide action buttons and return to gallery view
              this.hideActionButtons();
              
              // Clear the before photo reference
              this.currentBeforePhoto = null;
              
              // Auto-cycle to next unpaired before photo in current room
              // Only auto-cycle if we're still in the same room where the photo was taken
              if (this.currentRoom === beforePhoto.room) {
                this.autoCycleToNextBeforePhoto(this.currentRoom);
              } else {
                // User switched rooms - just restore the UI and return to gallery
                this.showMainRoomTabs();
                this.hideActionButtons();
                document.body.style.overflow = '';
              }
            }
          }, 100);
        }
        
        autoCycleToNextBeforePhoto(room) {
          // Find all before photos in this room that don't have corresponding after photos
          const beforePhotos = this.photos.filter(p => p.room === room && p.mode === 'before');
          const afterPhotos = this.photos.filter(p => p.room === room && p.mode === 'after');
          
          // Find before photos that don't have a corresponding after photo
          const unpairedBeforePhotos = beforePhotos.filter(beforePhoto => {
            return !afterPhotos.some(afterPhoto => afterPhoto.beforePhotoId === beforePhoto.id);
          });
          
          if (unpairedBeforePhotos.length > 0) {
            // Sort by timestamp to get the next one chronologically
            unpairedBeforePhotos.sort((a, b) => a.timestamp - b.timestamp);
            const nextBeforePhoto = unpairedBeforePhotos[0];
            
            console.log('Auto-cycling to next before photo:', nextBeforePhoto);
            
            // Open comparison modal with the next before photo
            this.showPhotoFullscreen(nextBeforePhoto);
          } else {
            console.log('All before photos in room', room, 'have been paired with after photos');

            // Restore UI when all photos are paired - return to gallery
            this.showMainRoomTabs();
            this.hideActionButtons();
            document.body.style.overflow = '';

            // Update the photo grid to show current room
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners();
            }
          }
        }
        
        openComparisonModal(beforePhoto) {
          // Create modal container
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: black; z-index: 2000; display: flex; align-items: center; justify-content: center;
          `;
          
          // Store the specific before photo that was clicked for later reference
          this.currentBeforePhoto = beforePhoto;
          
          // Split screen: before photo and camera
          modal.innerHTML = this.getComparisonModalHTML(beforePhoto);
          
          document.body.appendChild(modal);

          // Prevent background scrolling when modal is open
          document.body.style.overflow = 'hidden';

          // Hide main room tabs and show camera button for photo capture
          this.hideMainRoomTabs();
          this.showCameraButton();
          
          // Initialize camera for comparison
          this.initializeComparisonCamera(modal);
        }
        
        async initializeComparisonCamera(modal) {
          try {
            let stream;
            try {
              // Try iPhone optimized constraints first
              const constraints = this.getIOSCameraConstraints();
              stream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (backCameraError) {
              console.log('iPhone optimized camera not available, trying fallback:', backCameraError);
              const aspectRatio = this.getAspectRatio();
              const targetAspectRatio = aspectRatio.width / aspectRatio.height;

              stream = await navigator.mediaDevices.getUserMedia({
                video: {
                  facingMode: 'environment'
                  // Removed aspectRatio constraint to get full native sensor area
                }
              });
            }
            
            const video = document.getElementById('comparison-camera');
            video.srcObject = stream;
            
            let currentFacingMode = 'environment';
            let currentZoom = this.currentBeforePhoto?.zoomLevel || 1; // Use before photo's zoom level
            
            // Initialize zoom controls for comparison camera
            this.initializeZoomControls(stream, 'comparison-camera', currentZoom, 'comparison');

            // Initialize aspect ratio button
            this.initializeAspectRatioButton();

            // Initialize aspect ratio overlay
            setTimeout(() => {
              this.updateAspectRatioOverlay();
            }, 100);

            // Close button
            document.getElementById('close-comparison-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(modal);
              this.hideCameraButton();
              this.showMainRoomTabs(); // Show room tabs when returning to gallery
              this.currentBeforePhoto = null; // Clear the reference

              // Restore background scrolling when modal is closed
              document.body.style.overflow = '';
            });
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
            document.body.removeChild(modal);
            this.hideCameraButton();
            this.showMainRoomTabs(); // Show room tabs when returning to gallery
            this.currentBeforePhoto = null; // Clear the reference

            // Restore background scrolling when modal is closed
            document.body.style.overflow = '';
          }
        }
        
        generatePhotoName(room, mode) {
          // Get all photos for this room and mode, sorted by timestamp (oldest first)
          const roomPhotos = this.photos
            .filter(p => p.room === room && p.mode === mode)
            .sort((a, b) => a.timestamp - b.timestamp);
          
          // The position should be based on the chronological order in the grid
          // Since photos are sorted by timestamp, the position is the index + 1
          const position = roomPhotos.length + 1;
          
          // Create simple name: "kitchen 1", "kitchen 2", etc.
          const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
          return `${roomName} ${position}`;
        }

        // Function to reassign names to all photos based on their current grid position
        reassignPhotoNames() {
          const rooms = ['kitchen', 'bathroom', 'bedroom', 'living-room', 'dining-room', 'office'];
          
          rooms.forEach(room => {
            // Get all before photos for this room, sorted by timestamp (oldest first)
            const beforePhotos = this.photos
              .filter(p => p.room === room && p.mode === 'before')
              .sort((a, b) => a.timestamp - b.timestamp);
            
            // Reassign names based on chronological position
            beforePhotos.forEach((photo, index) => {
              const roomName = room.charAt(0).toUpperCase() + room.slice(1).replace('-', ' ');
              const newName = `${roomName} ${index + 1}`;
              photo.name = newName;
              
              // Also update any linked after photos
              const afterPhoto = this.photos.find(p => 
                p.mode === 'after' && p.beforePhotoId === photo.id
              );
              if (afterPhoto) {
                afterPhoto.name = newName;
              }
            });
          });
          
          this.savePhotos();
        }

        saveAfterPhotoToAll(afterPhotoDataUrl, beforePhoto) {
          // Check if there's already an after photo linked to this before photo
          const existingAfterPhotoIndex = this.photos.findIndex(p => 
            p.mode === 'after' && p.beforePhotoId === beforePhoto.id
          );

          // Use the same name as the before photo
          const afterPhotoName = beforePhoto.name;

          const afterPhoto = {
            id: Date.now(),
            dataUrl: afterPhotoDataUrl,
            room: beforePhoto.room,
            mode: 'after', // Save as after photo for split-screen display
            name: afterPhotoName,
            timestamp: Date.now(),
            beforePhotoId: beforePhoto.id, // Link to specific before photo
            aspectRatio: beforePhoto.aspectRatio || this.currentAspectRatio || '4:3' // Inherit aspect ratio from before photo
          };

          if (existingAfterPhotoIndex !== -1) {
            // Replace existing after photo
            this.photos[existingAfterPhotoIndex] = afterPhoto;
            console.log('Replaced existing after photo for before photo:', beforePhoto.id);
          } else {
            // Add new after photo
            this.photos.push(afterPhoto);
            console.log('Added new after photo for before photo:', beforePhoto.id);
          }

          // Automatically create combined photo using current template
          this.createCombinedPhoto(beforePhoto.dataUrl, afterPhotoDataUrl, beforePhoto.room, beforePhoto.name, this.currentTemplate);

          this.savePhotos();
        }
        
        createCombinedPhoto(beforeDataUrl, afterDataUrl, room, photoName, templateType = null) {
          // Use current global template if none specified
          const actualTemplateType = templateType || this.currentTemplate;
          console.log('Creating combined photo automatically for room:', room, 'with name:', photoName, 'template:', actualTemplateType);

          // Use createCombinedPhotoInMemory to actually create the photo
          this.createCombinedPhotoInMemory(beforeDataUrl, afterDataUrl, actualTemplateType, (combinedDataUrl) => {
            // Save the combined photo
            this.saveCombinedPhoto(combinedDataUrl, room, photoName, actualTemplateType);
          });
        }





        showTemplateSelector(beforePhoto, afterPhoto) {
          // Clean up any existing template selector modals first
          const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2500"]');
          existingModals.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Create modal container
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: rgba(0,0,0,0.8); z-index: 2500; 
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(10px);
          `;

          // Get template previews
          const templates = this.getTemplateOptions();

          modal.innerHTML = `
            <div style="
              background: white; 
              border-radius: 12px; 
              padding: 20px; 
              max-width: 90vw; 
              max-height: 90vh; 
              overflow-y: auto;
              box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            ">
              <h3 style="margin: 0 0 20px 0; text-align: center; color: #303030; font-size: 20px;">
                üìê Choose Template Size
              </h3>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                ${templates.map(template => `
                  <div class="template-option" data-template-type="${template.type}" style="
                    border: 2px solid #e1e5e9; 
                    border-radius: 8px; 
                    padding: 15px; 
                    text-align: center; 
                    cursor: pointer; 
                    transition: all 0.2s;
                    background: white;
                  " onmouseover="this.style.borderColor='#667eea'; this.style.background='#f8f9ff';" onmouseout="this.style.borderColor='#e1e5e9'; this.style.background='white';">
                    <div style="
                      width: 120px; 
                      height: ${template.previewHeight}px; 
                      background: #f0f0f0; 
                      border: 1px solid #ddd; 
                      margin: 0 auto 10px; 
                      border-radius: 4px;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      font-size: 12px;
                      color: #666;
                    ">
                      ${template.ratio}
                    </div>
                    <div style="font-weight: bold; margin-bottom: 5px; color: #303030;">
                      ${template.name}
                    </div>
                    <div style="font-size: 12px; color: #666;">
                      ${template.description}
                    </div>
                  </div>
                `).join('')}
              </div>

              <div style="display: flex; justify-content: center; gap: 15px;">
                <button id="cancel-template-btn" style="
                  background: #e1e5e9; 
                  color: #666; 
                  border: none; 
                  padding: 10px 20px; 
                  border-radius: 6px; 
                  cursor: pointer;
                  font-weight: bold;
                ">Cancel</button>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          // Add click handlers for template options
          modal.querySelectorAll('.template-option').forEach(option => {
            option.addEventListener('click', () => {
              const templateType = option.dataset.templateType;
              this.regenerateCombinedPhoto(beforePhoto, afterPhoto, templateType);
              document.body.removeChild(modal);
            });
          });

          // Cancel button
          modal.querySelector('#cancel-template-btn').addEventListener('click', () => {
            document.body.removeChild(modal);
          });

          // Close on backdrop click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
            }
          });
        }

        getTemplateOptions() {
          return [
            {
              type: 'default',
              name: 'Default',
              ratio: '4:3',
              description: 'Original size (800√ó600)',
              previewHeight: 90
            },
            {
              type: 'square',
              name: 'Square',
              ratio: '1:1',
              description: 'Perfect for social media',
              previewHeight: 120
            },
            {
              type: 'portrait',
              name: 'Portrait',
              ratio: '4:5',
              description: 'Tall format (800√ó1000)',
              previewHeight: 150
            },
            {
              type: 'landscape',
              name: 'Landscape',
              ratio: '16:9',
              description: 'Wide format (800√ó450)',
              previewHeight: 68
            }
          ];
        }

        regenerateCombinedPhoto(beforePhoto, afterPhoto, templateType) {
          console.log('Regenerating combined photo with template:', templateType);
          
          // Remove existing combined photos for this before/after pair
          this.photos = this.photos.filter(p => 
            !(p.mode === 'mix' && p.name === beforePhoto.name && p.room === beforePhoto.room)
          );

          // Create new combined photo with selected template
          this.createCombinedPhoto(beforePhoto.dataUrl, afterPhoto.dataUrl, beforePhoto.room, beforePhoto.name, templateType);

          // Update UI
          setTimeout(() => {
            const photosContainer = document.getElementById('photos-container');
            if (photosContainer) {
              photosContainer.innerHTML = this.getPhotosHTML();
              this.attachPhotoListeners();
            }
          }, 500); // Give time for photo generation
        }

        changeGlobalTemplate(newTemplate) {
          console.log('Changing global template from', this.currentTemplate, 'to', newTemplate);
          
          this.currentTemplate = newTemplate;
          
          // Show loading indicator
          const templateSelector = document.getElementById('template-selector');
          if (templateSelector) {
            templateSelector.style.opacity = '0.5';
            templateSelector.disabled = true;
          }
          
          // Find all combined photo pairs and regenerate them
          const beforeAfterPairs = [];
          
          // Group photos into before/after pairs
          this.photos.forEach(photo => {
            if (photo.mode === 'before') {
              const afterPhoto = this.photos.find(p => 
                p.mode === 'after' && p.beforePhotoId === photo.id
              );
              if (afterPhoto) {
                beforeAfterPairs.push({ before: photo, after: afterPhoto });
              }
            }
          });
          
          console.log('Found', beforeAfterPairs.length, 'photo pairs to regenerate');
          
          // Remove all existing combined photos
          this.photos = this.photos.filter(p => p.mode !== 'mix');
          
          // Regenerate all combined photos with new template
          let regeneratedCount = 0;
          const totalPairs = beforeAfterPairs.length;
          
          beforeAfterPairs.forEach((pair, index) => {
            setTimeout(() => {
              this.createCombinedPhoto(
                pair.before.dataUrl, 
                pair.after.dataUrl, 
                pair.before.room, 
                pair.before.name, 
                newTemplate
              );
              
              regeneratedCount++;
              
              // Update UI after all photos are regenerated
              if (regeneratedCount === totalPairs) {
                setTimeout(() => {
                  // Update main photos container
                  const photosContainer = document.getElementById('photos-container');
                  if (photosContainer) {
                    photosContainer.innerHTML = this.getPhotosHTML();
                    this.attachPhotoListeners();
                  }
                  
                  // Update gallery modal if it's open
                  const allPhotosContent = document.getElementById('all-photos-content');
                  if (allPhotosContent) {
                    allPhotosContent.innerHTML = this.getAllPhotosHTML();
                    // Reattach gallery photo listeners
                    this.attachGalleryPhotoListeners();
                  }
                  
                  // Re-enable template selector
                  if (templateSelector) {
                    templateSelector.style.opacity = '1';
                    templateSelector.disabled = false;
                  }
                  
                  // Save photos to localStorage after regeneration
                  this.savePhotos();
                  
                  // Backup: Ensure listeners are attached after a longer delay
                  setTimeout(() => {
                    const photosContainer = document.getElementById('photos-container');
                    if (photosContainer) {
                      this.attachPhotoListeners();
                    }
                    const allPhotosContent = document.getElementById('all-photos-content');
                    if (allPhotosContent) {
                      this.attachGalleryPhotoListeners();
                    }
                  }, 1000);
                  
                  console.log('Template change complete:', newTemplate);
                  console.log('Total photos after regeneration:', this.photos.length);
                }, 500);
              }
            }, index * 100); // Stagger the regeneration to avoid overwhelming the browser
          });
          
          // If no pairs to regenerate, just re-enable the selector
          if (totalPairs === 0) {
            if (templateSelector) {
              templateSelector.style.opacity = '1';
              templateSelector.disabled = false;
            }
          }
        }

        regenerateSpecificPhoto(photo, newTemplate, modal) {
          console.log('Photo:', photo);
          console.log('New template:', newTemplate);
          console.log('Modal:', modal);
          console.log('Current photos count:', this.photos.length);
          
          // Find the before and after photos that created this combined photo
          const beforePhoto = this.photos.find(p => 
            p.mode === 'before' && p.room === photo.room && p.name === photo.name
          );
          const afterPhoto = this.photos.find(p => 
            p.mode === 'after' && p.room === photo.room && p.name === photo.name
          );
          
          console.log('Found before photo:', beforePhoto);
          console.log('Found after photo:', afterPhoto);
          
          if (!beforePhoto || !afterPhoto) {
            console.error('Could not find before/after photos for regeneration');
            console.error('Looking for room:', photo.room, 'name:', photo.name);
            console.error('Available photos:', this.photos.map(p => ({mode: p.mode, room: p.room, name: p.name})));
            
            // Reset image opacity and show error
            const imgElement = modal.querySelector('#fullscreen-photo');
            if (imgElement) {
              imgElement.style.opacity = '1';
            }
            return;
          }
          
          // Store original photo info before removal
          const originalPhotoInfo = {
            id: photo.id,
            room: photo.room,
            name: photo.name,
            timestamp: photo.timestamp
          };
          
          // Remove the old combined photo from the array
          const photoIndex = this.photos.findIndex(p => p.id === photo.id);
          if (photoIndex !== -1) {
            console.log('Removing old photo at index:', photoIndex);
            this.photos.splice(photoIndex, 1);
          }
          
          // Create new combined photo with the selected template and store reference
          this.createCombinedPhotoWithCallback(
            beforePhoto.dataUrl, 
            afterPhoto.dataUrl, 
            originalPhotoInfo.room, 
            originalPhotoInfo.name, 
            newTemplate,
            (createdPhoto) => {
              // Callback with the newly created photo
              this.handlePhotoRegenerated(createdPhoto, modal, originalPhotoInfo);
            }
          );
          
        }

        createCombinedPhotoWithCallback(beforeDataUrl, afterDataUrl, room, photoName, templateType = null, callback) {
          // Use current global template if none specified
          const actualTemplateType = templateType || this.currentTemplate;
          console.log('Creating combined photo with callback for room:', room, 'with name:', photoName, 'template:', actualTemplateType);

          // Use createCombinedPhotoInMemory to actually create the photo
          this.createCombinedPhotoInMemory(beforeDataUrl, afterDataUrl, actualTemplateType, (combinedDataUrl) => {
            // Save the combined photo with callback
            this.saveCombinedPhotoWithCallback(combinedDataUrl, room, photoName, actualTemplateType, callback);
          });
        }


        saveCombinedPhotoWithCallback(combinedDataUrl, room, photoName, templateType = 'default', callback) {
          console.log('saveCombinedPhoto with callback called with name:', photoName, 'template:', templateType);
          
          // Create the combined photo with the same name as before/after photos
          const combinedPhoto = {
            id: Date.now(),
            dataUrl: combinedDataUrl,
            room: room,
            mode: 'mix',
            name: photoName, // Use the same name as before/after photos
            templateType: templateType, // Store template type for future reference
            timestamp: Date.now()
          };
          
          console.log('Created combined photo with callback:', combinedPhoto);
          
          // Add the combined photo
          this.photos.push(combinedPhoto);
          
          // Call the callback immediately with the created photo
          if (callback) {
            callback(combinedPhoto);
          }
          
          return combinedPhoto;
        }

        handlePhotoRegenerated(createdPhoto, modal, originalPhotoInfo) {
          console.log('Handling photo regeneration with created photo:', createdPhoto);
          
          // Update the image in the modal
          const imgElement = modal.querySelector('#fullscreen-photo');
          if (imgElement) {
            imgElement.src = createdPhoto.dataUrl;
            imgElement.style.opacity = '1'; // Remove loading state
            
            // Update the photo info
            const infoDiv = modal.querySelector('[style*="position: fixed; top: 20px; left: 20px"]');
            if (infoDiv) {
              const orientation = this.detectPhotoOrientation(createdPhoto.naturalWidth || 800, createdPhoto.naturalHeight || 600);
              infoDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                  ${createdPhoto.room.charAt(0).toUpperCase() + createdPhoto.room.slice(1).replace('-', ' ')} - ${createdPhoto.mode.charAt(0).toUpperCase() + createdPhoto.mode.slice(1)}
                </div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">
                  ${new Date(createdPhoto.timestamp).toLocaleString()}
                </div>
                <div style="font-size: 12px; opacity: 0.7;">
                  Orientation: ${orientation} | Template: ${this.getTemplateDisplayName(createdPhoto.templateType)}
                </div>
              `;
            }
          }
          
          // Update main photos container
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }
          
          // Update gallery modal if it's open
          const allPhotosContent = document.getElementById('all-photos-content');
          if (allPhotosContent) {
            allPhotosContent.innerHTML = this.getAllPhotosHTML();
            this.attachGalleryPhotoListeners();
          }
          
          // Save updated photos
          this.savePhotos();
          
          // Reattach template selector listeners to the modal
          this.reattachTemplateListeners(modal, createdPhoto);
          
          console.log('Photo regeneration complete with template:', createdPhoto.templateType);
        }

        reattachTemplateListeners(modal, photo) {
          console.log('Reattaching template listeners for photo:', photo);
          
          if (!modal || !photo || photo.mode !== 'mix') {
            console.log('Skipping template listener reattachment - not a combined photo');
            return;
          }
          
          // Reattach radio button listeners (always visible now)
          const templateRadios = modal.querySelectorAll('input[name="template-selector"]');
          console.log('Found template radios:', templateRadios.length);
          
          templateRadios.forEach(radio => {
            // Remove existing listeners by cloning
            const newRadio = radio.cloneNode(true);
            radio.parentNode.replaceChild(newRadio, radio);
            
            // Add fresh event listener
            newRadio.addEventListener('change', (e) => {
              if (e.target.checked) {
                const newTemplate = e.target.value;
                console.log('Template changed to:', newTemplate);
                
                // Show loading state
                const imgElement = modal.querySelector('#fullscreen-photo');
                if (imgElement) {
                  imgElement.style.opacity = '0.5';
                }
                
                // Regenerate this specific photo with new template
                this.regenerateSpecificPhoto(photo, newTemplate, modal);
              }
            });
          });
          
          console.log('Template listeners reattached successfully');
        }
        
        
        showSplitScreenPreview(beforeDataUrl, afterDataUrl, room) {
          // Clean up any existing split screen modals first
          const existingSplitScreens = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          existingSplitScreens.forEach(existing => {
            if (existing.parentNode) {
              document.body.removeChild(existing);
            }
          });

          // Create a new modal for split screen preview
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95); z-index: 2000; display: flex;
            flex-direction: column;
          `;

          modal.innerHTML = this.getSplitScreenPreviewHTML(beforeDataUrl, afterDataUrl, room);
          document.body.appendChild(modal);

          // Show action buttons in bottom panel
          this.showActionButtons();

          // Store current split screen data for button handlers
          this.currentSplitScreen = {
            beforeDataUrl,
            afterDataUrl,
            room,
            modal
          };

          // Close button event listener
          document.getElementById('close-split-btn').addEventListener('click', () => {
            this.closeSplitScreenPreview();
          });
        }

        closeSplitScreenPreview() {
          if (this.currentSplitScreen && this.currentSplitScreen.modal) {
            try {
              if (this.currentSplitScreen.modal.parentNode) {
                if (this.currentSplitScreen.modal.parentNode === document.body) {
                  document.body.removeChild(this.currentSplitScreen.modal);
                } else {
                  this.currentSplitScreen.modal.parentNode.removeChild(this.currentSplitScreen.modal);
                }
              }
            } catch (error) {
              console.log('Split screen modal already removed:', error);
            }
          }

          // Clean up any remaining split screen modals that might be orphaned
          const splitScreenModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 2000"], [style*="position: fixed"][style*="z-index: 2002"]');
          splitScreenModals.forEach(modal => {
            try {
              if (modal.parentNode) {
                if (modal.parentNode === document.body) {
                  document.body.removeChild(modal);
                } else {
                  modal.parentNode.removeChild(modal);
                }
              }
            } catch (error) {
              console.log('Modal already removed:', error);
            }
          });

          // Hide action buttons and show camera button
          this.hideActionButtons();

          // Clear current split screen data
          this.currentSplitScreen = null;
        }
        
        captureSplitScreenPhoto(beforeDataUrl, afterDataUrl, room) {
          // Create a temporary fullscreen container for the split-screen photo
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: white; z-index: 9999;
          `;
          
          tempContainer.innerHTML = `
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column;">
              <!-- Before photo (top half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${beforeDataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  BEFORE
                </div>
              </div>
              
              <!-- Divider line -->
              <div style="width: 100%; height: 4px; background: #000;"></div>
              
              <!-- After photo (bottom half) -->
              <div style="position: relative; width: 100%; height: 50%; background: black; overflow: hidden;">
                <img src="${afterDataUrl}" style="width: 100%; height: 100%; object-fit: contain;" />
                <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 20px; border-radius: 20px; font-size: 18px; font-weight: bold;">
                  AFTER
                </div>
              </div>
            </div>
          `;
          
          document.body.appendChild(tempContainer);
          
          // Use html2canvas to capture the entire screen
          setTimeout(() => {
            this.captureScreenAsImage(tempContainer, room);
          }, 500); // Give time for images to load
        }
        
        captureScreenAsImage(container, room) {
          // Create a canvas to capture the screen
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to match the container
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          
          // Fill white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Get all images from the container
          const images = container.querySelectorAll('img');
          let imagesLoaded = 0;
          const totalImages = images.length;
          
          if (totalImages === 0) {
            // No images, just save the container
            this.saveCombinedPhoto(canvas.toDataURL('image/jpeg', 0.9), room);
            document.body.removeChild(container);
            return;
          }
          
          const onImageLoad = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
              // All images loaded, now draw them
              const halfHeight = canvas.height / 2;
              
              // Draw before photo (top half)
              const beforeImg = images[0];
              ctx.drawImage(beforeImg, 0, 0, canvas.width, halfHeight);
              
              // Draw divider line
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(0, halfHeight);
              ctx.lineTo(canvas.width, halfHeight);
              ctx.stroke();
              
              // Draw after photo (bottom half)
              const afterImg = images[1];
              ctx.drawImage(afterImg, 0, halfHeight, canvas.width, halfHeight);
              
              // Add labels
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.font = 'bold 18px Arial';
              ctx.textAlign = 'center';
              
              // Before label
              ctx.fillRect(canvas.width/2 - 50, 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('BEFORE', canvas.width/2, 40);
              
              // After label
              ctx.fillStyle = 'rgba(0,0,0,0.8)';
              ctx.fillRect(canvas.width/2 - 50, halfHeight + 20, 100, 30);
              ctx.fillStyle = '#ffffff';
              ctx.fillText('AFTER', canvas.width/2, halfHeight + 40);
              
              // Convert to data URL and save
              const combinedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
              this.saveCombinedPhoto(combinedDataUrl, room);
              
              // Clean up
              document.body.removeChild(container);
            }
          };
          
          // Set up image load handlers
          images.forEach(img => {
            if (img.complete) {
              onImageLoad();
            } else {
              img.onload = onImageLoad;
            }
          });
        }
        
        saveCombinedPhoto(combinedDataUrl, room, photoName, templateType = 'default') {
          console.log('saveCombinedPhoto called with name:', photoName, 'template:', templateType);
          
          // Create the combined photo with the same name as before/after photos
          const combinedPhoto = {
            id: Date.now(),
            dataUrl: combinedDataUrl,
            room: room,
            mode: 'mix',
            name: photoName, // Use the same name as before/after photos
            templateType: templateType, // Store template type for future reference
            timestamp: Date.now()
          };
          
          console.log('Created combined photo:', combinedPhoto);

          // Add the combined photo
          this.photos.push(combinedPhoto);
          console.log('üì∏ Added combined photo to photos array. Total photos:', this.photos.length);
          console.log('üì∏ Photos array now contains:', this.photos.map(p => `${p.mode} - ${p.name} (${p.room})`));

          // Keep before photo in main gallery (don't move to archived)
          // The combined photo will appear in All Photos gallery separately

          this.savePhotos();

          // Update UI immediately
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            console.log('üì∏ Updating main photos grid after combined photo creation');
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }

          // Photo saved successfully - modal closing handled by caller
        }
        
        async openCameraForRoom(room) {
          // Set the current room
          this.currentRoom = room;
          
          // Open camera
          await this.openCamera();
        }
        
        async openCamera() {
          console.log('Opening camera...');

          // Prevent multiple camera modals from opening simultaneously
          if (this.isOpeningCamera) {
            console.log('Camera already opening, ignoring request');
            return;
          }
          this.isOpeningCamera = true;

          try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
              alert('Camera not supported on this device');
              this.isOpeningCamera = false;
              return;
            }

            // Clean up any existing camera modals first
            const existingCameraModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index: 1000"]');
            existingCameraModals.forEach(existing => {
              if (existing.parentNode) {
                document.body.removeChild(existing);
              }
            });

            // Restore scrolling if no camera modals remain
            this.restoreScrollingIfNoCameraModals();

            // Try iPhone optimized constraints first, fallback to basic
            let stream;
            try {
              const constraints = this.getIOSCameraConstraints();
              stream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (backCameraError) {
              console.log('iPhone optimized camera not available, trying fallback:', backCameraError);
              const aspectRatio = this.getAspectRatio();
              const targetAspectRatio = aspectRatio.width / aspectRatio.height;

              stream = await navigator.mediaDevices.getUserMedia({
                video: {
                  facingMode: 'environment'
                  // Removed aspectRatio constraint to get full native sensor area
                }
              });
            }

            // Create fullscreen camera modal
            const modal = document.createElement('div');
            modal.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
              background: black; z-index: 1000; display: flex; 
              flex-direction: column; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = this.getBeforePhotoModalHTML();
            
            document.body.appendChild(modal);
            console.log('Before photo modal created and added to DOM');

            // Prevent background scrolling when modal is open
            document.body.style.overflow = 'hidden';

            // Hide main room tabs and show camera button for photo capture
            this.hideMainRoomTabs();
            this.showCameraButton();
            
            const video = document.getElementById('camera-video');
            console.log('Video element found:', video);
            if (video) {
              video.srcObject = stream;
              console.log('Stream assigned to video');
            } else {
              console.error('Video element not found!');
            }
            
            // Store current facing mode and zoom level
            let currentFacingMode = 'environment'; // Start with back camera
            let currentZoom = 1; // Start with 1x zoom
            this.currentBeforeZoom = currentZoom; // Track zoom for before photos
            
            // DISABLED zoom controls for testing
            // this.initializeZoomControls(stream, 'camera-video', currentZoom);

            // Initialize aspect ratio button
            this.initializeAspectRatioButton();

            // Initialize aspect ratio overlay
            setTimeout(() => {
              this.updateAspectRatioOverlay();
            }, 100);

            // Capture will be handled by the bottom panel camera button
            
            document.getElementById('close-before-modal-btn').addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              if (modal && modal.parentNode) {
                document.body.removeChild(modal);
              }
              this.isOpeningCamera = false; // Reset flag
              this.hideCameraButton(); // Hide camera button when closing modal
              this.showMainRoomTabs(); // Show room tabs when returning to gallery

              // Restore background scrolling when modal is closed
              document.body.style.overflow = '';
            });

            // Attach listeners to before photo items
            this.attachBeforePhotoListeners();
            
            // Auto-scroll to bottom to show latest photos
            setTimeout(() => {
              const beforePhotoGrid = document.getElementById('before-photo-grid');
              if (beforePhotoGrid) {
                beforePhotoGrid.scrollTop = beforePhotoGrid.scrollHeight;
              }
            }, 200);
            
          } catch (error) {
            alert('Camera access denied or failed: ' + error.message);
            this.isOpeningCamera = false; // Reset flag on error
            this.hideCameraButton();
            this.showMainRoomTabs(); // Show room tabs when returning to gallery
          }
        }
        
        captureFromCameraModal() {
          // Get the camera video element
          const video = document.getElementById('camera-video');
          if (!video || !video.srcObject) {
            console.error('Camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Capture the before photo
          this.capturePhoto(video, stream);
        }
        
        captureFromComparisonModal() {
          // Get the comparison camera video element
          const video = document.getElementById('comparison-camera');
          if (!video || !video.srcObject) {
            console.error('Comparison camera not found or no stream');
            return;
          }
          
          // Get the stream from the video element
          const stream = video.srcObject;
          
          // Use the specific before photo that was clicked to open the comparison modal
          const beforePhoto = this.currentBeforePhoto;

          if (!beforePhoto) {
            console.error('No before photo reference found - this should not happen');
            return;
          }
          
          // Capture the after photo
          this.captureComparisonPhoto(video, stream, beforePhoto);
        }
        
        // Helper function to get aspect ratio based on current setting
        getAspectRatio() {
          // Default to 4:3 ratio if not set (for stack mode)
          if (!this.currentAspectRatio) {
            this.currentAspectRatio = '4:3';
          }

          if (this.currentAspectRatio === '4:3') {
            return { width: 4, height: 3 }; // 4:3 for stack mode (landscape crop from portrait)
          } else if (this.currentAspectRatio === '2:3' || this.currentAspectRatio === '3:4') {
            return { width: 2, height: 3 }; // 2:3 for side-by-side mode (portrait crop)
          } else {
            return { width: 2, height: 3 }; // Default fallback to portrait
          }
        }

        // Get camera constraints for maximum sensor area
        getIOSCameraConstraints() {
          console.log(`Requesting maximum camera sensor area for ${this.currentAspectRatio}`);

          // Request 4:3 aspect ratio to match iPhone native camera's full sensor area
          // iPhone sensor is 4032√ó3024 (4:3 ratio) - same as native camera app
          const constraints = {
            video: {
              facingMode: 'environment',
              aspectRatio: { ideal: 4/3 },
              width: { ideal: 4032 },
              height: { ideal: 3024 }
            }
          };

          console.log('Requesting 4:3 camera constraints to match native camera sensor:', constraints);
          return constraints;
        }

        // Switch between aspect ratios
        switchAspectRatio() {
          const previousRatio = this.currentAspectRatio;
          this.currentAspectRatio = this.currentAspectRatio === '4:3' ? '2:3' : '4:3';
          console.log('üîÑ Switched aspect ratio from', previousRatio, 'to', this.currentAspectRatio);

          // Update UI button text
          const aspectRatioBtn = document.getElementById('aspect-ratio-btn');
          if (aspectRatioBtn) {
            aspectRatioBtn.textContent = this.currentAspectRatio;
            console.log('Updated button text to:', this.currentAspectRatio);
          } else {
            console.log('Aspect ratio button not found when trying to update text');
          }

          // Update the visual overlay immediately
          this.updateAspectRatioOverlay();

          // Skip camera restart entirely - both modes use same 4:3 camera constraints
          // Only video styling and frame overlays change between modes
          console.log('Skipped camera restart - both modes use same 4:3 camera stream');
        }

        // Restart camera with new aspect ratio
        async restartCameraWithNewAspectRatio() {
          const videoElement = document.getElementById('camera-video') || document.getElementById('comparison-camera');
          if (!videoElement || !videoElement.srcObject) {
            return; // No active camera to restart
          }

          // Stop current stream
          const currentStream = videoElement.srcObject;
          currentStream.getTracks().forEach(track => track.stop());

          try {
            // Get new stream with updated constraints
            const constraints = this.getIOSCameraConstraints();
            const newStream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = newStream;

            console.log('Camera restarted with new aspect ratio:', this.currentAspectRatio);
          } catch (error) {
            console.error('Failed to restart camera with new aspect ratio:', error);
            // Fallback to basic constraints
            try {
              const aspectRatio = this.getAspectRatio();
              const basicConstraints = {
                video: {
                  facingMode: 'environment',
                  aspectRatio: aspectRatio.width / aspectRatio.height
                }
              };
              const fallbackStream = await navigator.mediaDevices.getUserMedia(basicConstraints);
              videoElement.srcObject = fallbackStream;
            } catch (fallbackError) {
              console.error('Fallback camera restart also failed:', fallbackError);
            }
          }
        }

        // Initialize aspect ratio button
        initializeAspectRatioButton() {
          const aspectRatioBtn = document.getElementById('aspect-ratio-btn');
          if (!aspectRatioBtn) {
            console.log('Aspect ratio button not found');
            return;
          }

          // Set button text to current aspect ratio
          aspectRatioBtn.textContent = this.currentAspectRatio || '4:3';
          console.log('Initialized aspect ratio button with:', this.currentAspectRatio || '4:3');

          // Remove any existing event listeners by cloning the button
          const newBtn = aspectRatioBtn.cloneNode(true);
          aspectRatioBtn.parentNode.replaceChild(newBtn, aspectRatioBtn);

          // Add click event listener to the new button
          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Aspect ratio button clicked');
            this.switchAspectRatio();
          });
        }

        // Get aspect ratio overlay HTML
        getAspectRatioOverlay() {
          const aspectRatio = this.getAspectRatio();
          const ratio = aspectRatio.width / aspectRatio.height;

          let overlayStyle = '';
          let overlayWidth = '';
          let overlayHeight = '';

          if (this.currentAspectRatio === '2:3') {
            // 2:3 ratio (0.667) - portrait orientation
            overlayWidth = '60%';  // Narrower width
            overlayHeight = '90%'; // Almost full height
            overlayStyle = `
              width: ${overlayWidth};
              height: ${overlayHeight};
              aspect-ratio: 2/3;
            `;
          } else {
            // 4:3 ratio (1.333) - landscape orientation
            overlayWidth = '90%';  // Almost full width
            overlayHeight = '67.5%'; // Calculated for 4:3 ratio
            overlayStyle = `
              width: ${overlayWidth};
              height: ${overlayHeight};
              aspect-ratio: 4/3;
            `;
          }

          return `
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; display: flex; align-items: center; justify-content: center;">
              <!-- Semi-transparent overlay covering full area -->
              <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3);"></div>

              <!-- Clear capture area -->
              <div style="${overlayStyle} border: 3px solid #F2C31B; border-radius: 8px; box-shadow: 0 0 20px rgba(242, 195, 27, 0.6), inset 0 0 20px rgba(242, 195, 27, 0.1); background: transparent; position: relative; z-index: 1;">
                <!-- Corner indicators -->
                <div style="position: absolute; top: -2px; left: -2px; width: 20px; height: 20px; border-top: 4px solid #F2C31B; border-left: 4px solid #F2C31B; border-radius: 4px 0 0 0;"></div>
                <div style="position: absolute; top: -2px; right: -2px; width: 20px; height: 20px; border-top: 4px solid #F2C31B; border-right: 4px solid #F2C31B; border-radius: 0 4px 0 0;"></div>
                <div style="position: absolute; bottom: -2px; left: -2px; width: 20px; height: 20px; border-bottom: 4px solid #F2C31B; border-left: 4px solid #F2C31B; border-radius: 0 0 0 4px;"></div>
                <div style="position: absolute; bottom: -2px; right: -2px; width: 20px; height: 20px; border-bottom: 4px solid #F2C31B; border-right: 4px solid #F2C31B; border-radius: 0 0 4px 0;"></div>

                <!-- Aspect ratio label -->
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: #F2C31B; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold; backdrop-filter: blur(10px);">
                  ${this.currentAspectRatio || '2:3'}
                </div>
              </div>
            </div>
          `;
        }

        // Update video element styling based on aspect ratio mode
        updateVideoStyling() {
          const aspectRatio = this.currentAspectRatio || '4:3';

          const videoElements = document.querySelectorAll('#camera-video, #comparison-camera');

          videoElements.forEach(video => {
            // Remove any wrapper that might exist from previous manual sizing
            const wrapper = video.parentElement.querySelector('.video-wrapper');
            if (wrapper && wrapper !== video.parentElement) {
              wrapper.parentElement.insertBefore(video, wrapper);
              wrapper.remove();
            }

            if (aspectRatio === '4:3') {
              // Stack mode: Fill full width but add top/bottom spacing for equal borders
              video.style.objectFit = 'cover';
              video.style.objectPosition = 'center center';
              video.style.width = '100%';
              video.style.height = '75%'; // Reduced height to create top/bottom black bars
            } else {
              // Side-by-side mode: Show full video with side black bars (keep as is - was perfect)
              video.style.objectFit = 'contain';
              video.style.objectPosition = 'center center';
              video.style.width = '100%';
              video.style.height = '100%';
            }

            video.style.margin = '0';
            video.style.display = 'block';
            video.style.transform = 'none';
          });
        }

        // Update aspect ratio overlay with frames and dimming
        updateAspectRatioOverlay() {

          // Update video styling based on aspect ratio mode
          this.updateVideoStyling();

          // Find all photo frame overlays and update them
          const overlays = document.querySelectorAll('.photo-frame-overlay');
          overlays.forEach(overlay => {
            // Determine if this is before or after mode
            const isAfterMode = document.getElementById('comparison-camera') !== null;
            const aspectRatio = this.currentAspectRatio || '4:3';

            // Calculate frame dimensions based on aspect ratio
            let frameWidth, frameHeight;
            const containerWidth = overlay.offsetWidth;
            const containerHeight = overlay.offsetHeight;
            const border = 10; // 10px border as requested

            // Get actual video stream dimensions
            const videoElement = document.querySelector('#camera-video, #comparison-camera');
            let actualVideoWidth, actualVideoHeight;

            if (videoElement && videoElement.videoWidth && videoElement.videoHeight) {
              actualVideoWidth = videoElement.videoWidth;
              actualVideoHeight = videoElement.videoHeight;
            } else {
              // Fallback dimensions
              actualVideoWidth = aspectRatio === '4:3' ? 3024 : 3024;
              actualVideoHeight = aspectRatio === '4:3' ? 2268 : 4032;
            }

            const actualVideoAspectRatio = actualVideoWidth / actualVideoHeight;
            const containerAspectRatio = containerWidth / containerHeight;

            // Calculate visible video dimensions based on object-fit mode
            let visibleVideoWidth, visibleVideoHeight;

            // Calculate visible video dimensions based on aspect ratio mode
            if (aspectRatio === '4:3') {
              // Stack mode uses object-fit: cover - video fills container
              visibleVideoWidth = containerWidth;
              visibleVideoHeight = containerHeight;
            } else {
              // Side-by-side mode uses object-fit: contain - video fits with black bars
              if (actualVideoAspectRatio > containerAspectRatio) {
                // Video is wider than container - constrained by width
                visibleVideoWidth = containerWidth;
                visibleVideoHeight = containerWidth / actualVideoAspectRatio;
              } else {
                // Video is taller than container - constrained by height
                visibleVideoHeight = containerHeight;
                visibleVideoWidth = containerHeight * actualVideoAspectRatio;
              }
            }

            // Now calculate frame based on desired aspect ratio, not actual video
            let targetAspectRatio;
            if (aspectRatio === '4:3') {
              // Stack mode: 4:3 individual ‚Üí Combined: 4:6 = 2:3 (portrait)
              targetAspectRatio = 4/3; // 1.333 - Individual frame for stacking
            } else {
              // Side-by-side mode: 3:4 individual ‚Üí Combined: 6:4 = 3:2 (landscape)
              targetAspectRatio = 3/4; // 0.750 - Individual frame for side-by-side
            }


            // Calculate frame size for target aspect ratio within visible video area
            const availableWidth = visibleVideoWidth - 2*border;
            const availableHeight = visibleVideoHeight - 2*border;

            if (aspectRatio === '4:3') {
              // Stack mode: Use full width for enlarged frame
              // Create symmetric top/bottom black borders like side-by-side has side borders
              frameWidth = availableWidth;
              frameHeight = frameWidth / targetAspectRatio;

              // Ensure frame doesn't exceed available height - if it does, scale down proportionally
              if (frameHeight > availableHeight) {
                frameHeight = availableHeight;
                frameWidth = frameHeight * targetAspectRatio;
              }
            } else {
              // Side-by-side mode: Height constrained to create side borders
              frameHeight = availableHeight;
              frameWidth = frameHeight * targetAspectRatio;

              // Ensure frame doesn't exceed available width
              if (frameWidth > availableWidth) {
                frameWidth = availableWidth;
                frameHeight = frameWidth / targetAspectRatio;
              }
            }


            // Ensure frame doesn't go negative
            if (frameWidth < 0) frameWidth = availableWidth * 0.9;
            if (frameHeight < 0) frameHeight = availableHeight * 0.9;

            const frameLeft = (containerWidth - frameWidth) / 2;
            const frameTop = (containerHeight - frameHeight) / 2;

            overlay.innerHTML = `
              <!-- Frame area -->
              <div style="position: absolute; top: ${frameTop}px; left: ${frameLeft}px; width: ${frameWidth}px; height: ${frameHeight}px; background: transparent; border: 2px solid white; z-index: 2;"></div>

              <!-- Mode label -->
              <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: bold; z-index: 10;">
                ${isAfterMode ? 'AFTER' : 'BEFORE'} - ${aspectRatio === '4:3' ? 'STACK' : 'SIDE-BY-SIDE'} (${aspectRatio})
              </div>
            `;
          });
        }

        // Initialize zoom controls for camera
        initializeZoomControls(stream, videoElementId, currentZoom = 1, mode = 'before') {
          const zoomControlsId = mode === 'comparison' ? 'zoom-controls-comparison' : 'zoom-controls';
          const zoomButtonClass = mode === 'comparison' ? 'zoom-btn-comparison' : 'zoom-btn';
          
          const zoomControls = document.getElementById(zoomControlsId);
          if (!zoomControls) {
            console.log('Zoom controls not found for mode:', mode);
            return;
          }

          const zoomButtons = zoomControls.querySelectorAll(`.${zoomButtonClass}`);
          
          // Set initial active button based on currentZoom
          zoomButtons.forEach(btn => {
            const btnZoom = parseFloat(btn.dataset.zoom);
            if (btnZoom === currentZoom) {
              btn.classList.add('active');
              btn.style.background = '#F2C31B';
              btn.style.color = '#303030';
            } else {
              btn.classList.remove('active');
              btn.style.background = 'rgba(255,255,255,0.2)';
              btn.style.color = 'white';
            }
          });
          
          // Apply initial zoom level
          setTimeout(() => {
            this.applyZoom(stream, videoElementId, currentZoom);
          }, 100);
          
          // Set up zoom button event listeners
          zoomButtons.forEach(button => {
            button.addEventListener('click', async () => {
              const newZoom = parseFloat(button.dataset.zoom);
              
              // Update active button styling
              zoomButtons.forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'rgba(255,255,255,0.2)';
                btn.style.color = 'white';
              });
              
              button.classList.add('active');
              button.style.background = '#F2C31B';
              button.style.color = '#303030';
              
              // Track zoom level for before photos
              if (mode === 'before') {
                this.currentBeforeZoom = newZoom;
              }
              
              // Apply zoom to video stream
              await this.applyZoom(stream, videoElementId, newZoom);
            });
          });
        }

        // Apply zoom to video stream using constraints
        async applyZoom(stream, videoElementId, zoomLevel) {
          try {
            const videoTracks = stream.getVideoTracks();
            if (videoTracks.length === 0) {
              console.log('No video tracks found');
              return;
            }

            const track = videoTracks[0];
            const capabilities = track.getCapabilities();
            
            // Check if zoom is supported
            if (capabilities.zoom) {
              const constraints = {
                advanced: [{
                  zoom: Math.max(capabilities.zoom.min, Math.min(capabilities.zoom.max, zoomLevel))
                }]
              };
              
              await track.applyConstraints(constraints);
              console.log(`Applied zoom: ${zoomLevel}x`);
            } else {
              // Fallback: use CSS transform for devices that don't support zoom constraints
              const video = document.getElementById(videoElementId);
              if (video) {
                video.style.transform = `scale(${zoomLevel})`;
                console.log(`Applied CSS zoom fallback: ${zoomLevel}x`);
              }
            }
          } catch (error) {
            console.error('Error applying zoom:', error);
            
            // Fallback to CSS transform if constraints fail
            const video = document.getElementById(videoElementId);
            if (video) {
              video.style.transform = `scale(${zoomLevel})`;
              console.log(`Applied CSS zoom fallback after error: ${zoomLevel}x`);
            }
          }
        }

        // Enhanced photo sizing and cropping system
        // Default sizes for different templates




        // Helper function to calculate square size for grids
        calculateSquareSize(columns) {
          if (this.isLandscape) {
            // In landscape mode, use the height (which equals portrait width) to calculate square size
            const landscapeHeight = window.innerHeight; // This is equivalent to portrait width
            const availableHeight = landscapeHeight - 200; // Account for headers, tabs, padding
            const squareSize = Math.floor(availableHeight / columns);
            
            return squareSize;
          } else {
            // In portrait mode, calculate actual size based on screen width
            const availableWidth = window.innerWidth - 20; // Account for padding
            return Math.floor(availableWidth / columns);
          }
        }

        capturePhoto(video, stream) {
          console.log('üì∏ Capturing before photo with aspect ratio:', this.currentAspectRatio);
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');

          // Get the target aspect ratio for cropping
          const targetAspectRatio = this.currentAspectRatio || '4:3';
          console.log('üì∏ Target aspect ratio for before capture:', targetAspectRatio);

          // Calculate crop dimensions based on aspect ratio
          let cropWidth, cropHeight, cropX, cropY;
          const videoWidth = video.videoWidth;
          const videoHeight = video.videoHeight;
          const videoAspectRatio = videoWidth / videoHeight;

          if (targetAspectRatio === '4:3') {
            // Horizontal mode: 4:3 aspect ratio
            canvas.width = 800;
            canvas.height = 600; // 4:3 ratio

            // Crop to fit 4:3 from center of video
            if (videoAspectRatio > (4/3)) {
              // Video is wider, crop sides
              cropHeight = videoHeight;
              cropWidth = videoHeight * (4/3);
              cropX = (videoWidth - cropWidth) / 2;
              cropY = 0;
            } else {
              // Video is taller, crop top/bottom
              cropWidth = videoWidth;
              cropHeight = videoWidth * (3/4);
              cropX = 0;
              cropY = (videoHeight - cropHeight) / 2;
            }
          } else {
            // Vertical mode: 2:3 aspect ratio
            canvas.width = 600;
            canvas.height = 900; // 2:3 ratio

            // Crop to fit 2:3 from center of video
            if (videoAspectRatio > (2/3)) {
              // Video is wider, crop sides significantly
              cropHeight = videoHeight;
              cropWidth = videoHeight * (2/3);
              cropX = (videoWidth - cropWidth) / 2;
              cropY = 0;
            } else {
              // Video is taller, crop top/bottom
              cropWidth = videoWidth;
              cropHeight = videoWidth * (3/2);
              cropX = 0;
              cropY = (videoHeight - cropHeight) / 2;
            }
          }

          console.log(`üì∏ Before Video: ${videoWidth}x${videoHeight}, Crop: ${cropWidth}x${cropHeight} at (${cropX},${cropY}), Canvas: ${canvas.width}x${canvas.height}`);

          // Draw the cropped video frame
          context.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, canvas.width, canvas.height);
          
          // First photos are always "before" photos
          const photoMode = 'before';
          
          // Create simple position-based name or use pending name from gallery
          const photoName = this.pendingPhotoName || this.generatePhotoName(this.currentRoom, photoMode);
          
          const photo = {
            id: Date.now(),
            dataUrl: canvas.toDataURL('image/jpeg', 0.6),
            room: this.currentRoom,
            mode: photoMode,
            name: photoName,
            timestamp: Date.now(),
            zoomLevel: this.currentBeforeZoom || 1, // Store the zoom level used
            aspectRatio: this.currentAspectRatio || '4:3' // Store the aspect ratio used
          };
          
          console.log('üì∏ Photo created with aspect ratio:', photo.aspectRatio, 'Current mode:', this.currentAspectRatio);
          console.log('üì∏ Full photo object:', photo);
          this.photos.push(photo);
          console.log('üì∏ Photos array length:', this.photos.length);
          this.savePhotos();
          
          // Update the before photo grid in the modal
          const beforePhotoGrid = document.getElementById('before-photo-grid');
          if (beforePhotoGrid) {
            // Store current scroll position and content height
            const previousScrollTop = beforePhotoGrid.scrollTop;
            const previousScrollHeight = beforePhotoGrid.scrollHeight;

            beforePhotoGrid.innerHTML = this.getBeforePhotosGridHTML();
            this.attachBeforePhotoListeners();

            // Smart scrolling to keep content visible above bottom panel
            setTimeout(() => {
              const currentScrollHeight = beforePhotoGrid.scrollHeight;
              const containerHeight = beforePhotoGrid.clientHeight;
              const bottomPanelHeight = 80; // Height of bottom panel

              // If content grew (new photos added), scroll up to accommodate
              if (currentScrollHeight > previousScrollHeight) {
                const heightDifference = currentScrollHeight - previousScrollHeight;

                // Calculate optimal scroll position to keep latest content visible
                // but not hidden behind bottom panel
                const maxVisibleScroll = currentScrollHeight - containerHeight + bottomPanelHeight;
                const newScrollTop = Math.min(previousScrollTop + heightDifference, maxVisibleScroll);

                beforePhotoGrid.scrollTop = Math.max(0, newScrollTop);
                console.log('üì∏ Auto-scrolled up after capturing new photo');
              }
            }, 100);
          }

          // Update main gallery as well
          const photosContainer = document.getElementById('photos-container');
          if (photosContainer) {
            photosContainer.innerHTML = this.getPhotosHTML();
            this.attachPhotoListeners();
          }

          // Check if photo was taken from gallery dummy card (before photo)
          if (this.galleryReturnContext && this.galleryReturnContext.returnToGallery && this.galleryReturnContext.mode === 'before') {
            console.log('Before photo taken from gallery dummy card - closing camera and returning to gallery');
            
            // Close the before photo modal
            setTimeout(() => {
              // Stop camera stream
              const video = document.querySelector('video');
              if (video && video.srcObject) {
                const stream = video.srcObject;
                stream.getTracks().forEach(track => track.stop());
              }
              
              // Close modal overlays
              const existingModals = document.querySelectorAll('[style*="position: fixed"][style*="z-index"]');
              existingModals.forEach(modal => {
                try {
                  if (modal.parentNode &&
                      !modal.id.includes('bottom-panel') &&
                      !modal.id.includes('sticky-tabs-container') &&
                      modal.id !== 'bottom-panel' &&
                      modal.id !== 'sticky-tabs-container') {
                    if (modal.parentNode === document.body) {
                      document.body.removeChild(modal);
                    } else if (modal.parentNode) {
                      modal.parentNode.removeChild(modal);
                    }
                  }
                } catch (error) {
                  console.log('Modal already removed:', error);
                }
              });
              
              // Clear the gallery return context
              this.galleryReturnContext = null;
              
              // Hide action buttons and restore UI
              this.hideActionButtons();
              this.showMainRoomTabs();
              document.body.style.overflow = '';
              
              // Return to All Photos gallery
              setTimeout(() => {
                this.showAllPhotosModal();
              }, 200);
              
            }, 500); // Small delay to let user see the photo was captured
          }

          console.log('Photo capture completed');
        }

        attachBeforePhotoListeners() {
          // Add click listeners to before photo items in the modal
          setTimeout(() => {
            // Delete button listeners
            document.querySelectorAll('.delete-before-photo-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering the photo click
                const photoId = parseInt(e.currentTarget.dataset.photoId);
                const photoIndex = this.photos.findIndex(p => p.id === photoId);
                if (photoIndex !== -1) {
                  this.showDeleteConfirmation('before', this.currentRoom, photoIndex);
                }
              });
            });

            // Photo item click listeners (for enlarging photo)
            document.querySelectorAll('.before-photo-item').forEach(item => {
              item.addEventListener('click', (e) => {
                // Only trigger if clicking on the photo itself, not on buttons
                if (e.target === item || e.target.tagName === 'IMG') {
                  const photoId = parseInt(e.currentTarget.dataset.photoId);
                  const photo = this.photos.find(p => p.id === photoId);
                  if (photo) {
                    // Show enlarged photo
                    this.showPhotoEnlarged(photo);
                  }
                }
              });
            });

            // Room tab listeners in modal
            document.querySelectorAll('#modal-tabs-carousel .room-tab').forEach(btn => {
              btn.addEventListener('click', (e) => {
                const room = e.currentTarget.dataset.room;
                if (room && room !== this.currentRoom) {
                  this.currentRoom = room;
                  this.updateModalRoomTabs();
                  this.updateModalPhotoGrid();
                }
              });
            });

            // Dummy square listeners in modal (for taking new before photos)
            document.querySelectorAll('.dummy-before-photo').forEach(dummy => {
              dummy.addEventListener('click', (e) => {
                // Dummy squares don't do anything special - camera button is already available
                // They just provide visual feedback that more photos can be taken
                console.log('Dummy square clicked - camera button should be used for taking photos');
              });
            });
          }, 100);
        }


        savePhotos() {
          try {
            // Check storage size before saving
            const photosData = JSON.stringify(this.photos);
            const sizeInMB = (photosData.length * 2) / (1024 * 1024); // Rough estimate of size in MB

            localStorage.setItem('cleaning-photos', photosData);
          } catch (e) {
            if (e.name === 'QuotaExceededError') {
              this.manageStorage();
            } else {
              console.error('Error saving photos:', e);
            }
          }
        }

        manageStorage() {
          // Remove oldest photos if storage is full
          const maxPhotos = 50; // Limit to 50 photos total

          if (this.photos.length > maxPhotos) {
            // Sort by timestamp and keep only the newest photos
            this.photos.sort((a, b) => b.timestamp - a.timestamp);
            const removedCount = this.photos.length - maxPhotos;
            this.photos = this.photos.slice(0, maxPhotos);

            console.log(`üßπ Removed ${removedCount} oldest photos to free up storage`);

            // Try saving again
            try {
              localStorage.setItem('cleaning-photos', JSON.stringify(this.photos));

              // Update the UI to reflect the changes
              const photosContainer = document.getElementById('photos-container');
              if (photosContainer) {
                photosContainer.innerHTML = this.getPhotosHTML();
                this.attachPhotoListeners();
              }
            } catch (e) {
              alert('Storage is full. Please delete some photos manually.');
            }
          } else {
            // If we don't have too many photos, try compressing them
            this.compressPhotosAndSave();
          }
        }

        compressPhotosAndSave() {
          console.log('üóúÔ∏è Attempting to compress photos...');

          // Compress images by reducing quality
          const compressedPhotos = this.photos.map(photo => {
            if (photo.dataUrl && photo.dataUrl.startsWith('data:image/')) {
              // Create a canvas to re-compress the image
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();

              return new Promise(resolve => {
                img.onload = () => {
                  // Reduce size if image is too large
                  const maxWidth = 800;
                  const maxHeight = 600;
                  let { width, height } = img;

                  if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                  }

                  canvas.width = width;
                  canvas.height = height;

                  ctx.drawImage(img, 0, 0, width, height);

                  // Compress with lower quality
                  const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.5);
                  resolve({ ...photo, dataUrl: compressedDataUrl });
                };
                img.src = photo.dataUrl;
              });
            }
            return Promise.resolve(photo);
          });

          Promise.all(compressedPhotos).then(compressed => {
            this.photos = compressed;
            try {
              localStorage.setItem('cleaning-photos', JSON.stringify(this.photos));
            } catch (e) {
              // Fall back to removing old photos
              this.manageStorage();
            }
          });
        }
        
        loadPhotos() {
          const saved = localStorage.getItem('cleaning-photos');
          if (saved) {
            this.photos = JSON.parse(saved);
          }
        }

        // User data storage methods
        getStoredUserData() {
          const stored = localStorage.getItem('user-preferences');
          if (stored) {
            try {
              return JSON.parse(stored);
            } catch (e) {
              console.error('Error parsing stored user data:', e);
              return {};
            }
          }
          return {};
        }

        saveUserData(cleaner, location) {
          const userData = {
            cleaner: cleaner,
            location: location,
            savedAt: Date.now()
          };
          localStorage.setItem('user-preferences', JSON.stringify(userData));
          console.log('User preferences saved:', userData);
        }

        clearUserData() {
          localStorage.removeItem('user-preferences');
          console.log('User preferences cleared');
        }

        showChangeUserWarning() {
          // Get current user info for the warning
          const urlParams = new URLSearchParams(window.location.search);
          const currentCleaner = urlParams.get('cleaner') || 'Current User';
          
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: rgba(0,0,0,0.6); z-index: 3000; display: flex; 
            align-items: center; justify-content: center; padding: 20px; box-sizing: border-box;
            backdrop-filter: blur(5px);
          `;
          
          modal.innerHTML = `
            <div style="
              background: white; 
              border-radius: 20px; 
              padding: 40px; 
              max-width: 400px; 
              width: 100%; 
              box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
              text-align: center;
              font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif;
              animation: slideIn 0.3s ease-out;
            ">
              <!-- Warning Icon -->
              <div style="font-size: 64px; margin-bottom: 20px; color: #F2C31B;">
                ‚ö†Ô∏è
              </div>
              
              <!-- Title -->
              <h2 style="margin: 0 0 16px 0; color: #303030; font-size: 24px; font-weight: bold;">
                Switch User?
              </h2>
              
              <!-- Message -->
              <div style="margin-bottom: 24px; color: #666; font-size: 16px; line-height: 1.5;">
                <p style="margin: 0 0 12px 0;">You are currently signed in as:</p>
                <p style="margin: 0 0 16px 0; font-weight: bold; color: #303030; font-size: 18px;">
                  ${currentCleaner}
                </p>
                <p style="margin: 0; font-size: 14px;">
                  Switching users will clear your stored preferences and you'll need to sign in again.
                </p>
              </div>
              
              <!-- Buttons -->
              <div style="display: flex; gap: 12px; justify-content: center;">
                <button id="cancel-change-user" style="
                  background: #f8f9fa; 
                  color: #666; 
                  border: 2px solid #e1e5e9; 
                  padding: 12px 24px; 
                  border-radius: 10px; 
                  font-size: 16px; 
                  font-weight: bold; 
                  cursor: pointer; 
                  transition: all 0.2s;
                  font-family: inherit;
                " onmouseover="this.style.background='#e9ecef'; this.style.borderColor='#d1d5db'" onmouseout="this.style.background='#f8f9fa'; this.style.borderColor='#e1e5e9'">
                  Cancel
                </button>
                
                <button id="confirm-change-user" style="
                  background: #F2C31B; 
                  color: #303030; 
                  border: 2px solid #F2C31B; 
                  padding: 12px 24px; 
                  border-radius: 10px; 
                  font-size: 16px; 
                  font-weight: bold; 
                  cursor: pointer; 
                  transition: all 0.2s;
                  font-family: inherit;
                  box-shadow: 0 4px 12px rgba(242, 195, 27, 0.3);
                " onmouseover="this.style.background='#E6B800'; this.style.borderColor='#E6B800'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='#F2C31B'; this.style.borderColor='#F2C31B'; this.style.transform='translateY(0)'">
                  Switch User
                </button>
              </div>
            </div>
            
            <style>
              @keyframes slideIn {
                from {
                  opacity: 0;
                  transform: scale(0.8) translateY(20px);
                }
                to {
                  opacity: 1;
                  transform: scale(1) translateY(0);
                }
              }
            </style>
          `;
          
          document.body.appendChild(modal);
          
          // Prevent background scrolling
          document.body.style.overflow = 'hidden';
          
          // Event listeners
          document.getElementById('cancel-change-user').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
          });
          
          document.getElementById('confirm-change-user').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
            
            // Clear user data and redirect
            this.clearUserData();
            window.location.href = `${window.location.origin}${window.location.pathname}`;
          });
          
          // Close on backdrop click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
            }
          });
          
          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              if (document.body.contains(modal)) {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
              }
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        showClearDataWarning(nameInput, cityInput, clearDataContainer) {
          // Get stored user info for the warning
          const storedData = this.getStoredUserData();
          const storedName = storedData.cleaner || 'Unknown User';
          const storedLocation = storedData.location || 'Unknown Location';
          
          const modal = document.createElement('div');
          modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: rgba(0,0,0,0.6); z-index: 3000; display: flex; 
            align-items: center; justify-content: center; padding: 20px; box-sizing: border-box;
            backdrop-filter: blur(5px);
          `;
          
          modal.innerHTML = `
            <div style="
              background: white; 
              border-radius: 20px; 
              padding: 40px; 
              max-width: 400px; 
              width: 100%; 
              box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
              text-align: center;
              font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif;
              animation: slideIn 0.3s ease-out;
            ">
              <!-- Warning Icon -->
              <div style="font-size: 64px; margin-bottom: 20px; color: #F2C31B;">
                üóëÔ∏è
              </div>
              
              <!-- Title -->
              <h2 style="margin: 0 0 16px 0; color: #303030; font-size: 24px; font-weight: bold;">
                Clear Stored Data?
              </h2>
              
              <!-- Message -->
              <div style="margin-bottom: 24px; color: #666; font-size: 16px; line-height: 1.5;">
                <p style="margin: 0 0 12px 0;">This will remove your stored information:</p>
                <div style="margin: 0 0 16px 0; padding: 16px; background: #f8f9fa; border-radius: 10px; border: 2px solid #e1e5e9;">
                  <p style="margin: 0 0 8px 0; font-weight: bold; color: #303030;">
                    üìù Name: ${storedName}
                  </p>
                  <p style="margin: 0; font-weight: bold; color: #303030;">
                    üìç Location: ${storedLocation.charAt(0).toUpperCase() + storedLocation.slice(1).replace('-', ' ')}
                  </p>
                </div>
                <p style="margin: 0; font-size: 14px;">
                  You'll need to enter this information again next time you visit.
                </p>
              </div>
              
              <!-- Buttons -->
              <div style="display: flex; gap: 12px; justify-content: center;">
                <button id="cancel-clear-data" style="
                  background: #f8f9fa; 
                  color: #666; 
                  border: 2px solid #e1e5e9; 
                  padding: 12px 24px; 
                  border-radius: 10px; 
                  font-size: 16px; 
                  font-weight: bold; 
                  cursor: pointer; 
                  transition: all 0.2s;
                  font-family: inherit;
                " onmouseover="this.style.background='#e9ecef'; this.style.borderColor='#d1d5db'" onmouseout="this.style.background='#f8f9fa'; this.style.borderColor='#e1e5e9'">
                  Keep Data
                </button>
                
                <button id="confirm-clear-data" style="
                  background: #dc2626; 
                  color: white; 
                  border: 2px solid #dc2626; 
                  padding: 12px 24px; 
                  border-radius: 10px; 
                  font-size: 16px; 
                  font-weight: bold; 
                  cursor: pointer; 
                  transition: all 0.2s;
                  font-family: inherit;
                  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
                " onmouseover="this.style.background='#b91c1c'; this.style.borderColor='#b91c1c'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='#dc2626'; this.style.borderColor='#dc2626'; this.style.transform='translateY(0)'">
                  Clear Data
                </button>
              </div>
            </div>
            
            <style>
              @keyframes slideIn {
                from {
                  opacity: 0;
                  transform: scale(0.8) translateY(20px);
                }
                to {
                  opacity: 1;
                  transform: scale(1) translateY(0);
                }
              }
            </style>
          `;
          
          document.body.appendChild(modal);
          
          // Prevent background scrolling
          document.body.style.overflow = 'hidden';
          
          // Event listeners
          document.getElementById('cancel-clear-data').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
          });
          
          document.getElementById('confirm-clear-data').addEventListener('click', () => {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
            
            // Clear user data and form
            this.clearUserData();
            // Clear the form fields
            if (nameInput) nameInput.value = '';
            if (cityInput) cityInput.value = '';
            // Hide the clear button
            if (clearDataContainer) clearDataContainer.style.display = 'none';
          });
          
          // Close on backdrop click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              document.body.removeChild(modal);
              document.body.style.overflow = '';
            }
          });
          
          // Close on Escape key
          const handleEscape = (e) => {
            if (e.key === 'Escape') {
              if (document.body.contains(modal)) {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
              }
              document.removeEventListener('keydown', handleEscape);
            }
          };
          document.addEventListener('keydown', handleEscape);
        }

        showSuccessNotification(title, message, icon = '‚úÖ') {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed; top: 20px; right: 20px; 
            background: white; border-radius: 12px; 
            padding: 20px; max-width: 350px; width: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
            z-index: 4000; display: flex; align-items: flex-start; gap: 12px;
            font-family: 'EB Garamond', 'Garamond', 'Times New Roman', serif;
            border-left: 4px solid #10B981;
            animation: slideInRight 0.4s ease-out;
          `;
          
          notification.innerHTML = `
            <!-- Success Icon -->
            <div style="font-size: 24px; color: #10B981; margin-top: 2px;">
              ${icon}
            </div>
            
            <!-- Content -->
            <div style="flex: 1;">
              <h3 style="margin: 0 0 8px 0; color: #303030; font-size: 18px; font-weight: bold;">
                ${title}
              </h3>
              <p style="margin: 0; color: #666; font-size: 14px; line-height: 1.4;">
                ${message}
              </p>
            </div>
            
            <!-- Close button -->
            <button id="close-notification" style="
              background: none; border: none; color: #999; 
              font-size: 16px; cursor: pointer; padding: 4px;
              border-radius: 4px; transition: all 0.2s;
            " onmouseover="this.style.background='#f3f4f6'; this.style.color='#666'" onmouseout="this.style.background='none'; this.style.color='#999'">
              ‚úï
            </button>
            
            <style>
              @keyframes slideInRight {
                from {
                  opacity: 0;
                  transform: translateX(100px);
                }
                to {
                  opacity: 1;
                  transform: translateX(0);
                }
              }
              
              @keyframes slideOutRight {
                from {
                  opacity: 1;
                  transform: translateX(0);
                }
                to {
                  opacity: 0;
                  transform: translateX(100px);
                }
              }
            </style>
          `;
          
          document.body.appendChild(notification);
          
          // Close button functionality
          const closeBtn = notification.querySelector('#close-notification');
          closeBtn.addEventListener('click', () => {
            this.removeNotification(notification);
          });
          
          // Auto-remove after 4 seconds
          setTimeout(() => {
            if (document.body.contains(notification)) {
              this.removeNotification(notification);
            }
          }, 4000);
          
          // Click anywhere on notification to close
          notification.addEventListener('click', (e) => {
            if (e.target !== closeBtn) {
              this.removeNotification(notification);
            }
          });
        }

        removeNotification(notification) {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => {
            if (document.body.contains(notification)) {
              document.body.removeChild(notification);
            }
          }, 300);
        }

        showDeleteSuccessNotification(count = 1) {
          const title = count > 1 ? 'Photos Deleted!' : 'Photo Deleted!';
          const message = count > 1 
            ? `Successfully deleted ${count} photos from your gallery.`
            : 'Photo has been successfully removed from your gallery.';
          
          this.showSuccessNotification(title, message, 'üóëÔ∏è');
        }

        showUploadSuccessNotification(count, albumName) {
          const title = count > 1 ? 'Photos Uploaded!' : 'Photo Uploaded!';
          const message = count > 1
            ? `Successfully uploaded ${count} photos to "${albumName}".`
            : `Successfully uploaded photo to "${albumName}".`;
          
          this.showSuccessNotification(title, message, 'üì§');
        }
      }
      
      // Initialize app
      const app = new CleaningPhotoApp();

      // Make app available globally for debugging
      window.app = app;
      window.testRoomTabs = () => app.testRoomTabs();

    </script>
    
    <!-- Fallback for browsers that don't support ES6 modules -->
    <script nomodule>
      document.getElementById('debug-info').innerHTML += '<div style="color: orange;">‚ö†Ô∏è ES6 modules not supported</div>';
      
      // Show a simple message instead of React app
      setTimeout(() => {
        document.getElementById('root').innerHTML = `
          <div style="padding: 20px; text-align: center; font-family: Arial, sans-serif;">
            <h1>üö´ Browser Compatibility Issue</h1>
            <p>Your browser doesn't support ES6 modules, which are required for this app.</p>
            <p>Please update your browser or try a different browser.</p>
            <p style="color: #666; font-size: 14px;">iOS Safari 10.3+ is required for ES6 module support.</p>
          </div>
        `;
      }, 2000);
    </script>
    
  </body>
</html>